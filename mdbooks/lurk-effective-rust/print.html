<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Effective Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-23228806-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
        <meta name="description" content="A collection of specific ways to improve your use of Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/third_party/ferris/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cover.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="use-types.html"><strong aria-hidden="true">3.1.</strong> Item 1: Use the type system to express your data structures</a></li><li class="chapter-item expanded "><a href="use-types-2.html"><strong aria-hidden="true">3.2.</strong> Item 2: Use the type system to express common behaviour</a></li><li class="chapter-item expanded "><a href="transform.html"><strong aria-hidden="true">3.3.</strong> Item 3: Avoid matching Option and Result</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">3.4.</strong> Item 4: Prefer idiomatic Error variants</a></li><li class="chapter-item expanded "><a href="std-traits.html"><strong aria-hidden="true">3.5.</strong> Item 5: Familiarize yourself with standard traits</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">3.6.</strong> Item 6: Understand type conversions</a></li><li class="chapter-item expanded "><a href="newtype.html"><strong aria-hidden="true">3.7.</strong> Item 7: Embrace the newtype pattern</a></li><li class="chapter-item expanded "><a href="builders.html"><strong aria-hidden="true">3.8.</strong> Item 8: Use builders for complex types</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.9.</strong> Item 9: Familiarize yourself with reference and pointer types</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">3.10.</strong> Item 10: Consider using iterator transforms instead of explicit loops</a></li><li class="chapter-item expanded "><a href="raii.html"><strong aria-hidden="true">3.11.</strong> Item 11: Implement the Drop trait for RAII patterns</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">3.12.</strong> Item 12: Prefer generics to trait objects</a></li><li class="chapter-item expanded "><a href="default-impl.html"><strong aria-hidden="true">3.13.</strong> Item 13: Use default implementations to minimize required trait methods</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">4.1.</strong> Item 14: Understand lifetimes</a></li><li class="chapter-item expanded "><a href="borrows.html"><strong aria-hidden="true">4.2.</strong> Item 15: Understand the borrow checker</a></li><li class="chapter-item expanded "><a href="unsafe.html"><strong aria-hidden="true">4.3.</strong> Item 16: Avoid writing unsafe code</a></li><li class="chapter-item expanded "><a href="deadlock.html"><strong aria-hidden="true">4.4.</strong> Item 17: Be wary of shared-state parallelism</a></li><li class="chapter-item expanded "><a href="panic.html"><strong aria-hidden="true">4.5.</strong> Item 18: Don't panic</a></li><li class="chapter-item expanded "><a href="reflection.html"><strong aria-hidden="true">4.6.</strong> Item 19: Avoid reflection</a></li><li class="chapter-item expanded "><a href="optimize.html"><strong aria-hidden="true">4.7.</strong> Item 20: Avoid the temptation to over-optimize</a></li></ol></li><li class="chapter-item expanded "><a href="deps.html"><strong aria-hidden="true">5.</strong> Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="semver.html"><strong aria-hidden="true">5.1.</strong> Item 21: Understand what semantic versioning promises</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.2.</strong> Item 22: Minimize visibility</a></li><li class="chapter-item expanded "><a href="wildcard.html"><strong aria-hidden="true">5.3.</strong> Item 23: Avoid wildcard imports</a></li><li class="chapter-item expanded "><a href="re-export.html"><strong aria-hidden="true">5.4.</strong> Item 24: Re-export dependencies whose types appear in your API</a></li><li class="chapter-item expanded "><a href="dep-graph.html"><strong aria-hidden="true">5.5.</strong> Item 25: Manage your dependency graph</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">5.6.</strong> Item 26: Be wary of feature creep</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">6.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">6.1.</strong> Item 27: Document public interfaces</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">6.2.</strong> Item 28: Use macros judiciously</a></li><li class="chapter-item expanded "><a href="clippy.html"><strong aria-hidden="true">6.3.</strong> Item 29: Listen to Clippy</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.4.</strong> Item 30: Write more than unit tests</a></li><li class="chapter-item expanded "><a href="use-tools.html"><strong aria-hidden="true">6.5.</strong> Item 31: Take advantage of the tooling ecosystem</a></li><li class="chapter-item expanded "><a href="ci.html"><strong aria-hidden="true">6.6.</strong> Item 32: Set up a continuous integration (CI) system</a></li></ol></li><li class="chapter-item expanded "><a href="beyond-std.html"><strong aria-hidden="true">7.</strong> Beyond Standard Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="no-std.html"><strong aria-hidden="true">7.1.</strong> Item 33: Consider making library code no_std compatible</a></li><li class="chapter-item expanded "><a href="ffi.html"><strong aria-hidden="true">7.2.</strong> Item 34: Control what crosses FFI boundaries</a></li><li class="chapter-item expanded "><a href="bindgen.html"><strong aria-hidden="true">7.3.</strong> Item 35: Prefer bindgen to manual FFI mappings</a></li></ol></li><li class="chapter-item expanded "><a href="indexing.html"><strong aria-hidden="true">8.</strong> Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <br/>
<br/>
<br/>
<br/>
<h1 id="effective-rust"><a class="header" href="#effective-rust"><center>Effective Rust</center></a></h1>
<h3 id="35-specific-ways-to-improve-your-rust-code"><a class="header" href="#35-specific-ways-to-improve-your-rust-code"><center>35 Specific Ways to Improve Your Rust Code</center></a></h3>
<br/>
<br/>
<h2 id="david-drysdale"><a class="header" href="#david-drysdale"><center>David Drysdale</center></a></h2>
<br/>
<br/>
<br/>
<aside id="oreilly" style="background-color:#b0f5ce; color:#000000;">
<p>A printed and ebook version of this book is published by
<a href="https://learning.oreilly.com/library/view/effective-rust/9781098151393/">O'Reilly Media</a>:</p>
<table style="border-style:hidden;">
<trow>
<td style="vertical-align:top;">
<img alt="Printed book cover showing crab" src="images/cover.jpg" title="Book cover" width="300"/>
<td>
<p>
Release date: April 2024<br/>
Page count: 280 pages<br/>
ISBN: 9781098151409<br/>
<p>
<p>Available at:
<ul>
<li><a href="https://www.amazon.com/Effective-Rust-Specific-Ways-Improve/dp/1098151402">ðŸ‡ºðŸ‡¸ Amazon.com</a>
<li><a href="https://www.amazon.co.uk/Effective-Rust-Specific-Ways-Improve/dp/1098151402">ðŸ‡¬ðŸ‡§ Amazon.co.uk</a>
<li><a href="https://www.barnesandnoble.com/w/effective-rust-david-drysdale/1144437517">ðŸ‡ºðŸ‡¸ Barnes &amp; Noble</a>
<li><a href="https://www.waterstones.com/book/effective-rust/david-drysdale/9781098151409">ðŸ‡¬ðŸ‡§ Waterstones</a>
<li>and many other book stores.
</ul>
</trow>
</table>
</aside>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<blockquote>
<p>&quot;The code is more what you'd call 'guidelines' than actual rules.&quot; â€“ <a name="a001"></a>Hector Barbossa</p>
</blockquote>
<p><a name="a002"></a>Scott Meyers' original <a name="a003"></a><em>Effective C++</em> book was phenomenally successful because it introduced
a new style of programming book, focused on a collection of guidelines that had been learned from real world experience
of creating software in <a name="a004"></a>C++. Significantly, those guidelines were explained in the context of the reasons why they
were necessary â€“ allowing the reader to decide for themselves whether their particular scenario warranted breaking
the rules.</p>
<p>The first edition of <em>Effective C++</em> was published in 1992, and at that time C++, although young, was already a subtle
language that included many footguns; having a guide to the interactions of its different features was essential.</p>
<p>Rust is also a young language, but in contrast to C++ it is remarkably free of footguns. The strength and consistency of
its type system means that if a Rust program compiles, there is already a decent chance that it will work â€“ a
phenomenon previously only observed with more academic, less accessible languages such as Haskell.</p>
<p>This safety â€“ both type safety and memory safety â€“ does come with a cost, though.  Rust has a reputation for
having a steep on-ramp, where newcomers have to go through the initiation rituals of fighting the <a name="a005"></a>borrow checker,
redesigning their data structures and being befuddled by <a name="a006"></a>lifetimes. A Rust program that compiles may have a good
chance of just working, but the struggle to get it to compile is real â€“ even with the Rust compiler's remarkably
helpful error diagnostics.</p>
<p>As a result, this book is aimed at a slightly different level than other <em>Effective &lt;Language&gt;</em> books; there are
more Items that cover the concepts that are new with Rust, even though the official documentation already includes good
introductions of these topics.  These Items have titles like &quot;<em>Understandâ€¦</em>&quot; and &quot;<em>Familiarize yourself withâ€¦</em>&quot;.</p>
<p>Rust's safety also leads to a complete absence of Items titled &quot;<em>Neverâ€¦</em>&quot;. If you really should never do
something, the compiler will generally prevent you from doing it.</p>
<p>That said, the text still assumes an understanding of the basics of the language. It also assumes the 2018 edition of
Rust, using the stable toolchain.</p>
<p>The specific <code>rustc</code> version used for code fragments and error messages is 1.60.  Rust is now stable enough
(and has sufficient <a name="a007"></a>back-compatibility guarantees) that the code fragments are unlikely to need changes for later
versions, but the error messages may vary with your particular compiler version.</p>
<p>The text also has a number of references to and comparisons with C++, as this is probably the closest equivalent
language (particularly with <a name="a008"></a>C++11's move semantics), and the most likely previous language that newcomers to Rust will
have encountered.</p>
<p>The Items that make up the book are divided into six sections:</p>
<ul>
<li><strong>Types</strong>: Suggestions that revolve around Rust's core type system.</li>
<li><strong>Concepts</strong>: Core ideas that form the design of Rust.</li>
<li><strong>Dependencies</strong>: Advice for working with Rust's package ecosystem.</li>
<li><strong>Tooling</strong>: Suggestions on how to improve your codebase by going beyond just the Rust compiler.</li>
<li><strong>Asynchronous Rust</strong>: Advice for working with Rust's <code>async</code> mechanisms.</li>
<li><strong>Beyond Standard Rust</strong>: Suggestions for when you have to work beyond Rust's standard, safe environment.</li>
</ul>
<p>Although the &quot;Concepts&quot; section is arguably more fundamental than the &quot;Types&quot; section, it is deliberately placed second
so that readers who are reading from beginning to end can build up some confidence first.</p>
<p><span id="ferris"></span></p>
<p>The following markers, borrowing <a name="a009"></a>Ferris from the <a href="https://doc.rust-lang.org/stable/book/ch00-00-introduction.html#ferris">Rust
Book</a>, are used to identify code that isn't
right in some way.</p>
<div class="table-wrapper"><table><thead><tr><th>Ferris</th><th>Meaning</th></tr></thead><tbody>
<tr><td><img src="third_party/ferris/does_not_compile.svg" class="ferris-explain"/></td><td>This code does not compile!</td></tr>
<tr><td><img src="third_party/ferris/panics.svg" class="ferris-explain"/></td><td>This code panics!</td></tr>
<tr><td><img src="third_party/ferris/unsafe.svg" class="ferris-explain"/></td><td>This code block contains unsafe code.</td></tr>
<tr><td><img src="third_party/ferris/not_desired_behaviour.svg" class="ferris-explain"/></td><td>This code does not produce the desired behaviour.</td></tr>
</tbody></table>
</div>
<h2 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h2>
<p>My thanks go to:</p>
<ul>
<li>Tiziano Santoro, from whom I originally learned many things about Rust.</li>
<li>Julian Rosse, who spotted dozens of typos and other errors in the online text.</li>
<li>Martin Disch, who pointed out potential improvements and inaccuracies in several Items.</li>
<li>Chris Fleetwood, Sergey Kaunov, Clifford Matthews, Remo Senekowitsch, Kirill Zaborsky, and an anonymous ProtonMail
user, who pointed out mistakes in the text.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>The first section of this book covers advice that revolves around Rust's <a name="a001"></a>type system.  This type system is more
expressive than that of other mainstream languages; it has more in common with &quot;academic&quot; languages such as
<a name="a002"></a><a href="https://ocaml.org/">OCaml</a> or <a name="a003"></a><a href="https://www.haskell.org/">Haskell</a>.</p>
<p>One core part of this is Rust's <a name="a004"></a><code>enum</code> type, which is considerably more expressive than the enumeration types in
other languages, and which allows for <a name="a005"></a><a href="https://en.wikipedia.org/wiki/Algebraic_data_type"><em>algebraic data
types</em></a>.</p>
<p>The other core pillar of Rust's type system is the <a name="a006"></a><code>trait</code> type. Traits are roughly equivalent to interface types
in other languages, but they are also tied to Rust's <em><a name="a007"></a>generics</em> (<a href="generics.html">Item 12</a>), to allow interface re-use without runtime
overhead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-1-use-the-type-system-to-express-your-data-structures"><a class="header" href="#item-1-use-the-type-system-to-express-your-data-structures">Item 1: Use the type system to express your data structures</a></h1>
<blockquote>
<p>&quot;who called them programers and not type writers&quot; â€“
<a name="a001"></a><a href="https://twitter.com/thingskatedid/status/1400213496785108997">@thingskatedid</a></p>
</blockquote>
<p>The basics of Rust's <a name="a002"></a>type system are pretty familiar to anyone coming
from another statically typed programming language (such as <a name="a003"></a>C++, <a name="a004"></a>Go or <a name="a005"></a>Java).
There's a collection of integer types with specific sizes, both signed
(<a name="a006"></a><a href="https://doc.rust-lang.org/std/primitive.i8.html"><code>i8</code></a>,
<a name="a007"></a><a href="https://doc.rust-lang.org/std/primitive.i16.html"><code>i16</code></a>,
<a name="a008"></a><a href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>,
<a name="a009"></a><a href="https://doc.rust-lang.org/std/primitive.i64.html"><code>i64</code></a>,
<a name="a010"></a><a href="https://doc.rust-lang.org/std/primitive.i128.html"><code>i128</code></a>)
and unsigned
(<a name="a011"></a><a href="https://doc.rust-lang.org/std/primitive.u8.html"><code>u8</code></a>,
<a name="a012"></a><a href="https://doc.rust-lang.org/std/primitive.u16.html"><code>u16</code></a>,
<a name="a013"></a><a href="https://doc.rust-lang.org/std/primitive.u32.html"><code>u32</code></a>,
<a name="a014"></a><a href="https://doc.rust-lang.org/std/primitive.u64.html"><code>u64</code></a>,
<a name="a015"></a><a href="https://doc.rust-lang.org/std/primitive.u128.html"><code>u128</code></a>).</p>
<p>There's also signed (<a name="a016"></a><a href="https://doc.rust-lang.org/std/primitive.isize.html"><code>isize</code></a>) and unsigned
(<a name="a017"></a><a href="https://doc.rust-lang.org/std/primitive.usize.html"><code>usize</code></a>) integers whose size matches the pointer size on
the target system.  Rust isn't a language where you're going to be doing much in the way of converting between pointers
and integers, so that characterization isn't really relevant. However, standard collections return their size as a
<code>usize</code> (from <code>.len()</code>), so collection indexing means that <code>usize</code> values are quite common â€“ which is obviously
fine from a capacity perspective, as there can't be more items in an in-memory collection than there are memory
addresses on the system.</p>
<p>The integral types do give us the first hint that Rust is a stricter world than C++ â€“ attempting to
<a name="a018"></a> put a quart (<code>i32</code>) into a pint pot (<code>i16</code>) generates a compile-time error.</p>
<pre><code class="language-rust ignore does_not_compile">        let x: i32 = 42;
        let y: i16 = x;</code></pre>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:14:22
   |
14 |         let y: i16 = x;
   |                ---   ^ expected `i16`, found `i32`
   |                |
   |                expected due to this
   |
help: you can convert an `i32` to an `i16` and panic if the converted value doesn't fit
   |
14 |         let y: i16 = x.try_into().unwrap();
   |                       ++++++++++++++++++++
</code></pre>
<p>This is reassuring: Rust is not going to sit there quietly while the programmer does things that are risky.  It also
gives an early indication that while Rust has stronger rules, it also has helpful compiler messages that point the way
to how to comply with the rules.  The suggested solution raises the question of how to handle situations where the
conversion would alter the value, and we'll have more to say on both <a name="a019"></a>error handling (<a href="errors.html">Item 4</a>) and using
<a name="a020"></a><code>panic!</code> (<a href="panic.html">Item 18</a>) later.</p>
<p>Rust also doesn't allow some things that might appear &quot;safe&quot;:</p>
<pre><code class="language-rust ignore does_not_compile">        let x = 42i32; // Integer literal with type suffix
        let y: i64 = x;</code></pre>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:23:22
   |
23 |         let y: i64 = x;
   |                ---   ^ expected `i64`, found `i32`
   |                |
   |                expected due to this
   |
help: you can convert an `i32` to an `i64`
   |
23 |         let y: i64 = x.into();
   |                       +++++++
</code></pre>
<p>Here, the suggested solution doesn't raise the spectre of error handling, but the conversion does still need to be
explicit. We'll discuss type conversions in more detail later (<a href="casts.html">Item 6</a>).</p>
<p>Continuing with the unsurprising primitive types, Rust has a
<a name="a021"></a><a href="https://doc.rust-lang.org/std/primitive.bool.html"><code>bool</code></a> type, <a name="a022"></a>floating point types
(<a name="a023"></a><a href="https://doc.rust-lang.org/std/primitive.f32.html"><code>f32</code></a>,
<a name="a024"></a><a href="https://doc.rust-lang.org/std/primitive.f64.html"><code>f64</code></a>)
and a <a name="a025"></a><a href="https://en.wikipedia.org/wiki/Unit_type">unit type</a> <a name="a026"></a><a href="https://doc.rust-lang.org/std/primitive.unit.html"><code>()</code></a>
(like C's <a name="a027"></a><code>void</code>).</p>
<p>More interesting is the <a name="a028"></a><a href="https://doc.rust-lang.org/std/primitive.char.html"><code>char</code></a> character type, which holds a
<a name="a029"></a><a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode value</a> (similar to Go's <a href="https://golang.org/doc/go1#rune"><code>rune</code>
type</a>). Although this is stored as 4 bytes internally, there are again no silent
conversions to or from a 32-bit integer.</p>
<p>This precision in the type system forces you to be explicit about what you're trying to express â€“ a <code>u32</code> value is
different than a <code>char</code>, which in turn is different than a sequence of <a name="a030"></a>UTF-8 bytes, which in turn is different
than a sequence of arbitrary bytes, and it's up to you to specify exactly which you mean<sup><a name="to-footnote-1"><a href="use-types.html#footnote-1">1</a></a></sup>.  Joel Spolsky's <a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">famous blog
post</a> can help you understand which you need.</p>
<p>Of course, there are helper methods that allow you to convert between these different types, but their signatures force
you to handle (or explicitly ignore) the possibility of failure.  For example, a <a name="a031"></a>Unicode code point<sup><a name="to-footnote-2"><a href="use-types.html#footnote-2">2</a></a></sup> can always be represented in 32 bits, so <code>'a' as u32</code>
is allowed, but the other direction is trickier (as there are <code>u32</code> values that are not valid Unicode code points):</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.char.html#method.from_u32"><code>char::from_u32</code></a> returns an <code>Option&lt;char&gt;</code>
forcing the caller to handle the failure case</li>
<li><a href="https://doc.rust-lang.org/std/primitive.char.html#method.from_u32_unchecked"><code>char::from_u32_unchecked</code></a> makes the
assumption of validity, but is marked <code>unsafe</code> as a result, forcing the caller to use <code>unsafe</code> too (<a href="unsafe.html">Item 16</a>).</li>
</ul>
<h2 id="aggregate-types"><a class="header" href="#aggregate-types">Aggregate Types</a></h2>
<p>Moving on to aggregate types, Rust has:</p>
<ul>
<li><a name="a032"></a><a href="https://doc.rust-lang.org/std/primitive.array.html">Arrays</a>, which hold multiple instances of a single
type, where the number of instances is known at compile time.  For example <code>[u32; 4]</code> is four 4-byte integers in a
row.</li>
<li><a name="a033"></a><a href="https://doc.rust-lang.org/std/primitive.tuple.html">Tuples</a>, which hold instances of multiple
heterogeneous types, where the number of elements and their types are known at compile time, for example
<code>(WidgetOffset, WidgetSize, WidgetColour)</code>.  If the types in the tuple aren't distinctive â€“ for example <code>(i32, i32, &amp;'static str, bool)</code> â€“ it's better to give each element a name and useâ€¦</li>
<li><a name="a034"></a><a href="https://doc.rust-lang.org/std/keyword.struct.html">Structs</a>, which also hold instances of heterogeneous
types known at compile time, but which allows both the overall type and the individual fields to be referred to by
name.</li>
</ul>
<p>The <em><a name="a035"></a>tuple struct</em> is a cross-breed of a <code>struct</code> with a tuple: there's a name for the overall type, but no names
for the individual fields â€“ they are referred to by number instead: <code>s.0</code>, <code>s.1</code>, etc.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct TextMatch(usize, String);
    let m = TextMatch(12, &quot;needle&quot;.to_owned());
    assert_eq!(m.0, 12);
<span class="boring">}</span></code></pre></pre>
<p>This brings us to the jewel in the crown of Rust's type system, the <a name="a036"></a><code>enum</code>.</p>
<p>In its basic form, it's hard to see what there is to get excited about.  As with other languages, the <code>enum</code> allows you
to specify a set of mutually exclusive values, possibly with a numeric or string value attached.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    enum HttpResultCode {
        Ok = 200,
        NotFound = 404,
        Teapot = 418,
    }
    let code = HttpResultCode::NotFound;
    assert_eq!(code as i32, 404);
<span class="boring">}</span></code></pre></pre>
<p>Because each <code>enum</code> definition creates a distinct type, this can be used to improve readability and maintainability of
functions that take <a name="a037"></a><code>bool</code> arguments. Instead of:</p>
<pre><code class="language-rust ignore">        print_page(/* both_sides= */ true, /* colour= */ false);</code></pre>
<p>a version that uses a pair of <code>enum</code>s:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub enum Sides {
        Both,
        Single,
    }

    pub enum Output {
        BlackAndWhite,
        Colour,
    }

    pub fn print_page(sides: Sides, colour: Output) {
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>is more type-safe and easier to read at the point of invocation:</p>
<pre><code class="language-rust ignore">        print_page(Sides::Both, Output::BlackAndWhite);</code></pre>
<p>Unlike the <code>bool</code> version, if a library user were to accidentally flip the order of the arguments, the compiler would
immediately complain:</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:89:20
   |
89 |         print_page(Output::BlackAndWhite, Sides::Single);
   |                    ^^^^^^^^^^^^^^^^^^^^^ expected enum `enums::Sides`, found enum `enums::Output`
error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:89:43
   |
89 |         print_page(Output::BlackAndWhite, Sides::Single);
   |                                           ^^^^^^^^^^^^^ expected enum `enums::Output`, found enum `enums::Sides`
</code></pre>
<p>(Using the <a name="a038"></a>newtype pattern (<a href="newtype.html">Item 7</a>) to wrap a <code>bool</code> also achieves type safety and maintainability; it's
generally best to use that if the semantics will always be Boolean, and to use an <code>enum</code> if there's a chance that a new
alternative (e.g. <code>Sides::BothAlternateOrientation</code>) could arise in the future.)</p>
<p>The type safety of Rust's <code>enum</code>s continues with the <a name="a039"></a><code>match</code> expression:</p>
<pre><code class="language-rust ignore does_not_compile">        let msg = match code {
            HttpResultCode::Ok =&gt; &quot;Ok&quot;,
            HttpResultCode::NotFound =&gt; &quot;Not found&quot;,
            // forgot to deal with the all-important &quot;I'm a teapot&quot; code
        };</code></pre>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `Teapot` not covered
  --&gt; use-types/src/main.rs:65:25
   |
51 | /     enum HttpResultCode {
52 | |         Ok = 200,
53 | |         NotFound = 404,
54 | |         Teapot = 418,
   | |         ------ not covered
55 | |     }
   | |_____- `HttpResultCode` defined here
...
65 |           let msg = match code {
   |                           ^^^^ pattern `Teapot` not covered
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `HttpResultCode`
</code></pre>
<p>The compiler forces the programmer to consider <em>all</em> of the possibilities<sup><a name="to-footnote-3"><a href="use-types.html#footnote-3">3</a></a></sup>  that are represented by the <code>enum</code>, even if the result is just to add a default arm <code>_ =&gt; {}</code>.
(Note that modern C++ compilers can and do warn about missing <code>switch</code> arms for <code>enum</code>s as well.)</p>
<h2 id="enums-with-fields"><a class="header" href="#enums-with-fields"><code>enum</code>s With Fields</a></h2>
<p>The true power of Rust's <code>enum</code> feature comes from the fact that each variant can have data that
comes along with it, making it into an <a name="a041"></a><a href="https://en.wikipedia.org/wiki/Algebraic_data_type"><em>algebraic data
type</em></a> (ADT).  This is less familiar to
programmers of mainstream languages; in C/C++ terms it's like a combination of an <code>enum</code> with a
<code>union</code> â€“ only type-safe.</p>
<p>This means that the invariants of the program's data structures can be encoded into Rust's type system; states that
don't comply with those invariants won't even compile.  A well-designed <code>enum</code> makes the creator's intent clear to
humans as well as to the compiler:</p>
<pre><code class="language-rust ignore">pub enum SchedulerState {
    Inert,
    Pending(HashSet&lt;Job&gt;),
    Running(HashMap&lt;CpuId, Vec&lt;Job&gt;&gt;),
}</code></pre>
<p>Just from the type definition, it's reasonable to guess that <code>Job</code>s get queued up in the <code>Pending</code> state until the
scheduler is fully active, at which point they're assigned to some per-CPU pool.</p>
<p>This highlights the central theme of this Item, which is to use Rust's type system to express the concepts that are
associated with the design of your software.</p>
<p>A dead giveaway for when this is <em>not</em> happening is a comment that explains when some field or parameter is valid:</p>
<pre><code class="language-rust ignore">struct DisplayProps {
    x: u32,
    y: u32,
    monochrome: bool,
    // `fg_colour` must be (0, 0, 0) if `monochrome` is true.
    fg_colour: RgbColour,
}</code></pre>
<p>This is a prime candidate for replacement with an <code>enum</code> holding data:</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
enum Colour {
    Monochrome,
    Foreground(RgbColour),
}

struct DisplayProperties {
    x: u32,
    y: u32,
    colour: Colour,
}</code></pre>
<p>This small example illustrates a key piece of advice: <strong>make invalid states inexpressible in your types</strong>.  Types that
only support valid combinations of values mean that whole classes of error are rejected by the compiler, leading to
smaller and safer code.</p>
<h2 id="options-and-errors"><a class="header" href="#options-and-errors">Options and Errors</a></h2>
<p>Returning to the power of the <a name="a042"></a><code>enum</code>, there are two concepts that are so common that Rust includes built-in <code>enum</code>
types to express them.</p>
<p>The first is the concept of an <a name="a043"></a><a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>: either there's a
value of a particular type (<a name="a044"></a><code>Some(T)</code>), or there isn't (<a name="a045"></a><code>None</code>). <strong>Always use <code>Option</code> for values
that can be absent</strong>; never fall back to using <a name="a046"></a>sentinel values (-1, <code>nullptr</code>, â€¦) to try to express the
same concept in-band.</p>
<p>There is one subtle point to consider though.  If you're dealing with a <em>collection</em> of things, you need to decide
whether having zero things in the collection is the same as not having a collection. For most situations, the
distinction doesn't arise and you can go ahead and use <code>Vec&lt;Thing&gt;</code>: a count of zero things implies an absence of
things.</p>
<p>However, there are definitely other rare scenarios where the two cases need to be distinguished with
<code>Option&lt;Vec&lt;Thing&gt;&gt;</code> â€“ for example, a cryptographic system might need to distinguish between <a href="https://tools.ietf.org/html/rfc8152#section-4.1">&quot;payload transported
separately&quot;</a> and &quot;empty payload provided&quot;.  (This is related to the
debates around the <a name="a047"></a><a href="https://en.wikipedia.org/wiki/Null_(SQL)"><code>NULL</code> marker</a> columns in <a name="a048"></a>SQL.)</p>
<p>One common edge case that's in the middle is a <code>String</code> which might be absent â€“ does <code>&quot;&quot;</code> or <code>None</code> make more
sense to indicate the absence of a value?  Either way works, but <code>Option&lt;String&gt;</code> clearly communicates the possibility
that this value may be absent.</p>
<p>The second common concept arises from error processing: if a function fails, how should that failure be reported?
Historically, special <a name="a049"></a>sentinel values (e.g. <code>-errno</code> return values from Linux system calls) or <a name="a050"></a>global
variables (<code>errno</code> for POSIX systems) were used. More recently, languages that support multiple or tuple return values
(such as <a name="a051"></a>Go) from functions may have a convention of returning a <code>(result, error)</code> pair, assuming the existence of
some suitable &quot;zero&quot; value for the <code>result</code> when the <code>error</code> is non-&quot;zero&quot;.</p>
<p>In Rust, <strong>always encode the result of an operation that might fail as a <a name="a052"></a><a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;T, E&gt;</code></a></strong>.  The <code>T</code> type holds the successful result (in the
<a name="a053"></a><code>Ok</code> variant), and the <code>E</code> type holds error details (in the <a name="a054"></a><code>Err</code> variant) on failure.  Using the standard
type makes the intent of the design clear, and allows the use of standard transformations (<a href="transform.html">Item 3</a>) and error
processing (<a href="errors.html">Item 4</a>); it also makes it possible to streamline error processing with the <code>?</code> operator.</p>
<p><hr/>
<p><a name="footnote-1"><a href="use-types.html#to-footnote-1">1</a></a>: The situation gets
muddier still if the filesystem is involved, since filenames on popular platforms are somewhere in between arbitrary
bytes and UTF-8 sequences: see the <a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>std::ffi::OsString</code></a>
documentation.</p>
<p><a name="footnote-2"><a href="use-types.html#to-footnote-2">2</a></a>: Technically, a <em>Unicode scalar value</em> rather than a code point</p>
<p><a name="footnote-3"><a href="use-types.html#to-footnote-3">3</a></a>: This also means that adding a new
variant to an existing <code>enum</code> in a library is a <em>breaking change</em> (<a href="semver.html">Item 21</a>): clients of the library will need to change
their code to cope with the new variant.  If an <code>enum</code> is really just an old-style list of values, this behaviour can be
avoided by marking it as a
<a name="a040"></a><a href="https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a>
<code>enum</code>; see <a href="semver.html">Item 21</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-2-use-the-type-system-to-express-common-behaviour"><a class="header" href="#item-2-use-the-type-system-to-express-common-behaviour">Item 2: Use the type system to express common behaviour</a></h1>
<p><a href="use-types.html">Item 1</a> discussed how to express data structures in the type system; this Item moves on to discuss the encoding of
<em>behaviour</em> in Rust's type system.</p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>The first place where behaviour is visible in Rust's type system is the addition of <em><a name="a001"></a>methods</em> to data structures:
functions that act on an item of that type, identified by <code>self</code>.  This encapsulates related data and code together
in a <a name="a002"></a>object-oriented way that's similar to other languages; however, in Rust methods can be added to
to <a name="a003"></a><code>enum</code> types as well as to <a name="a004"></a><code>struct</code> types, in keeping with the pervasive nature of Rust's <code>enum</code> (<a href="use-types.html">Item 1</a>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Shape {
    Rectangle { width: f64, height: f64 },
    Circle { radius: f64 },
}

impl Shape {
    pub fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle { width, height } =&gt; width * height,
            Shape::Circle { radius } =&gt; std::f64::consts::PI * radius * radius,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The name of a method gives a label for the behaviour that it encodes, and the <a name="a005"></a>method signature gives type
information for its inputs and outputs.  The first input for a method will be some variant of <code>self</code>, indicating
what the method might do to the data structure:</p>
<ul>
<li>A <code>&amp;self</code> parameter indicates that the contents of the data structure may be read from, but will not be modified.</li>
<li>A <code>&amp;mut self</code> parameter indicates that the method might modify the contents of the data structure.</li>
<li>A <code>self</code> parameter indicates that the method consumes the data structure.</li>
</ul>
<h2 id="abstracting-behaviour"><a class="header" href="#abstracting-behaviour">Abstracting Behaviour</a></h2>
<p>Invoking a method always results in the same code being executed; all that changes from invocation to invocation is the
data that the method operates on.  That covers a lot of possible scenarios, but what if the <em>code</em> needs to vary at
runtime?</p>
<p>Rust includes several features in its type system to accomodate this, which this section explores.</p>
<h3 id="function-pointers"><a class="header" href="#function-pointers">Function Pointers</a></h3>
<p>The simplest behavioural abstraction is the <a name="a006"></a><a href="https://doc.rust-lang.org/std/primitive.fn.html"><em>function
pointer</em></a>: a pointer to (just) some code, with a type that reflects the
signature of the function.  The type is checked at compile time, so by the time the program runs the value is just the
size of a pointer.</p>
<pre><code class="language-rust ignore">    fn sum(x: i32, y: i32) -&gt; i32 {
        x + y
    }
    // Explicit coercion to `fn` type is required...
    let op: fn(i32, i32) -&gt; i32 = sum;</code></pre>
<p>Function pointers have no other data associated with them, so they can be treated as values in various ways:</p>
<pre><code class="language-rust ignore">    // `fn` types implement `Copy`
    let op1 = op;
    let op2 = op;
    // `fn` types implement `Eq`
    assert!(op1 == op2);
    // `fn` implements `std::fmt::Pointer`, used by the {:p} format specifier.
    println!(&quot;op = {:p}&quot;, op);
    // Example output: &quot;op = 0x101e9aeb0&quot;</code></pre>
<aside>
<p>One technical detail to watch out for: explicit coercion to a <code>fn</code> type is needed, because just using the name of a
function <em>doesn't</em> give you something of <code>fn</code> type;</p>
<pre><code class="language-rust ignore does_not_compile">        let op1 = sum;
        let op2 = sum;
        // Both op1 and op2 are of a type that cannot be named in user code,
        // and this internal type does not implement `Eq`.
        assert!(op1 == op2);</code></pre>
<pre><code class="language-text">error[E0369]: binary operation `==` cannot be applied to type `fn(i32, i32) -&gt; i32 {main::sum}`
   --&gt; use-types-behaviour/src/main.rs:117:21
    |
117 |         assert!(op1 == op2);
    |                 --- ^^ --- fn(i32, i32) -&gt; i32 {main::sum}
    |                 |
    |                 fn(i32, i32) -&gt; i32 {main::sum}
    |
help: you might have forgotten to call this function
    |
117 |         assert!(op1( /* arguments */ ) == op2);
    |                    +++++++++++++++++++
help: you might have forgotten to call this function
    |
117 |         assert!(op1 == op2( /* arguments */ ));
    |                           +++++++++++++++++++
</code></pre>
<p>Instead, the compiler error indicates that the type is something like <code>fn(i32, i32) -&gt; i32 {main::sum}</code>, a type that's
entirely internal to the compiler (i.e. could not be written in user code), and which identifies the specific function as
well as its signature.  To put it another way, the <em>type</em> of <code>sum</code> encodes both the function's signature <em>and</em> its
location (<a href="https://doc.rust-lang.org/std/primitive.fn.html#creating-function-pointers">for optimization reasons</a>); this
type can be automatically <a name="a007"></a><em>coerced</em> (<a href="casts.html">Item 6</a>) to a <code>fn</code> type.</p>
</aside>
<h3 id="closures"><a class="header" href="#closures">Closures</a></h3>
<p>Bare function pointers are limiting, because the only inputs available to the invoked function are those that are
explicitly passed as parameter values.</p>
<p>For example, consider some code that modified every element of a slice using a function pointer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // In real code, an `Iterator` method would be more appropriate.
    pub fn modify_all(data: &amp;mut [u32], mutator: fn(u32) -&gt; u32) {
        for value in data {
            *value = mutator(*value);
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>This works for a simple mutation of the slice:</p>
<pre><code class="language-rust ignore">        fn add2(v: u32) -&gt; u32 {
            v + 2
        }
        let mut data = vec![1, 2, 3];
        modify_all(&amp;mut data, add2);
        assert_eq!(data, vec![3, 4, 5,]);</code></pre>
<p>However, if the modification relies on any additional state, it's not possible to implicitly pass that into the function
pointer.</p>
<pre><code class="language-rust ignore does_not_compile">        let amount_to_add = 3;
        fn add_n(v: u32) -&gt; u32 {
            v + amount_to_add
        }
        let mut data = vec![1, 2, 3];
        modify_all(&amp;mut data, add_n);
        assert_eq!(data, vec![3, 4, 5,]);</code></pre>
<pre><code>error[E0434]: can't capture dynamic environment in a fn item
   --&gt; use-types-behaviour/src/main.rs:142:17
    |
142 |             v + amount_to_add
    |                 ^^^^^^^^^^^^^
    |
    = help: use the `|| { ... }` closure form instead
</code></pre>
<p>The error message points to the right tool for the job: a <em><a name="a008"></a>closure</em>. A closure is a chunk of code that looks like
the body of a function definition (a <em><a name="a009"></a>lambda expression</em>), except that:</p>
<ul>
<li>it can be built as part of an expression, and so need not have a name associated with it</li>
<li>the input parameters are given in vertical bars <code>|param1, param2|</code> (their associated types can usually be
automatically deduced by the compiler)</li>
<li>it can capture parts of the environment around it.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let amount_to_add = 3;
    let add_n = |y| {
        // a closure capturing `amount_to_add`
        y + amount_to_add
    };
    let z = add_n(5);
    assert_eq!(z, 8);
<span class="boring">}</span></code></pre></pre>
<p>To (roughly) understand how the capture works, imagine that the compiler creates a one-off, internal type that
holds all of the parts of the environment that get mentioned in the lambda expression.  When the closure is created, an
instance of this ephemeral type is created to hold the relevant values, and when the closure is invoked that
instance is used as additional context.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let amount_to_add = 3;
    // *Rough* equivalent to a capturing closure.
    struct InternalContext&lt;'a&gt; {
        // references to captured variables
        amount_to_add: &amp;'a u32,
    }
    impl&lt;'a&gt; InternalContext&lt;'a&gt; {
        fn internal_op(&amp;self, y: u32) -&gt; u32 {
            // body of the lambda expression
            y + *self.amount_to_add
        }
    }
    let add_n = InternalContext {
        amount_to_add: &amp;amount_to_add,
    };
    let z = add_n.internal_op(5);
    assert_eq!(z, 8);
<span class="boring">}</span></code></pre></pre>
<p>The values that are held in this notional context are often references (<a href="references.html">Item 9</a>) as here, but they can also be mutable
references to things in the environment, or values that are moved out of the environment altogether (by using the <code>move</code>
keyword before the input parameters).</p>
<p>Returning to the <code>modify_all</code> example, a closure can't be used where a function pointer is expected.</p>
<pre><code>error[E0308]: mismatched types
   --&gt; use-types-behaviour/src/main.rs:165:31
    |
165 |         modify_all(&amp;mut data, |y| y + amount_to_add);
    |                               ^^^^^^^^^^^^^^^^^^^^^ expected fn pointer, found closure
    |
    = note: expected fn pointer `fn(u32) -&gt; u32`
                  found closure `[closure@use-types-behaviour/src/main.rs:165:31: 165:52]`
note: closures can only be coerced to `fn` types if they do not capture any variables
   --&gt; use-types-behaviour/src/main.rs:165:39
    |
165 |         modify_all(&amp;mut data, |y| y + amount_to_add);
    |                                       ^^^^^^^^^^^^^ `amount_to_add` captured here
</code></pre>
<p>Instead, the code that receives the closure has to accept an instance of one of the <code>Fn*</code> traits.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn modify_all&lt;F&gt;(data: &amp;mut [u32], mut mutator: F)
    where
        F: FnMut(u32) -&gt; u32,
    {
        for value in data {
            *value = mutator(*value);
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>Rust has three different <code>Fn*</code> traits, which between them express some distinctions around this environment
capturing behaviour.</p>
<ul>
<li><a name="a010"></a><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> describes a closure that can only be called
<em>once</em>.  If some part of its environment is <code>move</code>d into the closure, then that <code>move</code> can only happen once â€“
there's no other copy of the source item to <code>move</code> from â€“ and so the closure can only be invoked once.</li>
<li><a name="a011"></a><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a> describes a closure that can be called repeatedly,
and which can make changes to its environment because it <em>mutably</em> borrows from the environment.</li>
<li><a name="a012"></a><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a> describes a closure that can be called repeatedly, and
which only borrows values from the environment immutably.</li>
</ul>
<p>The compiler <em>automatically</em> implements the appropriate subset of these <code>Fn*</code> traits for any lambda
expression in the code; it's not possible to manually implement any of these traits<sup><a name="to-footnote-1"><a href="use-types-2.html#footnote-1">1</a></a></sup> (unlike <a name="a013"></a>C++'s <code>operator()</code> overload).</p>
<p>Returning to the rough mental model of closures above, which of the traits the compiler auto-implements roughly
corresponds to whether the captured environmental context has:</p>
<ul>
<li><code>FnOnce</code>: any moved values</li>
<li><code>FnMut</code>: any mutable references to values (<code>&amp;mut T</code>)</li>
<li><code>Fn</code>: only normal references to values (<code>&amp;T</code>).</li>
</ul>
<p>The latter two traits in the list above each has a <a name="a014"></a>trait bound of the preceding trait, which makes sense when you consider
the things that <em>use</em> the closures.</p>
<ul>
<li>If something only expects to call a closure once (indicated by receiving a <code>FnOnce</code>), it's OK to pass it a closure
that's capable of being repeatedly called (<code>FnMut</code>).</li>
<li>If something expects to repeatedly call a closure that might mutate its environment (indicated by receiving a
<code>FnMut</code>), it's OK to pass it a closure that <em>doesn't</em> need to mutate its environment (<code>Fn</code>).</li>
</ul>
<p>The bare function pointer type <code>fn</code> also notionally belongs at the end of this list; any (not-<code>unsafe</code>) <code>fn</code> type
automatically implements all of the <code>Fn*</code> traits, because it borrows nothing from the environment.</p>
<p>As a result, when writing code that accepts closures, <strong>use the most general <code>Fn*</code> trait that works</strong>, to allow the
greatest flexibility for callers â€“ for example, accept <code>FnOnce</code> for closures that are only used once. The same
reasoning also leads to advice to <strong>prefer <code>Fn*</code> trait bounds to bare function pointers (<code>fn</code>)</strong>.</p>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>The <code>Fn*</code> traits are more flexible than a bare function pointer, but they can still only describe the behaviour of a
single function, and even then only in terms of the function's signature.</p>
<p>However, they are themselves examples of another mechanism for describing behaviour in Rust's type system, the
<em><a name="a015"></a>trait</em>. A trait defines a set of related methods that some underlying item
makes publicly available. Each method in a trait also has a <em>name</em>, providing a label which allows the compiler to
disambiguate methods with the same signature, and more importantly which allows programmers to deduce the intent of the
method.</p>
<p>A Rust trait is roughly analogous to an &quot;interface&quot; in <a name="a016"></a>Go and <a name="a017"></a>Java, or to an &quot;<a name="a018"></a>abstract class&quot;
(all virtual methods, no data members) in C++.  Implementations of the trait must provide all the methods (but note that
the trait definition can include a default implementation, <a href="default-impl.html">Item 13</a>), and can also have associated data that those
implementations make use of.  This means that code and data gets encapsulated together in a common abstraction, in a
<em>somewhat</em> <a name="a019"></a>object-oriented manner.</p>
<p>Code that accepts a <code>struct</code> and calls methods on it is constrained to only ever work with that specific type.  If there
are multiple types that implement common behaviour, then it is more flexible to define a trait that encapsulates that
common behaviour, and have the code make use of the trait's methods rather than methods on a specific <code>struct</code>.</p>
<p>This leads to the same kind of advice that turns up for other OO-influenced languages<sup><a name="to-footnote-2"><a href="use-types-2.html#footnote-2">2</a></a></sup>: <strong>prefer accepting trait types to concrete types</strong> if future flexibility is anticipated.</p>
<p>Sometimes, there is some behaviour that you want to distinguish in the type system, but which cannot be expressed as
some specific method signature in a trait definition. For example, consider a trait for sorting collections; an
implementation might be <em>stable</em> (elements that compare the same will appear in the same order before and after the
sort) but there's no way to express this in the <code>sort</code> method arguments.</p>
<p>In this case, it's still worth using the type system to track this requirement, using a <em>marker trait</em>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Sort {
    /// Re-arrange contents into sorted order.
    fn sort(&amp;mut self);
}

/// Marker trait to indicate that a [`Sortable`] sorts stably.
pub trait StableSort: Sort {}
<span class="boring">}</span></code></pre></pre>
<p>A <a name="a021"></a>marker trait has no methods, but an implementation still has to declare that it is implementing the trait â€“
which acts as a promise from the implementer: &quot;I solemnly swear that my implementation sorts stably&quot;.  Code that relies
on a stable sort can then specify the <code>StableSort</code> trait bound, relying on the honour system to preserve its
invariants. <strong>Use marker traits to distinguish behaviours that cannot be expressed in the trait method signatures</strong>.</p>
<p>Once behaviour has been encapsulated into Rust's type system as a trait, there are two ways it can be used:</p>
<ul>
<li>as a <em>trait bound</em>, which constrains what types are acceptable for a <a name="a022"></a>generic data type or method at
compile-time, or</li>
<li>as a <em><a name="a023"></a>trait object</em>. which constrains what types can be stored or passed to a method at run-time.</li>
</ul>
<p><a href="generics.html">Item 12</a> discusses the trade-offs between these in more detail.</p>
<p>A <em><a name="a024"></a>trait bound</em> indicates that generic code which is parameterized by some type <code>T</code> can only be used when that type <code>T</code>
implements some specific trait. The presence of the <a name="a025"></a>trait bound means that the implementation of the generic can
use the methods from that trait, secure in the knowledge that the compiler will ensure that any <code>T</code> that compiles does
indeed have those methods.  This check happens at compile-time, when the generic is
<a name="a026"></a><em>monomorphized</em> (Rust's term for what C++ would call <a name="a027"></a>&quot;template instantiation&quot;).</p>
<p>This restriction on the target type <code>T</code> is <em>explicit</em>, encoded in the trait bounds: the trait can only be implemented by
types that satisfy the trait bounds. This is in contrast to the equivalent situation in C++, where the constraints on
the type <code>T</code> used in a <code>template&lt;typename T&gt;</code> are <em>implicit</em> <sup><a name="to-footnote-3"><a href="use-types-2.html#footnote-3">3</a></a></sup>: C++ template code still only compiles if all of the referenced methods are available at compile-time, but
the checks are purely based on method and signature.  (This <a name="a029"></a><a href="https://en.wikipedia.org/wiki/Duck_typing">&quot;duck
typing&quot;</a> leads to the chance of confusion; a C++ template that uses <code>t.pop()</code>
might compile for a <code>T</code> type parameter of either <code>Stack</code> or <code>Balloon</code> â€“ which is unlikely to be desired
behaviour.)</p>
<p>The need for explicit trait bounds also means that a large fraction of <a name="a030"></a>generics use trait bounds.  To see why this is,
turn the observation around and consider what can be done with a <code>struct Thing&lt;T&gt;</code> where there <em>no</em> trait bounds on
<code>T</code>. Without a trait bound, the <code>Thing</code> can only perform operations that apply to <em>any</em> type <code>T</code>; this allows for
containers, collections and smart pointers, but not much else.  Anything that <em>uses</em> the type <code>T</code> is going to need
a trait bound.</p>
<pre><code class="language-rust ignore">pub fn dump_sorted&lt;T&gt;(mut collection: T)
where
    T: Sort + IntoIterator,
    T::Item: Debug,
{
    // Next line requires `T: Sort` trait bound.
    collection.sort();
    // Next line requires `T: IntoIterator` trait bound.
    for item in collection {
        // Next line requires `T::Item : Debug` trait bound
        println!(&quot;{:?}&quot;, item);
    }
}</code></pre>
<p>So the advice here is to <strong>use trait bounds to express requirements on the types used in generics</strong>, but it's easy
advice to follow â€“ the compiler will force you to comply with it regardless.</p>
<p>A <em><a name="a031"></a>trait object</em> is the other way of making use of the encapsulation defined by a trait, but here different possible
implementations of the trait are chosen at run-time rather than compile-time.  This <em>dynamic dispatch</em> is analogous to
the use of virtual functions in C++, and under the covers Rust has '<a name="a032"></a>vtable' objects that are <em>roughly</em> analogous to those
in C++.</p>
<p>This dynamic aspect of trait objects also means that they always have to be handled indirectly, via a <a name="a033"></a>reference (<code>&amp;dyn Trait</code>) or a pointer (<code>Box&lt;dyn Trait&gt;</code>).  This is because the size of the object implementing the trait isn't known at
compile time â€“ it could be a giant <code>struct</code> or a tiny <code>enum</code> â€“ so there's no way to allocate the right
amount of space for a bare trait object.</p>
<p>A similar concern means that traits used as trait objects cannot have methods that return the <a name="a034"></a><code>Self</code> type, because the
compiled-in-advance code that uses the trait object would have no idea how big that <code>Self</code> might be.</p>
<p>A trait that has a <a name="a035"></a>generic method <code>fn method&lt;T&gt;(t:T)</code> allows for the possibility of an infinite number of implemented
methods, for all the different types <code>T</code> that might exist.  This is fine for a trait used as a trait bound, because the
infinite set of <em>possibly</em> invoked generic methods becomes a finite set of <em>actually</em> invoked generic methods at compile
time.  The same is not true for a trait object: the code available at compile time has to cope with all possible <code>T</code>s
that might arrive at run-time.</p>
<p>These two restrictions â€“ no returning <code>Self</code> and no generic methods â€“ are combined into the concept of
<em><a name="a036"></a>object safety</em>.  Only object safe traits can be used as trait objects.</p>
<p><hr/>
<p><a name="footnote-1"><a href="use-types-2.html#to-footnote-1">1</a></a>: At least, not in
stable Rust at the time of writing. The
<a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/unboxed-closures.html"><code>unboxed_closures</code></a> and
<a href="https://doc.rust-lang.org/nightly/unstable-book/library-features/fn-traits.html"><code>fn_traits</code></a> experimental features may
change this in future.</p>
<p><a name="footnote-2"><a href="use-types-2.html#to-footnote-2">2</a></a>: For example,
<a name="a020"></a><a href="https://www.oreilly.com/library/view/effective-java/9780134686097/"><em>Effective Java</em></a> Item 64: Refer to objects
by their interfaces</p>
<p><a name="footnote-3"><a href="use-types-2.html#to-footnote-3">3</a></a>: The addition of
<a href="https://en.cppreference.com/w/cpp/language/constraints"><em>concepts</em></a> in <a name="a028"></a>C++20 allows explicit specification of
constraints on template types, but the checks are still only performed when the template is instantiated, not when it is
declared.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-3-avoid-matching-option-and-result"><a class="header" href="#item-3-avoid-matching-option-and-result">Item 3: Avoid <code>match</code>ing <code>Option</code> and <code>Result</code></a></h1>
<p><a href="use-types.html">Item 1</a> expounded the virtues of <a name="a001"></a><code>enum</code> and showed how <a name="a002"></a><code>match</code> expressions force the programmer to take all
possibilities into account; this Item explores situations where you should prefer to avoid <code>match</code> expressions â€“
explicitly at least.</p>
<p><a href="use-types.html">Item 1</a> also introduced the two ubiquitous <code>enum</code>s that are provided by the Rust standard library:</p>
<ul>
<li><a name="a003"></a><a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;T&gt;</code></a> to express that a value (of type
<code>T</code>) <a name="a004"></a>may or <a name="a005"></a>may not be present</li>
<li><a name="a006"></a><a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;T, E&gt;</code></a>, for when an operation to
return a <a name="a007"></a>value (of type <code>T</code>) may not succeed, and may instead return an <a name="a008"></a>error (of type <code>E</code>).</li>
</ul>
<p>For these particular <code>enum</code>s, <em>explicitly</em> using <code>match</code> often leads to code that is less compact than it needs to be,
and which isn't idiomatic Rust.</p>
<p>The first situation where a <code>match</code> is unnecessary is when only the value is relevant, and the absence of value (and any
associated error) can just be ignored.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct S {
        field: Option&lt;i32&gt;,
    }

    let s = S { field: Some(42) };
    match &amp;s.field {
        Some(i) =&gt; println!(&quot;field is {}&quot;, i),
        None =&gt; {}
    }
<span class="boring">}</span></code></pre></pre>
<p>For this situation, an <a name="a009"></a><a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions"><code>if let</code></a>
expression is one line shorter and, more importantly, clearer:</p>
<pre><code class="language-rust ignore">    if let Some(i) = &amp;s.field {
        println!(&quot;field is {}&quot;, i);
    }</code></pre>
<p>However, most of the time the absence of a value, and an associated error, is going to be something that the programmer
has to deal with. Designing software to cope with failure paths is hard, and most of that is essential complexity that
no amount of syntactic support can help with â€“ specifically, deciding what should happen if an operation fails.</p>
<p>In some situations, the right decision is to perform an <a name="a010"></a>ostrich manoeuvre and explicitly not cope with
failure. Doing this with an explicit <code>match</code> would be needlessly verbose:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let result = std::fs::File::open(&quot;/etc/passwd&quot;);
    let f = match result {
        Ok(f) =&gt; f,
        Err(_e) =&gt; panic!(&quot;Failed to open /etc/passwd!&quot;),
    };
<span class="boring">}</span></code></pre></pre>
<p>Both <code>Option</code> and <code>Result</code> provide a pair of methods that extract their inner value and <code>panic!</code> if it's absent:
<a name="a011"></a><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>unwrap</code></a> and
<a name="a012"></a><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect</code></a>.  The latter allows the error
message on failure to be personalized, but in either case the resulting code is shorter and simpler â€“ error
handling is delegated to the <code>.unwrap()</code> suffix (but is still present).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let f = std::fs::File::open(&quot;/etc/passwd&quot;).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Be clear, though: these helper functions still <a name="a013"></a><code>panic!</code>, so choosing to use them is the same as choosing to <code>panic!</code>
(<a href="panic.html">Item 18</a>).</p>
<p>However, in many situations, the right decision for error handling is to defer the decision to somebody else.  This is
particularly true when writing a library, where the code may be used in all sorts of different environments that can't
be foreseen by the library author.  To make that somebody else's job easier, <strong>prefer <code>Result</code> to <code>Option</code></strong>, even
though this may involve conversions between different error types (<a href="errors.html">Item 4</a>).</p>
<p><code>Result</code> has also a
<a name="a014"></a><a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute"><code>[#must_use]</code></a>
attribute to nudge library users in the right direction â€“ if the code using the returned <code>Result</code> ignores it, the
compiler will generate a warning:</p>
<pre><code class="language-text">warning: unused `Result` that must be used
  --&gt; transform/src/main.rs:32:5
   |
32 |     f.set_len(0); // Truncate the file
   |     ^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled
</code></pre>
<p>Explicitly using a <code>match</code> allows an error to propagate, but at the cost of some visible boilerplate (reminiscent of
<a name="a015"></a><a href="https://blog.golang.org/errors-are-values">Go</a>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, std::io::Error&gt; {
        let f = match std::fs::File::open(&quot;/etc/passwd&quot;) {
            Ok(f) =&gt; f,
            Err(e) =&gt; return Err(e),
        };
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>The key ingredient for reducing boilerplate is Rust's <a name="a016"></a><a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator">question mark operator
<code>?</code></a>.  This piece of
<a name="a017"></a>syntactic sugar takes care of matching the <code>Err</code> arm and the <code>return Err(...)</code> expression in a single character:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, std::io::Error&gt; {
        let f = std::fs::File::open(&quot;/etc/passwd&quot;)?;
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>Newcomers to Rust sometimes find this disconcerting: the question mark can be hard to spot on first glance, leading to
disquiet as to how the code can possibly work. However, even with a single character, the <a name="a018"></a>type system is still at
work, ensuring that all of the possibilities expressed in the relevant types (<a href="use-types.html">Item 1</a>) are covered â€“ leaving the
programmer to focus on the mainline code path without distractions.</p>
<p>What's more, there's generally no cost to these apparent method invocations: they are all <a name="a019"></a>generic functions marked
as <a name="a020"></a><a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute"><code>#[inline]</code></a>, so
the generated code will typically compile to machine code that's identical to the manual version.</p>
<p>These two factors taken together mean that you should <strong>prefer <code>Option</code> and <code>Result</code> transforms to explicit <code>match</code>
expressions</strong>.</p>
<p>In the previous example, the error types lined up: both the inner and outer methods expressed errors as <a name="a021"></a>
<a href="https://doc.rust-lang.org/std/io/struct.Error.html"><code>std::io::Error</code></a>. That's often not the case; one function may
accumulate errors from a variety of different sub-libraries, each of which uses different error types.</p>
<p>Error mapping in general is discussed in <a href="errors.html">Item 4</a>; for now, just be aware that a manual mapping:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, String&gt; {
        let f = match std::fs::File::open(&quot;/etc/passwd&quot;) {
            Ok(f) =&gt; f,
            Err(e) =&gt; {
                return Err(format!(&quot;Failed to open password file: {:?}&quot;, e))
            }
        };
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>can be more succinctly and idiomatically expressed with the
<a name="a022"></a><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>.map_err()</code></a> transformation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, String&gt; {
        let f = std::fs::File::open(&quot;/etc/passwd&quot;)
            .map_err(|e| format!(&quot;Failed to open password file: {:?}&quot;, e))?;
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>Better still, even this may not be necessary â€“ if the outer error type can be created from the inner error type
via an implementation of the <a name="a023"></a><code>From</code> standard trait (<a href="std-traits.html">Item 5</a>), then the compiler will automatically perform the
conversion without the need for a call to <code>.map_err()</code>.</p>
<p>These kinds of transformations generalize more widely. The question mark operator is a big hammer; use transformation
methods on <code>Option</code> and <code>Result</code> types to manoeuvre them into a position where they can be a nail.</p>
<p>The standard library provides a wide variety of these transformation methods to make this possible, as shown in the
following map.  In line with <a href="panic.html">Item 18</a>, methods that can <a name="a024"></a><code>panic!</code> are highlighted in red.</p>
<p><img src="images/transform.svg" alt="Option/Result transformations" /></p>
<p>(The <a href="https://tinyurl.com/rust-transform">online version</a> of this diagram is clickable: each box links to the relevant
documentation.)</p>
<p>One common situation which isn't covered by the diagram is dealing with references. For example, consider a structure
that optionally holds some data.</p>
<pre><code class="language-rust ignore">    struct InputData {
        payload: Option&lt;Vec&lt;u8&gt;&gt;,
    }</code></pre>
<p>A method on this <code>struct</code> which tries to pass the payload to an encryption function with signature <code>(&amp;[u8]) -&gt; Vec&lt;u8&gt;</code>
fails if there's a naive attempt to take a reference:</p>
<pre><code class="language-rust ignore does_not_compile">    impl InputData {
        pub fn encrypted(&amp;self) -&gt; Vec&lt;u8&gt; {
            encrypt(&amp;self.payload.unwrap_or(vec![]))
        }
    }</code></pre>
<pre><code class="language-text">error[E0507]: cannot move out of `self.payload` which is behind a shared reference
  --&gt; transform/src/main.rs:62:22
   |
62 |             encrypt(&amp;self.payload.unwrap_or(vec![]))
   |                      ^^^^^^^^^^^^ move occurs because `self.payload` has type `Option&lt;Vec&lt;u8&gt;&gt;`, which does not implement the `Copy` trait
   |
help: consider borrowing the `Option`'s content
   |
62 |             encrypt(&amp;self.payload.as_ref().unwrap_or(vec![]))
   |                                  +++++++++
</code></pre>
<p>The error message describes exactly what's needed to make the code work, the
<a name="a025"></a><a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.as_ref"><code>as_ref()</code></a>
method<sup><a name="to-footnote-1"><a href="transform.html#footnote-1">1</a></a></sup>  on <code>Option</code>. This method converts a reference-to-an-<code>Option</code> to be an <code>Option</code>-of-a-reference:</p>
<pre><code class="language-rust ignore">        pub fn encrypted(&amp;self) -&gt; Vec&lt;u8&gt; {
            encrypt(self.payload.as_ref().unwrap_or(&amp;vec![]))
        }</code></pre>
<p>To sum up:</p>
<ul>
<li>Get used to the transformations of <code>Option</code> and <code>Result</code>, and prefer <code>Result</code> to <code>Option</code>.
<ul>
<li>Use <code>.as_ref()</code> as needed when transformations involve references.</li>
</ul>
</li>
<li>Use them in preference to explicit <code>match</code> operations.</li>
<li>In particular, use them to transform result types into a form where the <code>?</code> operator applies.</li>
</ul>
<p><hr/>
<p><a name="footnote-1"><a href="transform.html#to-footnote-1">1</a></a>: Note that this method is separate from the <a name="a026"></a><code>AsRef</code> trait, even though the method name is the
same.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-4-prefer-idiomatic-error-variants"><a class="header" href="#item-4-prefer-idiomatic-error-variants">Item 4: Prefer idiomatic <code>Error</code> variants</a></h1>
<p><a href="transform.html">Item 3</a> described how to use the transformations that the standard library provides for the <a name="a001"></a><code>Option</code> and
<a name="a002"></a><code>Result</code> types to allow concise, idiomatic handling of result types using the <a name="a003"></a><code>?</code> operator.  It stopped
short of discussing how best to handle the variety of different error types <code>E</code> that arise as the second type argument
of a <code>Result&lt;T, E&gt;</code>; that's the subject of this Item.</p>
<p>This is only really relevant when there <em>are</em> a variety of different error types in play; if all of the different errors
that a function encounters are already of the same type, it can just return that type.  When there are errors of
different types, there's a decision to be made about whether the sub-error type information should be preserved.</p>
<h2 id="the-error-trait"><a class="header" href="#the-error-trait">The <code>Error</code> Trait</a></h2>
<p>It's always good to understand what the standard traits (<a href="std-traits.html">Item 5</a>) involve, and the relevant trait here is
<a name="a004"></a><a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a>.  The <code>E</code> type parameter for a
<code>Result</code> doesn't <em>have</em> to be a type that implements <code>Error</code>, but it's a common convention that allows wrappers to
express appropriate trait bounds â€“ so <strong>prefer to implement <code>Error</code> for your error types</strong>.  However, if you're
writing code for a <a name="a005"></a><code>no_std</code> environment (<a href="no-std.html">Item 33</a>), this recommendation is more awkward to apply â€“ the
<code>Error</code> trait is currently<sup><a name="to-footnote-1"><a href="errors.html#footnote-1">1</a></a></sup> implemented in
<code>std</code>, not <a name="a006"></a><code>core</code>, and so is not available.</p>
<p>The first thing to notice is that the only hard requirement for <code>Error</code> types is the <a name="a007"></a>trait bounds: any type that
implements <code>Error</code> also has to implement both:</p>
<ul>
<li>the <a name="a008"></a><code>Display</code> trait, meaning that it can be <code>format!</code>ed with <code>{}</code>, and</li>
<li>the <a name="a009"></a><code>Debug</code> trait, meaning that it can be <code>format!</code>ed with <code>{:?}</code>.</li>
</ul>
<p>In other words, it should be possible to display <code>Error</code> types to both the user and the programmer.</p>
<p>The only<sup><a name="to-footnote-2"><a href="errors.html#footnote-2">2</a></a></sup> method in the trait is
<a href="https://doc.rust-lang.org/std/error/trait.Error.html#method.source"><code>source()</code></a>, which allows an <code>Error</code> type to expose
an inner, nested error.  This method is optional â€“ it comes with a <a name="a010"></a>default implementation (<a href="default-impl.html">Item 13</a>)
returning <code>None</code>, indicating that inner error information isn't available.</p>
<h2 id="minimal-errors"><a class="header" href="#minimal-errors">Minimal Errors</a></h2>
<p>If nested error information isn't needed, then an implementation of the <code>Error</code> type need not be much more than a
<code>String</code> â€“ one rare occasion where a &quot;stringly-typed&quot; variable might be appropriate.  It does need to be a
<em>little</em> more than a <code>String</code> though; while it's possible to use <code>String</code> as the <code>E</code> type parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, String&gt; {
        let f = std::fs::File::open(&quot;/etc/passwd&quot;)
            .map_err(|e| format!(&quot;Failed to open password file: {:?}&quot;, e))?;
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>a <code>String</code> doesn't implement <code>Error</code>, which we'd prefer so that other areas of code can deal in <code>Error</code>s.  It's not
possible to <code>impl Error</code> for <code>String</code>, because neither the trait nor the type belong to us (the so-called <em><a name="a011"></a>orphan
rule</em>):</p>
<pre><code class="language-rust ignore does_not_compile">    impl std::error::Error for String {}</code></pre>
<pre><code class="language-text">error[E0117]: only traits defined in the current crate can be implemented for arbitrary types
  --&gt; errors/src/main.rs:20:5
   |
20 |     impl std::error::Error for String {}
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^------
   |     |                          |
   |     |                          `String` is not defined in the current crate
   |     impl doesn't use only types from inside the current crate
   |
   = note: define and implement a trait or new type instead
</code></pre>
<p>A <a name="a012"></a><a href="https://doc.rust-lang.org/reference/items/type-aliases.html"><em>type alias</em></a> doesn't help either,
because it doesn't create a new type and so doesn't change the error message.</p>
<pre><code class="language-rust ignore does_not_compile">    pub type MyError = String;

    impl std::error::Error for MyError {}</code></pre>
<pre><code class="language-text">error[E0117]: only traits defined in the current crate can be implemented for arbitrary types
  --&gt; errors/src/main.rs:43:5
   |
43 |     impl std::error::Error for MyError {}
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^-------
   |     |                          |
   |     |                          `String` is not defined in the current crate
   |     impl doesn't use only types from inside the current crate
   |
   = note: define and implement a trait or new type instead
</code></pre>
<p>As usual, the compiler error message gives a hint of how to solve the problem.  Defining a tuple struct that wraps the
<code>String</code> type (the &quot;<a name="a013"></a>newtype pattern&quot;, <a href="newtype.html">Item 7</a>) allows the <code>Error</code> trait to be implemented, provided that <code>Debug</code> and
<code>Display</code> are implemented too:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[derive(Debug)]
    pub struct MyError(String);

    impl std::fmt::Display for MyError {
        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
            write!(f, &quot;{}&quot;, self.0)
        }
    }

    impl std::error::Error for MyError {}

    pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, MyError&gt; {
        let f = std::fs::File::open(&quot;/etc/passwd&quot;).map_err(|e| {
            MyError(format!(&quot;Failed to open password file: {:?}&quot;, e))
        })?;
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>For convenience, it may make sense to implement the <a name="a014"></a><code>From&lt;String&gt;</code> trait to allow string values to be
easily converted into <code>MyError</code> instances (<a href="casts.html">Item 6</a>):</p>
<pre><code class="language-rust ignore">    impl std::convert::From&lt;String&gt; for MyError {
        fn from(msg: String) -&gt; Self {
            Self(msg)
        }
    }</code></pre>
<p>When it encounters the <a name="a015"></a>question mark operator (<strong><code>?</code></strong>), the compiler will automatically apply any relevant
<a name="a016"></a><code>From</code> trait implementations that are needed to reach the destination error return type.  This allows further
minimization:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, MyError&gt; {
        let f = std::fs::File::open(&quot;/etc/passwd&quot;)
            .map_err(|e| format!(&quot;Failed to open password file: {:?}&quot;, e))?;
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>For the error path here:</p>
<ul>
<li><code>File::open</code> returns an error of type <a href="https://doc.rust-lang.org/stable/std/io/struct.Error.html"><code>std::io::Error</code></a>.</li>
<li><code>format!</code> converts this to a <code>String</code>, using the <code>Debug</code> implementation of <code>std::io::Error</code>.</li>
<li><code>?</code> makes the compiler look for and use a <code>From</code> implementation that can take it from <code>String</code> to <code>MyError</code>.</li>
</ul>
<h2 id="nested-errors"><a class="header" href="#nested-errors">Nested Errors</a></h2>
<p>The alternative scenario is where the content of nested errors is important enough that it should be preserved and made
available to the caller.</p>
<p>Consider a library function that attempts to return the first line of a file as a string, as long as the line is not too
long. A moment's thought reveals (at least) three distinct types of failure that could occur:</p>
<ul>
<li>The file might not exist, or might be inaccessible for reading.</li>
<li>The file might contain data that isn't valid <a name="a017"></a>UTF-8, and so can't be converted into a <code>String</code>.</li>
<li>The file might have a first line that is too long.</li>
</ul>
<p>In line with <a href="use-types.html">Item 1</a>, you can use the type system to express and encompass all of these possibilities as an
<a name="a018"></a><code>enum</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub enum MyError {
    Io(std::io::Error),
    Utf8(std::string::FromUtf8Error),
    General(String),
}
<span class="boring">}</span></code></pre></pre>
<p>This <code>enum</code> definition includes a <a name="a019"></a><code>derive(Debug)</code>, but to satisfy the <code>Error</code> trait a <code>Display</code> implementation is also
needed.</p>
<pre><code class="language-rust ignore">impl std::fmt::Display for MyError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            MyError::Io(e) =&gt; write!(f, &quot;IO error: {}&quot;, e),
            MyError::Utf8(e) =&gt; write!(f, &quot;UTF-8 error: {}&quot;, e),
            MyError::General(s) =&gt; write!(f, &quot;General error: {}&quot;, s),
        }
    }
}</code></pre>
<p>It also makes sense to override the default <code>source()</code> implementation for easy access to nested errors.</p>
<pre><code class="language-rust ignore">use std::error::Error;

impl Error for MyError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        match self {
            MyError::Io(e) =&gt; Some(e),
            MyError::Utf8(e) =&gt; Some(e),
            MyError::General(_) =&gt; None,
        }
    }
}</code></pre>
<p>This allows the error handling to be concise while still preserving all of the type information across different classes
of error:</p>
<pre><code class="language-rust ignore">    /// Return the first line of the given file.
    pub fn first_line(filename: &amp;str) -&gt; Result&lt;String, MyError&gt; {
        let file = std::fs::File::open(filename).map_err(MyError::Io)?;
        let mut reader = std::io::BufReader::new(file);

        // (A real implementation could just use `reader.read_line()`)
        let mut buf = vec![];
        let len = reader.read_until(b'\n', &amp;mut buf).map_err(MyError::Io)?;
        let result = String::from_utf8(buf).map_err(MyError::Utf8)?;
        if result.len() &gt; MAX_LEN {
            return Err(MyError::General(format!(&quot;Line too long: {}&quot;, len)));
        }
        Ok(result)
    }</code></pre>
<p>It's also a good idea to implement the <a name="a020"></a><code>From</code> trait for all of the sub-error types (<a href="casts.html">Item 6</a>):</p>
<pre><code class="language-rust ignore">impl From&lt;std::io::Error&gt; for MyError {
    fn from(e: std::io::Error) -&gt; Self {
        Self::Io(e)
    }
}
impl From&lt;std::string::FromUtf8Error&gt; for MyError {
    fn from(e: std::string::FromUtf8Error) -&gt; Self {
        Self::Utf8(e)
    }
}</code></pre>
<p>This prevents library users from suffering under the <a name="a021"></a>orphan rules themselves: they aren't allowed to implement <code>From</code> on
<code>MyError</code>, because both the trait and the struct are external to them.</p>
<p>Better still, implementing <a name="a022"></a><code>From</code> allows for even more concision, because the <a name="a023"></a><a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator">question mark
operator</a> will
automatically perform any necessary <code>From</code> conversions:</p>
<pre><code class="language-rust ignore">    /// Return the first line of the given file.
    pub fn first_line(filename: &amp;str) -&gt; Result&lt;String, MyError&gt; {
        let file = std::fs::File::open(filename)?; // via `From&lt;std::io::Error&gt;`
        let mut reader = std::io::BufReader::new(file);
        let mut buf = vec![];
        let len = reader.read_until(b'\n', &amp;mut buf)?; // via `From&lt;std::io::Error&gt;`
        let result = String::from_utf8(buf)?; // via `From&lt;std::string::FromUtf8Error&gt;`
        if result.len() &gt; MAX_LEN {
            return Err(MyError::General(format!(&quot;Line too long: {}&quot;, len)));
        }
        Ok(result)
    }</code></pre>
<p>Writing a complete error type can involve a fair amount of boilerplate; <strong>consider using the
<a name="a024"></a><a href="https://docs.rs/thiserror"><code>thiserror</code></a> crate</strong> to help with this, as it reduces the effort involved without
adding an extra runtime dependency.</p>
<h2 id="trait-objects"><a class="header" href="#trait-objects">Trait Objects</a></h2>
<p>The first approach to nested errors threw away all of the sub-error detail, just preserving some string output
(<code>format!(&quot;{:?}&quot;, err)</code>).  The second approach preserved the full type information for all possible sub-errors, but
required a full enumeration of all possible types of sub-error.</p>
<p>This raises the question: is there a half-way house between these two approaches, preserving sub-error information
without needing to manually include every possible error type?</p>
<p>Encoding the sub-error information as a <a name="a025"></a><a href="https://doc.rust-lang.org/reference/types/trait-object.html"><em>trait
object</em></a> avoids the need for an <code>enum</code> variant for every
possibility, but erases the details of the specific underlying error types. The receiver of such an object would have
access to the methods of the <code>Error</code> trait â€“ <code>display()</code>, <code>debug()</code> and <code>source()</code> in turn â€“ but wouldn't
know the original static type of the sub-error.</p>
<pre><code class="language-rust ignore not_desired_behaviour">#[derive(Debug)]
pub enum WrappedError {
    Wrapped(Box&lt;dyn Error&gt;),
    General(String),
}

impl std::fmt::Display for WrappedError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            Self::Wrapped(e) =&gt; write!(f, &quot;Inner error: {}&quot;, e),
            Self::General(s) =&gt; write!(f, &quot;{}&quot;, s),
        }
    }
}</code></pre>
<p>It turns out that this <em>is</em> possible, but it's surprisingly subtle. Part of the difficulty comes from the object safety
constraints on trait objects (<a href="generics.html">Item 12</a>), but Rust's <em>coherence rules</em> also come into play, which (roughly) say that
there can be at most one implementation of a trait for a type.</p>
<p>A putative <code>WrappedError</code> would naively be expected to both implement the <code>Error</code> trait, and also to implement the
<code>From&lt;Error&gt;</code> trait to allow sub-errors to be easily wrapped.  That means that a <code>WrappedError</code> can be created <code>from</code> an
inner <code>WrappedError</code>, as <code>WrappedError</code> implements <code>Error</code>, and that clashes with the <a name="a026"></a>blanket reflexive implementation of <code>From</code>:</p>
<pre><code class="language-text">error[E0119]: conflicting implementations of trait `std::convert::From&lt;WrappedError&gt;` for type `WrappedError`
   --&gt; errors/src/main.rs:253:1
    |
253 | impl&lt;E: 'static + Error&gt; From&lt;E&gt; for WrappedError {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: conflicting implementation in crate `core`:
            - impl&lt;T&gt; From&lt;T&gt; for T;
</code></pre>
<p><a name="a027"></a>David Tolnay's <a name="a028"></a><a href="https://docs.rs/anyhow"><code>anyhow</code></a> is a crate that has already solved these
<a href="https://github.com/dtolnay/anyhow/issues/63">problems</a>, and which adds other helpful features (such as stack traces)
besides. As a result, it is rapidly becoming the standard recommendation for error handling â€“ a recommendation
seconded here: <strong>consider using the <code>anyhow</code> crate for error handling in applications</strong>.</p>
<h2 id="libraries-versus-applications"><a class="header" href="#libraries-versus-applications">Libraries versus Applications</a></h2>
<p>The final advice of the previous section included the qualification &quot;â€¦for error handling <em>in applications</em>&quot;.
That's because there's often a distinction between code that's written for re-use in a library, and code that forms a
top-level application<sup><a name="to-footnote-3"><a href="errors.html#footnote-3">3</a></a></sup>.</p>
<p>Code that's written for a library can't predict the environment in which the code is used, so it's preferable to emit
concrete, detailed error information, and leave the caller to figure out how to use that information. This leans towards
the <code>enum</code>-style nested errors described previously (and also avoids a dependency on <code>anyhow</code> in the public API of the
library, cf. <a href="re-export.html">Item 24</a>).</p>
<p>However, application code typically needs to concentrate more on how to present errors to the user. It also potentially
has to cope with all of the different error types emitted by all of the libraries that are present in its dependency
graph (<a href="dep-graph.html">Item 25</a>).  As such, a more dynamic error type (such as
<a href="https://docs.rs/anyhow/latest/anyhow/struct.Error.html"><code>anyhow::Error</code></a>) makes error handling simpler and more
consistent across the application.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This item has covered a lot of ground, so a summary is in order:</p>
<ul>
<li>The standard <code>Error</code> trait requires little of you, so prefer to implement it for your error types.</li>
<li>When dealing with heterogeneous underlying error types, decide whether preserving those types is needed.
<ul>
<li>If not, consider using <code>anyhow</code> to wrap sub-errors in application code.</li>
<li>If they are needed, encode them in an <code>enum</code> and provide conversions. Consider using <code>thiserror</code> to help with this.</li>
</ul>
</li>
<li>Consider using the <code>anyhow</code> crate for convenient, idiomatic error handling.</li>
</ul>
<p>It's your decision, but whatever you decide, encode it in the type system (<a href="use-types.html">Item 1</a>).</p>
<p><hr/>
<p><a name="footnote-1"><a href="errors.html#to-footnote-1">1</a></a>: At the time of writing, <code>Error</code> has been <a href="https://github.com/rust-lang/rust/issues/103765">moved to
<code>core</code></a> but is not yet available in stable Rust.</p>
<p><a name="footnote-2"><a href="errors.html#to-footnote-2">2</a></a>: Or at least the only non-deprecated, stable method.</p>
<p><a name="footnote-3"><a href="errors.html#to-footnote-3">3</a></a>: This section is inspired by <a name="a029"></a><a href="https://nick.groenen.me/posts/rust-error-handling/">Nick Groenen's &quot;Rust: Structuring and
handling errors in 2020&quot; article</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-5-familiarize-yourself-with-standard-traits"><a class="header" href="#item-5-familiarize-yourself-with-standard-traits">Item 5: Familiarize yourself with standard traits</a></h1>
<p>Rust encodes key behavioural aspects of its <a name="a001"></a>type system in the type system itself, through a collection of fine-grained
standard <a name="a002"></a>traits that describe those behaviours (cf. <a href="use-types-2.html">Item 2</a>).</p>
<p>Many of these traits will seem familiar to programmers coming from <a name="a003"></a>C++, corresponding to concepts such as
copy-constructors, destructors, equality and assignment operators, etc.</p>
<p>As in C++, it's often a good idea to implement many of these traits for your own types; the Rust compiler will give
you helpful error messages if some operation needs one of these traits for your type, and it isn't present.</p>
<p>Implementing such a large collection of traits may seem daunting, but most of the common ones can be automatically
applied to user-defined types, through use of <a name="a004"></a><a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros"><code>derive</code>
macros</a>. This leads to type definitions like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    enum MyBooleanOption {
        Off,
        On,
    }
<span class="boring">}</span></code></pre></pre>
<p>This fine-grained specification of behaviour can be disconcerting at first, but it's important to be familiar with the
most common of these standard traits so that the available behaviours of a type definition can be immediately
understood.</p>
<p>A rough one-sentence summary of each of the standard traits that this Item covers is:</p>
<ul>
<li><a name="a005"></a><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>: Items of this type can make a copy of themselves
when asked.</li>
<li><a name="a006"></a><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>: If the compiler makes a bit-for-bit copy of this
item's memory representation, the result is a valid new item.</li>
<li><a name="a007"></a><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a>: It's possible to make new instances of
this type with sensible default values.</li>
<li><a name="a008"></a><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>: There's a <a href="https://en.wikipedia.org/wiki/Partial_equivalence_relation">partial equivalence
relation</a> for items of this type â€“ any two items
can be definitively compared, but it may not always be true that <code>x==x</code>.</li>
<li><a name="a009"></a><a href="https://doc.rust-lang.org/beta/std/cmp/trait.Eq.html"><code>Eq</code></a>: There's an <a href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence
relation</a> for items of this type: any two items can be
definitively compared, and it <em>is</em> always true that <code>x==x</code>.</li>
<li><a name="a010"></a><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a>: <em>Some</em> items of this type can be
compared and ordered.</li>
<li><a name="a011"></a><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialOrd.html"><code>Ord</code></a>: <em>All</em> items of this type can be
compared and ordered.</li>
<li><a name="a012"></a><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a>: Items of this type can produce a stable hash of their
contents when asked.</li>
<li><a name="a013"></a><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>: Items of this type can be displayed to programmers.</li>
<li><a name="a014"></a><a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a>: Items of this type can be displayed to users.</li>
</ul>
<p>These traits can all be <code>derive</code>d for user-defined types, with the exception of <code>Display</code> (included here because of its
overlap with <code>Debug</code>).  However, there are occasions when a manual implementation â€“ or no implementation â€“
is preferable.</p>
<p>Rust also allows various built-in unary and binary operators to be overloaded for user-defined types, by implementing
various traits from the <a href="https://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code> module</a>.  These traits are not
derivable, and are typically only needed for types that represent &quot;algebraic&quot; objects.</p>
<p>Other (non-<code>derive</code>able) standard traits are covered in other Items, and so are not included here. These include:</p>
<ul>
<li><a name="a015"></a><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>,
<a name="a016"></a><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> and
<a name="a017"></a><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>: Items implementing this trait represent closures
that can be invoked. See <a href="use-types-2.html">Item 2</a>.</li>
<li><a name="a018"></a><a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a>: Items implementing this trait represent error
information that can be displayed to users or programmers, and which <em>may</em> hold nested sub-error information.  See
<a href="errors.html">Item 4</a>.</li>
<li><a name="a019"></a><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>: Items implementing this trait perform processing
when they are destroyed, which is essential for <a name="a020"></a>RAII patterns. See <a href="raii.html">Item 11</a>.</li>
<li><a name="a021"></a><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and
<a name="a022"></a><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a>: Items implementing this trait can be automatically
created from items of some other type, but with a possibility of failure in the latter case. See <a href="casts.html">Item 6</a>.</li>
<li><a name="a023"></a><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> and
<a name="a024"></a><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a>: Items implementing this trait are
pointer-like objects that can be dereferenced to get access to an inner item. See <a href="references.html">Item 9</a>.</li>
<li><a name="a025"></a><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a> and friends: Items implementing this trait
represent collections that can be iterated over.  See <a href="iterators.html">Item 10</a>.</li>
<li><a name="a026"></a><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>: Items implementing this trait are safe to
transfer between multiple threads. See <a href="deadlock.html">Item 17</a>.</li>
<li><a name="a027"></a><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>: Items implementing this trait are safe to be
referenced by multiple threads. See <a href="deadlock.html">Item 17</a>.</li>
</ul>
<h2 id="clone"><a class="header" href="#clone"><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a></a></h2>
<p>The <a name="a028"></a><code>Clone</code> trait indicates that it's possible to make a new copy of an item, by calling the
<a href="https://doc.rust-lang.org/std/clone/trait.Clone.html#tymethod.clone"><code>clone()</code></a> method.  This is roughly equivalent to
C++'s copy-constructor, but more explicit: the compiler will never silently invoke this method on its own (read on to
the next section for that).</p>
<p><code>Clone</code> can be <a name="a029"></a><code>derive</code>d; the macro implementation clones an aggregate type by cloning each of its members in turn,
again, roughly equivalent to a default copy-constructor in C++.  This makes the trait opt-in (by adding
<code>#[derive(Clone)]</code>), in contrast to the opt-out behaviour in C++ (<code>MyType(const MyType&amp;) = delete;</code>).</p>
<p>This is such a common and useful operation that it's more interesting to investigate the situations where you shouldn't
or can't implement <code>Clone</code>, or where the default <code>derive</code> implementation isn't appropriate.</p>
<ul>
<li>You <em>shouldn't</em> implement <code>Clone</code> if the item embodies unique access to some resource (such as an <a name="a030"></a>RAII type,
<a href="raii.html">Item 11</a>), or when there's another reason to restrict copies (e.g. if the item holds cryptographic key material).</li>
<li>You <em>can't</em> implement <code>Clone</code> if some component of your type is un-<code>Clone</code>able in turn.  Examples include:
<ul>
<li>Fields that are mutable references (<code>&amp;mut T</code>), because the <a name="a031"></a>borrow checker (<a href="borrows.html">Item 15</a>) only allows a single
mutable reference at a time.</li>
<li>Standard library types that fall into the previous category, such as
<a name="a032"></a><a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a> (embodies unique access) or
<a name="a033"></a><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> (restricts copies for thread safety).</li>
</ul>
</li>
<li>You should <em>manually implement</em> <code>Clone</code> if there is anything about your item that won't be captured by a (recursive)
field-by-field copy, or if there is additional book-keeping associated with item lifetimes. For example, consider a
type that tracks the number of extant items at runtime for metrics purposes; a manual <code>Clone</code> implementation can
ensure the counter is kept accurate.</li>
</ul>
<h2 id="copy"><a class="header" href="#copy"><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a></a></h2>
<p>The <a name="a034"></a><code>Copy</code> trait has a trivial declaration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Copy: Clone { }
<span class="boring">}</span></code></pre></pre>
<p>There are no methods in this trait, meaning that it is a <em><a name="a035"></a>marker trait</em> (as described in <a href="use-types-2.html">Item 2</a>): it's
used to indicate some constraint on the type that's not directly expressed in the type system.</p>
<p>In the case of <code>Copy</code>, the meaning of this marker is that not only can items of this type be copied (hence the <code>Clone</code>
trait bound), but also a bit-for-bit copy of the memory holding an item gives a correct new item.  Effectively, this
trait is a marker that says that a type is a <a href="https://en.wikipedia.org/wiki/Passive_data_structure">&quot;plain old data&quot; (POD)
type</a>.</p>
<p>In contrast to user-defined marker traits (<a href="use-types.html">Item 1</a>), <code>Copy</code> has a special significance to the compiler<sup><a name="to-footnote-1"><a href="std-traits.html#footnote-1">1</a></a></sup> over and above being available for trait bounds â€“ it shifts
the compiler from <em><a name="a036"></a>move semantics</em> to <em><a name="a037"></a>copy semantics</em>.</p>
<p>With move semantics for the assignment operator, what the right hand giveth, the left hand taketh away:</p>
<pre><code class="language-rust ignore does_not_compile">        #[derive(Debug, Clone)]
        struct KeyId(u32);
        let k = KeyId(42);
        let k2 = k; // value moves out of k in to k2
        println!(&quot;k={:?}&quot;, k);</code></pre>
<pre><code class="language-text">error[E0382]: borrow of moved value: `k`
  --&gt; std-traits/src/main.rs:52:28
   |
50 |         let k = KeyId(42);
   |             - move occurs because `k` has type `main::KeyId`, which does not implement the `Copy` trait
51 |         let k2 = k; // value moves out of k in to k2
   |                  - value moved here
52 |         println!(&quot;k={:?}&quot;, k);
   |                            ^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<p>With copy semantics, the original item lives on:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        #[derive(Debug, Clone, Copy)]
        struct KeyId(u32);
        let k = KeyId(42);
        let k2 = k; // value bitwise copied from k to k2
        println!(&quot;k={:?}&quot;, k);
<span class="boring">}</span></code></pre></pre>
<p>This makes <code>Copy</code> one of the most important traits to watch out for: it fundamentally changes the behaviour of
assignments â€“ and this includes parameters for method invocations.</p>
<p>In this respect, there are again overlaps with C++'s copy-constructors, but it's worth emphasizing a key distinction: in
Rust there is no way to get the compiler to silently invoke user-defined code â€“ it's either explicit (a call to
<code>.clone()</code>), or it's not user-defined (a bitwise copy).</p>
<p>To finish this section, observe that because <code>Copy</code> has a <code>Clone</code> trait bound, it's possible to <code>.clone()</code> any
<code>Copy</code>-able item.  However, it's not a good idea: a bitwise copy will always be faster than invoking a trait method.
<a name="a038"></a>Clippy (<a href="clippy.html">Item 29</a>) will warn you about this:</p>
<pre><code class="language-rust ignore not_desired_behaviour">        let k3 = k.clone();</code></pre>
<pre><code class="language-text">warning: using `clone` on type `main::KeyId` which implements the `Copy` trait
  --&gt; std-traits/src/main.rs:68:18
   |
68 |         let k3 = k.clone();
   |                  ^^^^^^^^^ help: try removing the `clone` call: `k`
   |
</code></pre>
<h2 id="default"><a class="header" href="#default"><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a></a></h2>
<p>The <a name="a039"></a><code>Default</code> trait defines a <em>default constructor</em>, via a
<a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default"><code>default()</code></a> method. This trait can be
<a name="a040"></a><code>derive</code>d for user-defined types, provided that all of the sub-types involved have a <code>Default</code> implementation of
their own; if they don't, you'll have to implement the trait manually. Continuing the comparison with C++, notice that a
default constructor has to be explicitly triggered; the compiler does not create one automatically.</p>
<p>The most useful aspect of the <code>Default</code> trait is its combination with <a name="a041"></a><a href="https://doc.rust-lang.org/reference/expressions/struct-expr.html#functional-update-syntax"><em>struct update
syntax</em></a>.  This syntax allows
<code>struct</code> fields to be initialized by copying or moving their contents from an existing instance of the same <code>struct</code>,
for any fields that aren't explicitly initialized.  The template to copy from is given at the end of the initialization,
after <code>..</code>, and the <code>Default</code> trait provides an ideal template to use:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[derive(Default)]
    struct Colour {
        red: u8,
        green: u8,
        blue: u8,
        alpha: u8,
    }

    let c = Colour {
        red: 128,
        ..Default::default()
    };
<span class="boring">}</span></code></pre></pre>
<p>This makes it much easier to initialize structures with lots of fields, only some of which have non-default values.
(The <a name="a042"></a>builder pattern, <a href="builders.html">Item 8</a>, may also be appropriate for these situations.)</p>
<h2 id="partialeq-and-eq"><a class="header" href="#partialeq-and-eq"><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a> and <a href="https://doc.rust-lang.org/beta/std/cmp/trait.Eq.html"><code>Eq</code></a></a></h2>
<p>The <a name="a043"></a><code>PartialEq</code> and <a name="a044"></a><code>Eq</code> traits allow you to define equality for user-defined types. These traits have
special significance because if they're present, the compiler will automatically use them for equality (<code>==</code>) checks,
similarly to <code>operator==</code> in C++.  The default <a name="a045"></a><code>derive</code> implementation does this with a recursive field-by-field
comparison.</p>
<p>The <code>Eq</code> version is just a <a name="a046"></a>marker trait extension of <code>PartialEq</code> which adds the assumption of
<a name="a047"></a><em>reflexivity</em>: any type <code>T</code> that claims to support <code>Eq</code> should ensure that <code>x == x</code> is true for any <code>x: T</code>.</p>
<p>This is sufficiently odd to immediately raise the question: when wouldn't <code>x == x</code>?  The primary rationale behind this
split relates to <a name="a048"></a><a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">floating point
numbers</a><sup><a name="to-footnote-2"><a href="std-traits.html#footnote-2">2</a></a></sup>, and specifically to the special &quot;not a
number&quot; value NaN (<a name="a049"></a><code>f32::NAN</code> / <a name="a050"></a><code>f64::NAN</code> in Rust). The floating point specifications require that nothing
compares equal to NaN, <em>including NaN itself</em>; the <code>PartialEq</code> trait is the knock-on effect of this.</p>
<p>For user-defined types that don't have any float-related peculiarities, you should <strong>implement <code>Eq</code> whenever you
implement <code>PartialEq</code></strong>.  The full <code>Eq</code> trait is also required if you want to use the type as the key in a
<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> (as well as the <code>Hash</code> trait).</p>
<p>You should implement <code>PartialEq</code> manually if your type contains any fields that do not affect the item's identity,
such as internal caches and other performance optimizations.</p>
<h2 id="partialord-and-ord"><a class="header" href="#partialord-and-ord"><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a> and <a href="https://doc.rust-lang.org/beta/std/cmp/trait.Ord.html"><code>Ord</code></a></a></h2>
<p>The ordering traits <a name="a051"></a><code>PartialOrd</code> and <a name="a052"></a><code>Ord</code> allow comparisons between two items of a type, returning <code>Less</code>,
<code>Greater</code>, or <code>Equal</code>.  The traits require equivalent equality traits to be implemented (<code>PartialOrd</code> requires
<code>PartialEq</code>, <code>Ord</code> requires <code>Eq</code>), and the two have to agree with each other (watch out for this with manual
implementations in particular).</p>
<p>As with the equality traits, the comparison traits have special significance because the compiler will automatically use
them for comparison operations (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>).</p>
<p>The default implementation produced by <a name="a053"></a><code>derive</code> compares fields (or <code>enum</code> variants) lexicographically in the order
they're defined, so if this isn't correct you'll need to implement the traits manually (or re-order the fields).</p>
<p>Unlike <code>PartialEq</code>, the <code>PartialOrd</code> trait does correspond to a variety of real situations. For example, it could be
used to express a subset relationship<sup><a name="to-footnote-3"><a href="std-traits.html#footnote-3">3</a></a></sup> among collections: <code>{1, 2}</code> is a
subset of <code>{1, 2, 4}</code>, but <code>{1, 3}</code> is not a subset of <code>{2, 4}</code> nor vice versa.</p>
<p>However, even if a partial order does accurately model the behaviour of your type, <strong>be wary of implementing just
<code>PartialOrd</code></strong> (a rare occasion that contradicts the advice of <a href="use-types-2.html">Item 2</a> to encode behaviour in the type system) â€“
it can lead to surprising results:</p>
<pre><code class="language-rust ignore not_desired_behaviour">    let x = Oddity(1);
    let x2 = Oddity(1);
    if x &lt;= x2 {
        println!(&quot;It's possible to not hit this!&quot;);
    }

    let x = Oddity(1);
    let y = Oddity(2);
    // Programmers are unlikely to cover all possible arms...
    if x &lt;= y {
        println!(&quot;y is bigger&quot;); // Not hit
    } else if y &lt;= x {
        println!(&quot;x is bigger&quot;); // Not hit
    } else {
        println!(&quot;Neither is bigger&quot;); // This one
    }</code></pre>
<h2 id="hash"><a class="header" href="#hash"><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a></a></h2>
<p>The <a name="a055"></a><code>Hash</code> trait is used to produce a single value that has a high probability of being different for different
items; this value is used as the basis for hash-bucket based data structures like
<a name="a056"></a><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> and
<a name="a057"></a><a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html"><code>HashSet</code></a>.</p>
<p>Flipping this around, it's essential that the &quot;same&quot; items (as per <code>Eq</code>) always produce the same hash; if <code>x == y</code>
(via <code>Eq</code>) then it must always be true that <code>hash(x) == hash(y)</code>.  <strong>If you have a manual <code>Eq</code> implementation, check
whether you also need a manual implementation of <code>Hash</code></strong> to comply with this requirement.</p>
<h2 id="debug-and-display"><a class="header" href="#debug-and-display"><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> and <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a></a></h2>
<p>The <a name="a058"></a><code>Debug</code> and <a name="a059"></a><code>Display</code> traits allow a type to specify how it should be included in output, for either
normal (<code>{}</code> format argument) or debugging purposes (<code>{:?}</code> format argument), roughly analogous to an <code>operator&lt;&lt;</code>
overload for <code>iostream</code> in C++.</p>
<p>The differences between the intents of the two traits go beyond which format specifier is needed, though:</p>
<ul>
<li><code>Debug</code> can be automatically <a name="a060"></a>derived, <code>Display</code> can only be manually implemented. This is related
toâ€¦</li>
<li>The layout of <code>Debug</code> output may change between different Rust versions.  If the output will ever be parsed by
other code, use <code>Display</code>.</li>
<li><code>Debug</code> is programmer-oriented, <code>Display</code> is user-oriented. A thought experiment that helps with this is to
consider what would happen if the program was
<a href="https://en.wikipedia.org/wiki/Internationalization_and_localization">localized</a> to a language that the authors don't
speak; <code>Display</code> is appropriate if the content should be translated, <code>Debug</code> if not.</li>
</ul>
<p>As a general rule, <strong>add an automatically generated <code>Debug</code> implementation for your types</strong> unless they contain
sensitive information (personal details, cryptographic material etc.).  A manual implementation of <code>Debug</code> can be
appropriate when the automatically generated version would emit voluminous amounts of detail.</p>
<p>Implement <code>Display</code> if your types are designed to be shown to end users in textual output.</p>
<h2 id="operator-overloads"><a class="header" href="#operator-overloads">Operator Overloads</a></h2>
<p>Similarly to C++, Rust allows various arithmetic and bitwise operators to be overloaded for user-defined types.  This
is useful for &quot;algebraic&quot; or bit-manipulation types (respectively) where there is a natural interpretation of these
operators.  However, experience from C++ has shown that it's best to <strong>avoid overloading operators for unrelated types</strong>
as it often leads to code that is hard to maintain and has unexpected performance properties (e.g. <code>x + y</code> silently
invokes an expensive O(N) method).</p>
<p>Continuing with the principle of least surprise, if you implement any operator overloads you should <strong>implement a
coherent set of operator overloads</strong>. For example, if <code>x + y</code> has an overload
(<a name="a061"></a><a href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a>), and <code>-y</code>
(<a name="a062"></a><a href="https://doc.rust-lang.org/std/ops/trait.Neg.html"><code>Neg</code></a>), then you should also implement <code>x - y</code>
(<a name="a063"></a><a href="https://doc.rust-lang.org/std/ops/trait.Sub.html"><code>Sub</code></a>) and make sure it gives the same answer as <code>x + (-y)</code>.</p>
<p>The items passed to the operator overload traits are moved, which means that non-<code>Copy</code> types will be consumed by
default.  Adding implementations for <code>&amp;'a MyType</code> can help with this, but requires more boilerplate to cover all of the
possibilities (e.g. there are 4 = 2 Ã— 2 possibilities for combining reference/non-reference arguments to a binary
operator).</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>This item has covered a lot of ground, so some tables that summarize the standard traits that have been touched on are
in order. First, the traits of this Item, all of which can be automatically <a name="a064"></a><code>derive</code>d <strong>except <a name="a065"></a><code>Display</code></strong>.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Trait</th><th style="text-align: center">Compiler Use</th><th style="text-align: center">Bound</th><th style="text-align: left">Methods</th></tr></thead><tbody>
<tr><td style="text-align: left"><a name="a066"></a><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html#tymethod.clone"><code>clone</code></a></td></tr>
<tr><td style="text-align: left"><a name="a067"></a><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a></td><td style="text-align: center"><code>let y = x;</code></td><td style="text-align: center"><code>Clone</code></td><td style="text-align: left">Marker trait</td></tr>
<tr><td style="text-align: left"><a name="a068"></a><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default"><code>default</code></a></td></tr>
<tr><td style="text-align: left"><a name="a069"></a><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a></td><td style="text-align: center"><code>x == y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialEq.html#tymethod.eq"><code>eq</code></a></td></tr>
<tr><td style="text-align: left"><a name="a070"></a><a href="https://doc.rust-lang.org/beta/std/cmp/trait.Eq.html"><code>Eq</code></a></td><td style="text-align: center"><code>x == y</code></td><td style="text-align: center"><code>PartialEq</code></td><td style="text-align: left">Marker trait</td></tr>
<tr><td style="text-align: left"><a name="a071"></a><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></td><td style="text-align: center"><code>x &lt; y</code>, <div><code>x &lt;= y</code>,</div>â€¦</td><td style="text-align: center"><code>PartialEq</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialOrd.html#tymethod.partial_cmp"><code>partial_cmp</code></a></td></tr>
<tr><td style="text-align: left"><a name="a072"></a><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialOrd.html"><code>Ord</code></a></td><td style="text-align: center"><code>x &lt; y</code>, <div><code>x &lt;= y</code>,</div>â€¦</td><td style="text-align: center"><code>Eq + PartialOrd</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/beta/std/cmp/trait.Ord.html#tymethod.cmp"><code>cmp</code></a></td></tr>
<tr><td style="text-align: left"><a name="a073"></a><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html#tymethod.hash"><code>hash</code></a></td></tr>
<tr><td style="text-align: left"><a name="a074"></a><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a></td><td style="text-align: center"><code>format!(&quot;{:?}&quot;, x)</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html#tymethod.fmt"><code>fmt</code></a></td></tr>
<tr><td style="text-align: left"><a name="a075"></a><a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a></td><td style="text-align: center"><code>format!(&quot;{}&quot;, x)</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Display.html#tymethod.fmt"><code>fmt</code></a></td></tr>
</tbody></table>
</div>
<p>The operator overloads are in the next table. None of these can be <a name="a076"></a><code>derive</code>d.</p>
<!--- NOTE: The entries for bitwise OR use U+23AE rather than vertical bar to avoid confusing the columns --->
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Trait</th><th style="text-align: center">Compiler Use</th><th style="text-align: center">Bound</th><th style="text-align: left">Methods</th></tr></thead><tbody>
<tr><td style="text-align: left"><a name="a077"></a><a href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a></td><td style="text-align: center"><code>x + y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Add.html#tymethod.add"><code>add</code></a></td></tr>
<tr><td style="text-align: left"><a name="a078"></a><a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html"><code>AddAssign</code></a></td><td style="text-align: center"><code>x += y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html#tymethod.add_assign"><code>add_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a079"></a><a href="https://doc.rust-lang.org/std/ops/trait.BitAnd.html"><code>BitAnd</code></a></td><td style="text-align: center"><code>x &amp; y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitAnd.html#tymethod.bitand"><code>bitand</code></a></td></tr>
<tr><td style="text-align: left"><a name="a080"></a><a href="https://doc.rust-lang.org/std/ops/trait.BitAndAssign.html"><code>BitAndAssign</code></a></td><td style="text-align: center"><code>x &amp;= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitAndAssign.html#tymethod.bitand_assign"><code>bitand_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a081"></a><a href="https://doc.rust-lang.org/std/ops/trait.BitOr.html"><code>BitOr</code></a></td><td style="text-align: center"><code>x âŽ® y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitOr.html#tymethod.bitor"><code>bitor</code></a></td></tr>
<tr><td style="text-align: left"><a name="a082"></a><a href="https://doc.rust-lang.org/std/ops/trait.BitOrAssign.html"><code>BitOrAssign</code></a></td><td style="text-align: center"><code>x âŽ®= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitOrAssign.html#tymethod.bitor_assign"><code>bitor_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a083"></a><a href="https://doc.rust-lang.org/std/ops/trait.BitXor.html"><code>BitXor</code></a></td><td style="text-align: center"><code>x ^ y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitXor.html#tymethod.bitxor"><code>bitxor</code></a></td></tr>
<tr><td style="text-align: left"><a name="a084"></a><a href="https://doc.rust-lang.org/std/ops/trait.BitXorAssign.html"><code>BitXorAssign</code></a></td><td style="text-align: center"><code>x ^= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitXorAssign.html#tymethod.bitxor_assign"><code>bitxor_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a085"></a><a href="https://doc.rust-lang.org/std/ops/trait.Div.html"><code>Div</code></a></td><td style="text-align: center"><code>x / y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Div.html#tymethod.div"><code>div</code></a></td></tr>
<tr><td style="text-align: left"><a name="a086"></a><a href="https://doc.rust-lang.org/std/ops/trait.DivAssign.html"><code>DivAssign</code></a></td><td style="text-align: center"><code>x /= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.DivAssign.html#tymethod.div_assign"><code>div_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a087"></a><a href="https://doc.rust-lang.org/std/ops/trait.Mul.html"><code>Mul</code></a></td><td style="text-align: center"><code>x * y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Mul.html#tymethod.mul"><code>mul</code></a></td></tr>
<tr><td style="text-align: left"><a name="a088"></a><a href="https://doc.rust-lang.org/std/ops/trait.MulAssign.html"><code>MulAssign</code></a></td><td style="text-align: center"><code>x *= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.MulAssign.html#tymethod.mul_assign"><code>mul_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a089"></a><a href="https://doc.rust-lang.org/std/ops/trait.Neg.html"><code>Neg</code></a></td><td style="text-align: center"><code>-x</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Neg.html#tymethod.neg"><code>neg</code></a></td></tr>
<tr><td style="text-align: left"><a name="a090"></a><a href="https://doc.rust-lang.org/std/ops/trait.Not.html"><code>Not</code></a></td><td style="text-align: center"><code>!x</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Not.html#tymethod.not"><code>not</code></a></td></tr>
<tr><td style="text-align: left"><a name="a091"></a><a href="https://doc.rust-lang.org/std/ops/trait.Rem.html"><code>Rem</code></a></td><td style="text-align: center"><code>x % y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Rem.html#tymethod.rem"><code>rem</code></a></td></tr>
<tr><td style="text-align: left"><a name="a092"></a><a href="https://doc.rust-lang.org/std/ops/trait.RemAssign.html"><code>RemAssign</code></a></td><td style="text-align: center"><code>x %= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.RemAssign.html#tymethod.rem_assign"><code>rem_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a093"></a><a href="https://doc.rust-lang.org/std/ops/trait.Shl.html"><code>Shl</code></a></td><td style="text-align: center"><code>x &lt;&lt; y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Shl.html#tymethod.shl"><code>shl</code></a></td></tr>
<tr><td style="text-align: left"><a name="a094"></a><a href="https://doc.rust-lang.org/std/ops/trait.ShlAssign.html"><code>ShlAssign</code></a></td><td style="text-align: center"><code>x &lt;&lt;= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.ShlAssign.html#tymethod.shl_assign"><code>shl_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a095"></a><a href="https://doc.rust-lang.org/std/ops/trait.Shr.html"><code>Shr</code></a></td><td style="text-align: center"><code>x &gt;&gt; y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Shr.html#tymethod.shr"><code>shr</code></a></td></tr>
<tr><td style="text-align: left"><a name="a096"></a><a href="https://doc.rust-lang.org/std/ops/trait.ShrAssign.html"><code>ShrAssign</code></a></td><td style="text-align: center"><code>x &gt;&gt;= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.ShrAssign.html#tymethod.shr_assign"><code>shr_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a097"></a><a href="https://doc.rust-lang.org/std/ops/trait.Sub.html"><code>Sub</code></a></td><td style="text-align: center"><code>x - y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Sub.html#tymethod.sub"><code>sub</code></a></td></tr>
<tr><td style="text-align: left"><a name="a098"></a><a href="https://doc.rust-lang.org/std/ops/trait.SubAssign.html"><code>SubAssign</code></a></td><td style="text-align: center"><code>x -= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.SubAssign.html#tymethod.sub_assign"><code>sub_assign</code></a></td></tr>
</tbody></table>
</div>
<p>For completeness, the standard traits that are covered in other items are included in the following table; none of these
traits are <a name="a099"></a><code>derive</code>able (but <a name="a100"></a><code>Send</code> and <a name="a101"></a><code>Sync</code> may be automatically implemented by the compiler).</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Trait</th><th style="text-align: center">Item</th><th style="text-align: center">Compiler Use</th><th style="text-align: center">Bound</th><th style="text-align: left">Methods</th></tr></thead><tbody>
<tr><td style="text-align: left"><a name="a102"></a><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a></td><td style="text-align: center"><a href="use-types-2.html">Item 2</a></td><td style="text-align: center"><code>x(a)</code></td><td style="text-align: center"><code>FnMut</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html#tymethod.call"><code>call</code></a></td></tr>
<tr><td style="text-align: left"><a name="a103"></a><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a></td><td style="text-align: center"><a href="use-types-2.html">Item 2</a></td><td style="text-align: center"><code>x(a)</code></td><td style="text-align: center"><code>FnOnce</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html#tymethod.call_mut"><code>call_mut</code></a></td></tr>
<tr><td style="text-align: left"><a name="a104"></a><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></td><td style="text-align: center"><a href="use-types-2.html">Item 2</a></td><td style="text-align: center"><code>x(a)</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html#tymethod.call_once"><code>call_once</code></a></td></tr>
<tr><td style="text-align: left"><a name="a105"></a><a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a></td><td style="text-align: center"><a href="errors.html">Item 4</a></td><td style="text-align: center"></td><td style="text-align: center"><code>Display + Debug</code></td><td style="text-align: left">[<a href="https://doc.rust-lang.org/std/error/trait.Error.html#method.source"><code>source</code></a>]</td></tr>
<tr><td style="text-align: left"><a name="a106"></a><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a></td><td style="text-align: center"><a href="casts.html">Item 6</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.From.html#tymethod.from"><code>from</code></a></td></tr>
<tr><td style="text-align: left"><a name="a107"></a><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a></td><td style="text-align: center"><a href="casts.html">Item 6</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html#tymethod.try_from"><code>try_from</code></a></td></tr>
<tr><td style="text-align: left"><a name="a108"></a><a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a></td><td style="text-align: center"><a href="casts.html">Item 6</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.Into.html#tymethod.into"><code>into</code></a></td></tr>
<tr><td style="text-align: left"><a name="a109"></a><a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a></td><td style="text-align: center"><a href="casts.html">Item 6</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html#tymethod.try_into"><code>try_into</code></a></td></tr>
<tr><td style="text-align: left"><a name="a110"></a><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html#tymethod.as_ref"><code>as_ref</code></a></td></tr>
<tr><td style="text-align: left"><a name="a111"></a><a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html"><code>AsMut</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html#tymethod.as_mut"><code>as_mut</code></a></td></tr>
<tr><td style="text-align: left"><a name="a112"></a><a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html#tymethod.borrow"><code>borrow</code></a></td></tr>
<tr><td style="text-align: left"><a name="a113"></a><a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html"><code>BorrowMut</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"></td><td style="text-align: center"><code>Borrow</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html#tymethod.borrow_mut"><code>borrow_mut</code></a></td></tr>
<tr><td style="text-align: left"><a name="a114"></a><a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html"><code>ToOwned</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned"> <code>to_owned</code></a></td></tr>
<tr><td style="text-align: left"><a name="a115"></a><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"><code>*x</code>, <code>&amp;x</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#tymethod.deref"><code>deref</code></a></td></tr>
<tr><td style="text-align: left"><a name="a116"></a><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"><code>*x</code>, <code>&amp;mut x</code></td><td style="text-align: center"><code>Deref</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html#tymethod.deref_mut"><code>deref_mut</code></a></td></tr>
<tr><td style="text-align: left"><a name="a117"></a><a href="https://doc.rust-lang.org/std/ops/trait.Index.html"><code>Index</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"><code>x[idx]</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Index.html#tymethod.index"><code>index</code></a></td></tr>
<tr><td style="text-align: left"><a name="a118"></a><a href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html"><code>IndexMut</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"><code>x[idx] = ...</code></td><td style="text-align: center"><code>Index</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html#tymethod.index_mut"><code>index_mut</code></a></td></tr>
<tr><td style="text-align: left"><a name="a119"></a><a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html"><code>Pointer</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"><code>format(&quot;{:p}&quot;, x)</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html#tymethod.fmt"><code>fmt</code></a></td></tr>
<tr><td style="text-align: left"><a name="a120"></a><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a></td><td style="text-align: center"><a href="iterators.html">Item 10</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#tymethod.next"><code>next</code></a></td></tr>
<tr><td style="text-align: left"><a name="a121"></a><a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html"><code>IntoIterator</code></a></td><td style="text-align: center"><a href="iterators.html">Item 10</a></td><td style="text-align: center"><code>for y in x</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html#tymethod.into_iter"><code>into_iter</code></a></td></tr>
<tr><td style="text-align: left"><a name="a122"></a><a href="https://doc.rust-lang.org/core/iter/trait.FromIterator.html"><code>FromIterator</code></a></td><td style="text-align: center"><a href="iterators.html">Item 10</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.FromIterator.html#tymethod.from_iter"><code>from_iter</code></a></td></tr>
<tr><td style="text-align: left"><a name="a123"></a><a href="https://doc.rust-lang.org/core/iter/trait.ExactSizeIterator.html"><code>ExactSizeIterator</code></a></td><td style="text-align: center"><a href="iterators.html">Item 10</a></td><td style="text-align: center"></td><td style="text-align: center"><code>Iterator</code></td><td style="text-align: left">(<a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.size_hint"><code>size_hint</code></a>)</td></tr>
<tr><td style="text-align: left"><a name="a124"></a><a href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a></td><td style="text-align: center"><a href="iterators.html">Item 10</a></td><td style="text-align: center"></td><td style="text-align: center"><code>Iterator</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html#tymethod.next_back"><code>next_back</code></a></td></tr>
<tr><td style="text-align: left"><a name="a125"></a><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a></td><td style="text-align: center"><a href="raii.html">Item 11</a></td><td style="text-align: center"><code>}</code> (end of scope)</td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a></td></tr>
<tr><td style="text-align: left"><a name="a126"></a><a href="https://doc.rust-lang.org/std/marker/trait.Sized.html"><code>Sized</code></a></td><td style="text-align: center"><a href="borrows.html">Item 15</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left">Marker trait</td></tr>
<tr><td style="text-align: left"><a name="a127"></a><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a></td><td style="text-align: center"><a href="deadlock.html">Item 17</a></td><td style="text-align: center">cross-thread transfer</td><td style="text-align: center"></td><td style="text-align: left">Marker trait</td></tr>
<tr><td style="text-align: left"><a name="a128"></a><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a></td><td style="text-align: center"><a href="deadlock.html">Item 17</a></td><td style="text-align: center">cross-thread use</td><td style="text-align: center"></td><td style="text-align: left">Marker trait</td></tr>
</tbody></table>
</div><p><hr/>
<p><a name="footnote-1"><a href="std-traits.html#to-footnote-1">1</a></a>: As do
several of the other marker traits in <code>std::marker</code>.</p>
<p><a name="footnote-2"><a href="std-traits.html#to-footnote-2">2</a></a>: Of course, comparing floats
for equality is always a dangerous game, as there is typically no guarantee that rounded calculations will produce a
result that is bit-for-bit identical to the number you first thought of.</p>
<p><a name="footnote-3"><a href="std-traits.html#to-footnote-3">3</a></a>: More generally, any <a name="a054"></a><a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice
structure</a> also has a partial order.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-6-understand-type-conversions"><a class="header" href="#item-6-understand-type-conversions">Item 6: Understand type conversions</a></h1>
<p>In general, Rust does not perform automatic conversion between types. This includes integral types, even when the
transformation is &quot;safe&quot;:</p>
<pre><code class="language-rust ignore does_not_compile">        let x: u32 = 2;
        let y: u64 = x;</code></pre>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; casts/src/main.rs:69:22
   |
69 |         let y: u64 = x;
   |                ---   ^ expected `u64`, found `u32`
   |                |
   |                expected due to this
   |
help: you can convert a `u32` to a `u64`
   |
69 |         let y: u64 = x.into();
   |                       +++++++
</code></pre>
<p>Rust type conversions fall into three categories:</p>
<ul>
<li><em>manual</em>: user-defined type conversions provided by implementing the <a name="a001"></a><code>From</code> and <a name="a002"></a><code>Into</code> traits</li>
<li><em>semi-automatic</em>: explicit <strong><a name="a003"></a>casts</strong> between values using the <a name="a004"></a><code>as</code> keyword</li>
<li><em>automatic</em>: implicit <strong><a name="a005"></a>coercion</strong> into a new type.</li>
</ul>
<p>The latter two don't apply to conversions of user defined types (with a couple of exceptions), so the majority of this
Item will focus on manual conversion â€“ which the compiler error message also pointed towards.</p>
<p>However, sections at the end of the Item discuss casting and coercion â€“ including
the exceptions where they can apply to a user-defined type.</p>
<h2 id="user-defined-type-conversions"><a class="header" href="#user-defined-type-conversions">User-Defined Type Conversions</a></h2>
<p>As with other features of the language (<a href="std-traits.html">Item 5</a>) the ability to perform conversions between values of different
user-defined types is encapsulated as a standard trait â€“ or rather, as a set of related <a name="a006"></a>generic traits.</p>
<p>The four relevant traits that express the ability to convert values of a type are:</p>
<ul>
<li><a name="a007"></a><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From&lt;T&gt;</code></a>: Items of this type can be built from
items of type <code>T</code>.</li>
<li><a name="a008"></a><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom&lt;T&gt;</code></a>: Items of this type can
<em>sometimes</em> be built from items of type <code>T</code>.</li>
<li><a name="a009"></a><a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into&lt;T&gt;</code></a>: Items of this type can converted
into items of type <code>T</code>.</li>
<li><a name="a010"></a><a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto&lt;T&gt;</code></a>: Items of this type can
<em>sometimes</em> be converted into items of type <code>T</code>.</li>
</ul>
<p>Given the discussion in <a href="use-types.html">Item 1</a> about expressing things in the type system, it's no surprise to discover that the
difference with the <code>Try...</code> variants is that the sole trait method returns a <a name="a011"></a><code>Result</code> rather than a guaranteed
new item.  The <code>Try...</code> trait definitions also require an <a name="a012"></a>associated type that gives the type of the error <code>E</code>
emitted for failure situations.</p>
<p>The first piece of advice is therefore to <strong>implement (just) the <code>Try...</code> trait if it's possible for a conversion to
fail</strong>, in line with <a href="errors.html">Item 4</a>.  The alternative is to ignore the possibility of error (e.g. with <code>.unwrap()</code>), but that
needs to be a deliberate choice and in most cases it's best to leave that choice to the caller.</p>
<p>The type conversion traits have an obvious symmetry: if a type <code>T</code> can be transmuted <code>into</code> a type <code>U</code>, isn't that the
same as it being possible to create an item of type <code>U</code> by transmutation <code>from</code> an item of type <code>T</code>?</p>
<p>This is indeed the case, and it leads to the second piece of advice: <strong>implement the <code>From</code> trait for conversions</strong>.
The Rust standard library had to pick just one of the two possibilities, in order to prevent the system from spiralling
around in dizzy circles<sup><a name="to-footnote-1"><a href="casts.html#footnote-1">1</a></a></sup>, and it came down on the
side of automatically providing <code>Into</code> from a <code>From</code> implementation.</p>
<p>If you're consuming one of these two traits, as a trait bound on a new generic of your own, then the advice is reversed:
<strong>use the <code>Into</code> trait for <a name="a014"></a>trait bounds</strong>.  That way, the bound will be satisfied both by things that directly
implement <code>Into</code>, <em>and</em> by things that only directly implement <code>From</code>.</p>
<p>This automatic conversion is highlighted by the documentation for <code>From</code> and <code>Into</code>, but it's worth reading the relevant
part of the standard library code too, which is a <a name="a015"></a><em>blanket trait implementation</em>:</p>
<pre><code class="language-rust ignore">impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt;,
{
    fn into(self) -&gt; U {
        U::from(self)
    }
}</code></pre>
<p>Translating a trait specification into words can help with understanding more complex trait bounds; in this case, it's
fairly simple: &quot;I can implement <code>Into&lt;U&gt;</code> for a type <code>T</code> whenever <code>U</code> already implements <code>From&lt;T&gt;</code>&quot;.</p>
<p>The standard library also includes various implementations of these conversion traits for standard library types.  As
you'd expect, there are <code>From</code> implementations for safe integral conversions (<code>From&lt;u32&gt; for u64</code>) and <code>TryFrom</code>
implementations when the conversion isn't safe (<code>TryFrom&lt;u64&gt; for u32</code>).</p>
<p>There are also various other blanket trait implementations in addition to the <code>Into</code> version shown above, which
you can find by searching for <code>impl&lt;T&gt; From&lt;T&gt; for ...</code>. These are almost all for <em><a name="a016"></a>smart pointer</em> types,
allowing the smart pointer to be automatically constructed from an instance of the type that it holds, so that methods
that accept smart pointer parameters can also be called with plain old items; more on this below and in <a href="references.html">Item 9</a>.</p>
<p>The <code>TryFrom</code> trait also has a blanket implementation for any type that already implements the <code>Into</code> trait in the
opposite direction â€“ which automatically includes (as above) any type that implements <code>From</code> in the same
direction. In other words, if you can infallibly convert a <code>T</code> into a <code>U</code>, you can also fallibly obtain a <code>U</code> from a
<code>T</code>; as this conversion will always succeed, the associated error type is <sup><a name="to-footnote-2"><a href="casts.html#footnote-2">2</a></a></sup>  the helpfully named <a href="https://doc.rust-lang.org/std/convert/enum.Infallible.html"><code>Infallible</code></a>.</p>
<p>There's also one very specific generic implementation of <code>From</code> that sticks out, the <em><a name="a017"></a>reflexive implementation</em>:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; From&lt;T&gt; for T {
    fn from(t: T) -&gt; T {
        t
    }
}</code></pre>
<p>Translating into words, this just says that &quot;given a <code>T</code> I can get a <code>T</code>&quot;. That's such an obvious &quot;well, duh&quot; that it's
worth stopping to understand why this is useful.</p>
<p>Consider a simple newtype <code>struct</code> (<a href="newtype.html">Item 7</a>) and a function that operates on it (ignoring that this function would be
better expressed as a method):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Integer value from an IANA-controlled range.
#[derive(Clone, Copy, Debug)]
pub struct IanaAllocated(pub u64);

/// Indicate whether value is reserved.
pub fn is_iana_reserved(s: IanaAllocated) -&gt; bool {
    s.0 == 0 || s.0 == 65535
}
<span class="boring">}</span></code></pre></pre>
<p>This function can be invoked with instances of the <code>struct</code></p>
<pre><code class="language-rust ignore">    let s = IanaAllocated(1);
    println!(&quot;{:?} reserved? {}&quot;, s, is_iana_reserved(s));
    // output: &quot;IanaAllocated(1) reserved? false&quot;</code></pre>
<p>but even if <code>From&lt;u64&gt;</code> is implemented for the newtype wrapper</p>
<pre><code class="language-rust ignore">impl From&lt;u64&gt; for IanaAllocated {
    fn from(v: u64) -&gt; Self {
        Self(v)
    }
}</code></pre>
<p>the function can't be directly invoked for <code>u64</code> values</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; casts/src/main.rs:82:29
   |
82 |         if is_iana_reserved(42) {
   |                             ^^ expected struct `IanaAllocated`, found integer
</code></pre>
<p>However, a <a name="a018"></a>generic version of the function that accepts (and explicitly converts) anything
satisfying <code>Into&lt;IanaAllocated&gt;</code>:</p>
<pre><code class="language-rust ignore">    pub fn is_iana_reserved&lt;T&gt;(s: T) -&gt; bool
    where
        T: Into&lt;IanaAllocated&gt;,
    {
        let s = s.into();
        s.0 == 0 || s.0 == 65535
    }</code></pre>
<p>allows this use:</p>
<pre><code class="language-rust ignore">        if is_iana_reserved(42) {</code></pre>
<p>With this trait bound in place, the reflexive trait implementation of <code>From&lt;T&gt;</code> makes more sense: it means that the
generic function copes with items which are already <code>IanaAllocated</code> instances, no conversion needed.</p>
<p>This pattern also explains why (and how) Rust code sometimes <em>appears</em> to be doing implicit casts between types: the
combination of <code>From&lt;T&gt;</code> implementations and <code>Into&lt;T&gt;</code> trait bounds leads to code that appears to magically convert at
the call site (but which is still doing safe, explicit, conversions under the covers), This pattern becomes even more
powerful when combined with reference types and their related conversion traits; more in <a href="references.html">Item 9</a>.</p>
<h2 id="casts"><a class="header" href="#casts">Casts</a></h2>
<p>Rust includes the <a name="a019"></a><code>as</code> keyword to perform explicit
<a name="a020"></a><a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions"><strong>casts</strong></a> between
some pairs of types.</p>
<p>The pairs of types that can be converted in this way is a fairly limited set, and the only user-defined types it
includes are &quot;C-like&quot; <a name="a021"></a><code>enum</code>s (those that have just an associated integer value). General integral conversions are
included though, giving an alternative to <code>into()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x: u32 = 9;
    let y = x as u64;
    let z: u64 = x.into();
<span class="boring">}</span></code></pre></pre>
<p>The <code>as</code> version also allows lossy conversions<sup><a name="to-footnote-3"><a href="casts.html#footnote-3">3</a></a></sup>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x: u32 = 9;
    let y = x as u16;
<span class="boring">}</span></code></pre></pre>
<p>which would be rejected by the <code>from</code> / <code>into</code> versions:</p>
<pre><code class="language-text">error[E0277]: the trait bound `u16: From&lt;u32&gt;` is not satisfied
   --&gt; casts/src/main.rs:124:20
    |
124 |     let y: u16 = x.into();
    |                    ^^^^ the trait `From&lt;u32&gt;` is not implemented for `u16`
    |
    = help: the following implementations were found:
              &lt;u16 as From&lt;NonZeroU16&gt;&gt;
              &lt;u16 as From&lt;bool&gt;&gt;
              &lt;u16 as From&lt;u8&gt;&gt;
              &lt;f32 as From&lt;i16&gt;&gt;
            and 71 others
    = note: required because of the requirements on the impl of `Into&lt;u16&gt;` for `u32`
</code></pre>
<p>For consistency and safety you should <strong>prefer <code>from</code> / <code>into</code> conversions to <code>as</code> casts</strong>, unless you understand and
need the precise <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#semantics">casting semantics</a> (e.g
for C interoperability).</p>
<h2 id="coercion"><a class="header" href="#coercion">Coercion</a></h2>
<p>The explicit <code>as</code> casts described in the previous section are a superset of the implicit
<a href="https://doc.rust-lang.org/reference/type-coercions.html"><strong>coercions</strong></a> that the compiler will silently perform:
any <a name="a022"></a>coercion can be forced with an explicit <code>as</code>, but the converse is not true.  In particular, the integral
conversions performed in the previous section are not coercions, and so will always require <code>as</code>.</p>
<p>Most of the coercions involve silent conversions of pointer and reference types in ways that are sensible and convenient
for the programmer, such as:</p>
<ul>
<li>converting a mutable reference to a non-mutable references (so you can use a <code>&amp;mut T</code> as the argument to a function
that takes a <code>&amp;T</code>)</li>
<li>converting a reference to a raw pointer (this isn't <code>unsafe</code> â€“ the unsafety happens at the point where you're
foolish enough to <em>use</em> a raw pointer)</li>
<li>converting a closure that happens not to capture any variables into a bare function pointer (<a href="use-types-2.html">Item 2</a>)</li>
<li>converting an <a href="https://doc.rust-lang.org/std/primitive.array.html">array</a> to a
<a href="https://doc.rust-lang.org/std/primitive.slice.html">slice</a></li>
<li>converting a concrete item to a <a href="https://doc.rust-lang.org/reference/types/trait-object.html">trait object</a>, for a
trait that the concrete item implements</li>
<li>converting<sup><a name="to-footnote-4"><a href="casts.html#footnote-4">4</a></a></sup> an item lifetime to a &quot;shorter&quot; one (<a href="lifetimes.html">Item 14</a>).</li>
</ul>
<p>There are only two coercions whose behaviour can be affected by user-defined types. The first of these is when a
user-defined type implements the <a name="a023"></a><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> or the
<a name="a024"></a><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a> trait.  These traits indicate that the user defined
type is acting as a <em>smart pointer</em> of some sort (<a href="references.html">Item 9</a>), and in this case the compiler will coerce a reference to
the smart pointer item into being a reference to an item of the type that the smart pointer contains (indicated by
its <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#associatedtype.Target"><code>Target</code></a>).</p>
<p>The second coercion of a user-defined type happens when a concrete item is converted to a <em><a name="a025"></a>trait object</em>. This
operation builds a <a name="a026"></a>fat pointer to the item; this pointer is fat because it includes both a pointer to the item's
location in memory, together with a pointer to the <em><a name="a027"></a>vtable</em> for the concrete type's implementation of the trait
â€“ see <a href="references.html">Item 9</a>.</p>
<p><hr/>
<p><a name="footnote-1"><a href="casts.html#to-footnote-1">1</a></a>: More properly known as the <em><a name="a013"></a>trait coherence rules</em>.</p>
<p><a name="footnote-2"><a href="casts.html#to-footnote-2">2</a></a>: For now â€“ this is
likely to be replaced with the <a href="https://doc.rust-lang.org/std/primitive.never.html"><code>!</code> &quot;never&quot; type</a> in a future
version of Rust.</p>
<p><a name="footnote-3"><a href="casts.html#to-footnote-3">3</a></a>: Allowing lossy conversions in Rust was probably a mistake, and
there have been <a href="https://internals.rust-lang.org/t/lets-deprecate-as-for-lossy-numeric-casts/16283">discussions</a> around
trying to remove this behaviour.</p>
<p><a name="footnote-4"><a href="casts.html#to-footnote-4">4</a></a>: Rust refers to these conversions as
<a href="https://doc.rust-lang.org/reference/subtyping.html">&quot;subtyping&quot;</a>, but it's quite different that the definition of
&quot;subtyping&quot; used in object-oriented languages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-7-embrace-the-newtype-pattern"><a class="header" href="#item-7-embrace-the-newtype-pattern">Item 7: Embrace the newtype pattern</a></h1>
<p><a href="use-types.html">Item 1</a> described <em><a name="a001"></a>tuple structs</em>, where the fields of a <code>struct</code> have no names and are instead referred to by number
(<code>self.0</code>).  This Item focuses on tuple structs that have a single entry, which is a pattern that's sufficiently
pervasive in Rust that it deserves its own Item and has its own name: the <strong><a name="a002"></a>newtype pattern</strong>.</p>
<p>The simplest use of the newtype pattern is to indicate <a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction">additional semantics for a
type</a>,
over and above its normal behaviour.  To illustrate this, imagine a project that's going to send a satellite to
Mars<sup><a name="to-footnote-1"><a href="newtype.html#footnote-1">1</a></a></sup>.  It's a
big project, so different groups have built different parts of the project. One group has handled the code for the
rocket engines:</p>
<pre><code class="language-rust ignore">    /// Fire the thrusters. Returns generated force in Newton seconds.
    pub fn thruster_impulse(direction: Direction) -&gt; f64 {
        // ...
        return 42.0;
    }</code></pre>
<p>while a different group handles the inertial guidance system:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Update trajectory model for impulse, provided in pound force seconds.
    pub fn update_trajectory(force: f64) {
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>Eventually these different parts eventually need to be joined together:</p>
<pre><code class="language-rust ignore">        let thruster_force: f64 = thruster_impulse(direction);
        let new_direction = update_trajectory(thruster_force);</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure">Ruh-roh</a>.</p>
<p>Rust includes a <em><a name="a003"></a>type alias</em> feature, which allows the different groups to make their intentions clearer:</p>
<pre><code class="language-rust ignore">    /// Units for force.
    pub type NewtonSeconds = f64;

    /// Fire the thrusters. Returns generated force.
    pub fn thruster_impulse(direction: Direction) -&gt; NewtonSeconds {
        // ...
        return 42.0;
    }</code></pre>
<pre><code class="language-rust ignore">    /// Units for force.
    pub type PoundForceSeconds = f64;

    /// Update trajectory model for impulse.
    pub fn update_trajectory(force: PoundForceSeconds) {
        // ...
    }</code></pre>
<p>However, the type aliases are effectively just documentation; they're a stronger hint than the doc comments
of the previous version, but nothing stops a <code>NewtonSeconds</code> value being used where a
<code>PoundForceSeconds</code> value is expected:</p>
<pre><code class="language-rust ignore">        let thruster_force: NewtonSeconds = thruster_impulse(direction);
        let new_direction = update_trajectory(thruster_force);</code></pre>
<p>Ruh-roh once more.</p>
<p>This is the point where the newtype pattern helps.</p>
<pre><code class="language-rust ignore">/// Units for force.
pub struct NewtonSeconds(pub f64);

/// Fire the thrusters. Returns generated force.
pub fn thruster_impulse(direction: Direction) -&gt; NewtonSeconds {
    // ...
    return NewtonSeconds(42.0);
}</code></pre>
<pre><code class="language-rust ignore">/// Units for force.
pub struct PoundForceSeconds(pub f64);

/// Update trajectory model for impulse.
pub fn update_trajectory(force: PoundForceSeconds) {
    // ...
}</code></pre>
<p>As the name implies, a newtype is a new type, and as such the compiler objects to type conversions (cf. <a href="casts.html">Item 6</a>):</p>
<pre><code class="language-rust ignore does_not_compile">    let thruster_force: NewtonSeconds = thruster_impulse(direction);
    let new_direction = update_trajectory(thruster_force);</code></pre>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; newtype/src/main.rs:76:43
   |
76 |     let new_direction = update_trajectory(thruster_force);
   |                                           ^^^^^^^^^^^^^^ expected struct `PoundForceSeconds`, found struct `NewtonSeconds`
</code></pre>
<p>The same pattern of using a newtype to mark additional &quot;unit&quot; semantics for a type can also help to make boolean
arguments less ambiguous.  Revisiting the example from <a href="use-types.html">Item 1</a>, using newtypes makes the meaning of arguments clear:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DoubleSided(pub bool);

struct ColourOutput(pub bool);

fn print_page(sides: DoubleSided, colour: ColourOutput) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-rust ignore">    print_page(DoubleSided(true), ColourOutput(false));</code></pre>
<p>If size efficiency or binary compatibility is a concern, then the <a name="a004"></a><a href="https://doc.rust-lang.org/reference/type-layout.html#the-transparent-representation"><code>[repr(transparent)]</code>
attribute</a> ensures that a newtype
has the same representation in memory as the inner type.</p>
<p>That's the simple use of newtype, and it's a specific example of <a href="use-types.html">Item 1</a> â€“ encoding semantics into the type system, so
that the compiler takes care of policing those semantics.</p>
<h2 id="bypassing-the-orphan-rule-for-traits"><a class="header" href="#bypassing-the-orphan-rule-for-traits">Bypassing the Orphan Rule for Traits</a></h2>
<p>The other
<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">common</a>,
but more subtle, scenario that requires the newtype pattern revolves around Rust's <a name="a005"></a>orphan rule.
Roughly speaking, this says that you can only implement a trait for a type if:</p>
<ul>
<li>you own the trait, or</li>
<li>you own the type.</li>
</ul>
<p>Attempting to implement a foreign trait for a foreign type:</p>
<pre><code class="language-rust ignore does_not_compile">impl fmt::Display for rand::rngs::StdRng {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; Result&lt;(), fmt::Error&gt; {
        write!(f, &quot;&lt;StdRng instance&gt;&quot;)
    }
}</code></pre>
<p>leads to a compiler error (which in turn points the way back to newtypes).</p>
<pre><code class="language-text">error[E0117]: only traits defined in the current crate can be implemented for arbitrary types
   --&gt; newtype/src/main.rs:125:1
    |
125 | impl fmt::Display for rand::rngs::StdRng {
    | ^^^^^^^^^^^^^^^^^^^^^^------------------
    | |                     |
    | |                     `StdRng` is not defined in the current crate
    | impl doesn't use only types from inside the current crate
    |
    = note: define and implement a trait or new type instead
</code></pre>
<p>The reason for this restriction is due to the risk of ambiguity: if two different crates in the <a name="a006"></a>dependency graph
(<a href="dep-graph.html">Item 25</a>) were <em>both</em> to (say) <code>impl std::fmt::Display for rand::rngs::StdRng</code>, then the compiler/<a name="a007"></a>linker has no
way to choose between them.</p>
<p>This can frequently lead to frustration: for example, if you're trying to serialize data that includes a type from
another crate, the orphan rule prevents<sup><a name="to-footnote-2"><a href="newtype.html#footnote-2">2</a></a></sup> you from writing <code>impl serde::Serialize for somecrate::SomeType</code>.</p>
<p>But the newtype pattern means that you're creating a <em>new</em> type, which you own, and so the second part of the orphan trait
rule applies.  Implementing a foreign trait is now possible:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyRng(rand::rngs::StdRng);

use std::fmt;
impl fmt::Display for MyRng {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; Result&lt;(), fmt::Error&gt; {
        write!(f, &quot;&lt;Rng instance&gt;&quot;)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="newtype-limitations"><a class="header" href="#newtype-limitations">Newtype Limitations</a></h2>
<p>The newtype pattern solves these two classes of problems â€“ preventing unit conversions and bypassing the orphan
rule â€“ but it does come with some awkwardness: every operation that involves the newtype needs to forward
to the inner type.</p>
<p>On a trivial level that means that the code has to use <code>thing.0</code> throughout, rather than just <code>thing</code>, but that's easy
and the compiler will tell you where it's needed.</p>
<p>The more significant awkwardness is that any trait implementations on the inner type are lost: because the newtype is a
new type, the existing inner implementation doesn't apply.</p>
<p>For derivable traits this just means that the newtype declaration ends up with lots of <a name="a009"></a><code>derive</code>s:</p>
<pre><code class="language-rust ignore">    #[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct NewType(InnerType);</code></pre>
<p>However, for more sophisticated traits some forwarding boilerplate is needed to recover the inner type's implementation,
for example:</p>
<pre><code class="language-rust ignore">    use std::fmt;
    impl fmt::Display for NewType {
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; Result&lt;(), fmt::Error&gt; {
            self.0.fmt(f)
        }
    }</code></pre>
<p><hr/>
<p><a name="footnote-1"><a href="newtype.html#to-footnote-1">1</a></a>: Specifically, the <a href="https://en.wikipedia.org/wiki/Mars_Climate_Orbiter">Mars Climate Orbiter</a>.</p>
<p><a name="footnote-2"><a href="newtype.html#to-footnote-2">2</a></a>: This is a sufficiently common problem for <a name="a008"></a><code>serde</code> that it
includes a <a href="https://serde.rs/remote-derive.html">mechanism to help</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-8-use-builders-for-complex-types"><a class="header" href="#item-8-use-builders-for-complex-types">Item 8: Use builders for complex types</a></h1>
<p>Rust insists that all fields in a <a name="a001"></a><code>struct</code> must be filled in when a new instance of that <code>struct</code> is created. This
keeps the code safe, but does lead to more verbose boilerplate code than is ideal.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Default)]
struct BaseDetails {
    given_name: String,
    preferred_name: Option&lt;String&gt;,
    middle_name: Option&lt;String&gt;,
    family_name: String,
    mobile_phone_e164: Option&lt;String&gt;,
}

// ...

    let dizzy = BaseDetails {
        given_name: &quot;Dizzy&quot;.to_owned(),
        preferred_name: None,
        middle_name: None,
        family_name: &quot;Mixer&quot;.to_owned(),
        mobile_phone_e164: None,
    };
<span class="boring">}</span></code></pre></pre>
<p>This boilerplate code is also brittle, in the sense that a future change that adds a new field to the <code>struct</code> requires
an update to every place that builds the structure.</p>
<p>The boilerplate can be significantly reduced by implementing and using the
<a name="a002"></a><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait, as described in <a href="std-traits.html">Item 5</a><a name="a003"></a>:</p>
<pre><code class="language-rust ignore">    let dizzy = BaseDetails {
        given_name: &quot;Dizzy&quot;.to_owned(),
        family_name: &quot;Mixer&quot;.to_owned(),
        ..Default::default()
    };</code></pre>
<p>Using <code>Default</code> also helps reduce the changes needed when a new field is added, provided that the new field is itself of
a type that implements <code>Default</code>.</p>
<p>That's a more general concern: the automatically <a name="a004"></a>derived implementation of <code>Default</code> only works if all of
the field types implement the <code>Default</code> trait. If there's a field that doesn't play along, the <code>derive</code> step doesn't
work:</p>
<pre><code class="language-rust ignore does_not_compile">    #[derive(Debug, Default)]
    struct Details {
        given_name: String,
        preferred_name: Option&lt;String&gt;,
        middle_name: Option&lt;String&gt;,
        family_name: String,
        mobile_phone_e164: Option&lt;String&gt;,
        dob: chrono::Date&lt;chrono::Utc&gt;,
        last_seen: Option&lt;chrono::DateTime&lt;chrono::Utc&gt;&gt;,
    }</code></pre>
<pre><code class="language-text">error[E0277]: the trait bound `Date&lt;Utc&gt;: Default` is not satisfied
   --&gt; builders/src/main.rs:176:9
    |
169 |     #[derive(Debug, Default)]
    |                     ------- in this derive macro expansion
...
176 |         dob: chrono::Date&lt;chrono::Utc&gt;,
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `Date&lt;Utc&gt;`
    |
    = note: this error originates in the derive macro `Default` (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<p>The code can't implement <code>Default</code> for <code>chrono::Utc</code> because of the <a name="a005"></a>orphan rule, so this means that all of
the fields have to be filled out manually:</p>
<pre><code class="language-rust ignore">    use chrono::TimeZone;

    let bob = Details {
        given_name: &quot;Robert&quot;.to_owned(),
        preferred_name: Some(&quot;Bob&quot;.to_owned()),
        middle_name: Some(&quot;the&quot;.to_owned()),
        family_name: &quot;Builder&quot;.to_owned(),
        mobile_phone_e164: None,
        dob: chrono::Utc.ymd(1998, 11, 28),
        last_seen: None,
    };</code></pre>
<p>These ergonomics can be improved if you <strong>implement the <a name="a006"></a>builder pattern for complex data structures</strong>.</p>
<p>The simplest variant of the builder pattern is a separate <code>struct</code> that holds the information needed to construct the
item.  For simplicity, the example will hold an instance of the item itself.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DetailsBuilder(Details);

impl DetailsBuilder {
    /// Start building a new [`Details`] object.
    fn new(
        given_name: &amp;str,
        family_name: &amp;str,
        dob: chrono::Date&lt;chrono::Utc&gt;,
    ) -&gt; Self {
        DetailsBuilder(Details {
            given_name: given_name.to_owned(),
            preferred_name: None,
            middle_name: None,
            family_name: family_name.to_owned(),
            mobile_phone_e164: None,
            dob,
            last_seen: None,
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The builder type can then be equipped with helper methods that fill out the nascent item's fields. Each such method
consumes <code>self</code> but emits a new <a name="a007"></a><code>Self</code>, allowing different construction methods to be chained.</p>
<pre><code class="language-rust ignore">    /// Set the preferred name.
    fn preferred_name(mut self, preferred_name: &amp;str) -&gt; Self {
        self.0.preferred_name = Some(preferred_name.to_owned());
        self
    }</code></pre>
<p>These helper methods can be more helpful than just simple setters:</p>
<pre><code class="language-rust ignore">    /// Update the `last_seen` field to the current date/time.
    fn just_seen(mut self) -&gt; Self {
        self.0.last_seen = Some(chrono::Utc::now());
        self
    }</code></pre>
<p>The final method to be invoked for the builder consumes the builder and emits the built item.</p>
<pre><code class="language-rust ignore">    /// Consume the builder object and return a fully built [`Details`] object.
    fn build(self) -&gt; Details {
        self.0
    }</code></pre>
<p>Overall, this allows clients of the builder to have a more ergonomic building experience:</p>
<pre><code class="language-rust ignore">    let also_bob =
        DetailsBuilder::new(&quot;Robert&quot;, &quot;Builder&quot;, chrono::Utc.ymd(1998, 11, 28))
            .middle_name(&quot;the&quot;)
            .preferred_name(&quot;Bob&quot;)
            .just_seen()
            .build();</code></pre>
<p>The all-consuming nature of this style of builder leads to a couple of wrinkles.  The first is that separating out
stages of the build process can't be done on its own:</p>
<pre><code class="language-rust ignore does_not_compile">        let builder = DetailsBuilder::new(
            &quot;Robert&quot;,
            &quot;Builder&quot;,
            chrono::Utc.ymd(1998, 11, 28),
        );
        if informal {
            builder.preferred_name(&quot;Bob&quot;);
        }
        let bob = builder.build();</code></pre>
<pre><code class="language-text">error[E0382]: use of moved value: `builder`
   --&gt; builders/src/main.rs:249:19
    |
241 |         let builder = DetailsBuilder::new(
    |             ------- move occurs because `builder` has type `DetailsBuilder`, which does not implement the `Copy` trait
...
247 |             builder.preferred_name(&quot;Bob&quot;);
    |                     --------------------- `builder` moved due to this method call
248 |         }
249 |         let bob = builder.build();
    |                   ^^^^^^^ value used here after move
    |
note: this function takes ownership of the receiver `self`, which moves `builder`
   --&gt; builders/src/main.rs:49:27
    |
49  |     fn preferred_name(mut self, preferred_name: &amp;str) -&gt; Self {
    |                           ^^^^
</code></pre>
<p>This can be worked around by assigning the consumed builder back to the same variable:</p>
<pre><code class="language-rust ignore">    let mut builder =
        DetailsBuilder::new(&quot;Robert&quot;, &quot;Builder&quot;, chrono::Utc.ymd(1998, 11, 28));
    if informal {
        builder = builder.preferred_name(&quot;Bob&quot;);
    }
    let bob = builder.build();</code></pre>
<p>The other downside to the all-consuming nature of this builder is that only one item can be built; trying to
repeatedly <code>build()</code> copies:</p>
<pre><code class="language-rust ignore does_not_compile">        let smithy =
            DetailsBuilder::new(&quot;Agent&quot;, &quot;Smith&quot;, chrono::Utc.ymd(1999, 6, 11));
        let clones = vec![smithy.build(), smithy.build(), smithy.build()];</code></pre>
<p>falls foul of the <a name="a008"></a>borrow checker, as you'd expect:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `smithy`
   --&gt; builders/src/main.rs:269:43
    |
267 |         let smithy =
    |             ------ move occurs because `smithy` has type `DetailsBuilder`, which does not implement the `Copy` trait
268 |             DetailsBuilder::new(&quot;Agent&quot;, &quot;Smith&quot;, chrono::Utc.ymd(1999, 6, 11));
269 |         let clones = vec![smithy.build(), smithy.build(), smithy.build()];
    |                                  -------  ^^^^^^ value used here after move
    |                                  |
    |                                  `smithy` moved due to this method call
</code></pre>
<p>An alternative approach is for the builder's methods to take a <code>&amp;mut self</code> and emit a <code>&amp;mut Self</code>:</p>
<pre><code class="language-rust ignore">    /// Update the `last_seen` field to the current date/time.
    fn just_seen(&amp;mut self) -&gt; &amp;mut Self {
        self.0.last_seen = Some(chrono::Utc::now());
        self
    }</code></pre>
<p>This removes the need for self-assignment in separate build stages:</p>
<pre><code class="language-rust ignore">    let mut builder = DetailsRefBuilder::new(
        &quot;Robert&quot;,
        &quot;Builder&quot;,
        chrono::Utc.ymd(1998, 11, 28),
    );
    if informal {
        builder.preferred_name(&quot;Bob&quot;); // no `builder = ...`
    }
    let bob = builder.build();</code></pre>
<p>However, this version makes it impossible to chain the construction of the builder together with invocation of its
setter methods:</p>
<pre><code class="language-rust ignore does_not_compile">        let builder = DetailsRefBuilder::new(
            &quot;Robert&quot;,
            &quot;Builder&quot;,
            chrono::Utc.ymd(1998, 11, 28),
        )
        .middle_name(&quot;the&quot;)
        .just_seen();
        let bob = builder.build();</code></pre>
<pre><code class="language-text">error[E0716]: temporary value dropped while borrowed
   --&gt; builders/src/main.rs:289:23
    |
289 |           let builder = DetailsRefBuilder::new(
    |  _______________________^
290 | |             &quot;Robert&quot;,
291 | |             &quot;Builder&quot;,
292 | |             chrono::Utc.ymd(1998, 11, 28),
293 | |         )
    | |_________^ creates a temporary which is freed while still in use
294 |           .middle_name(&quot;the&quot;)
295 |           .just_seen();
    |                       - temporary value is freed at the end of this statement
296 |           let bob = builder.build();
    |                     --------------- borrow later used here
    |
    = note: consider using a `let` binding to create a longer lived value
</code></pre>
<p>As indicated by the compiler error, this can be worked around by <code>let</code>ting  the builder item have a name:</p>
<pre><code class="language-rust ignore">    let mut builder = DetailsRefBuilder::new(
        &quot;Robert&quot;,
        &quot;Builder&quot;,
        chrono::Utc.ymd(1998, 11, 28),
    );
    builder.middle_name(&quot;the&quot;).just_seen();
    if informal {
        builder.preferred_name(&quot;Bob&quot;);
    }
    let bob = builder.build();</code></pre>
<p>This mutating builder variant also allows for building multiple items.  The signature of the <code>build()</code> method has to
<em>not</em> consume self, and so must be:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Construct a fully built [`Details`] object.
    fn build(&amp;self) -&gt; Details {
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>The implementation of this repeatable <code>build()</code> method then has to construct a fresh item on each invocation. If the
underlying item implements <a name="a009"></a><code>Clone</code>, this is easy â€“ the builder can hold a template and <code>clone()</code> it for each
build.  If the underlying item <em>doesn't</em> implement <code>Clone</code>, then the builder needs to have enough state to be able to
manually construct an instance of the underlying item on each call to <code>build()</code>.</p>
<p>With any style of builder pattern, the boilerplate code is now confined to one place â€“ the builder â€“ rather
than being needed at every place that uses the underlying type.</p>
<p>The boilerplate that remains can potentially be reduced still further by use of a <a name="a010"></a>macro (<a href="macros.html">Item 28</a>), but if you go down
this road you should also check whether there's an existing crate (such as the
<a name="a011"></a><a href="https://docs.rs/derive_builder/"><code>derive_builder</code></a> crate in particular) that provides what's needed â€“ assuming
that you're happy to take a dependency on it (<a href="dep-graph.html">Item 25</a>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-9-familiarize-yourself-with-reference-and-pointer-types"><a class="header" href="#item-9-familiarize-yourself-with-reference-and-pointer-types">Item 9: Familiarize yourself with reference and pointer types</a></h1>
<p>For programming in general, a <em>reference</em> is a way to indirectly access some data structure, separately from whatever
variable owns that data structure.  In practice, this is usually implemented as a <em><a name="a001"></a>pointer</em>: a number whose value
is the address in memory of the data structure.</p>
<p>A modern CPU will typically police a few constraints on pointers â€“ the memory address should be in a valid range
of memory (whether virtual or physical), and may need to be <a name="a002"></a><em>aligned</em> (e.g. a 4-byte integer value might
only be accessible if its address is a multiple of 4).</p>
<p>However, higher level programming languages usually encode more information about pointers in their type systems.  In
C-derived languages, including Rust, pointers have a type that indicates what kind of data structure is expected to be
present at the pointed-to memory address.  This allows the code to interpret the contents of memory at that address, and
in the memory following that address.</p>
<p>This basic level of pointer information â€“ putative memory location and expected data structure layout â€“ is
represented in Rust as a <em><a name="a003"></a>raw pointer</em>.  However, &quot;normal&quot; Rust code does not use raw pointers, because Rust
provides richer reference and pointer types that provide additional safety guarantees and constraints.  These reference
and pointer types are the subject of this Item; raw pointers are relegated to <a href="unsafe.html">Item 16</a> (which discusses <code>unsafe</code> code).</p>
<h2 id="rust-references"><a class="header" href="#rust-references">Rust References</a></h2>
<p>The most ubiquitous pointer-like type in Rust is the <em><a name="a004"></a>reference</em>, whose type is written as <code>&amp;T</code> for some type
<code>T</code>. Although this is a pointer value under the covers, the compiler ensures that various rules around its use are
observed: it must always point to a valid, correctly-aligned instance of the relevant type <code>T</code>, whose lifetime (<a href="lifetimes.html">Item 14</a>) extends beyond its use, and which satisfies the <a name="a005"></a>borrow checking rules (<a href="borrows.html">Item 15</a>).  These
additional constraints are always implied by the term &quot;reference&quot; in Rust, and so the bare term &quot;pointer&quot; is generally
rare.</p>
<p>The constraints that a Rust reference must point to a valid, correctly-aligned item are shared by <a name="a006"></a>C++'s reference
types. However, C++ has no concept of lifetimes and so allows footguns<sup><a name="to-footnote-1"><a href="references.html#footnote-1">1</a></a></sup> with dangling references:</p>
<pre><code class="language-c++ not_desired_behaviour">// C++
const int&amp; dangle() {
  int x = 32; // on the stack, overwritten later
  return x; // return reference to stack variable!
}
</code></pre>
<p>Rust's borrowing and lifetime checks make the equivalent code broken at compile time:</p>
<pre><code class="language-rust ignore does_not_compile">fn dangle() -&gt; &amp;'static i64 {
    let x: i64 = 32; // on the stack
    &amp;x
}</code></pre>
<pre><code class="language-text">error[E0515]: cannot return reference to local variable `x`
   --&gt; references/src/main.rs:399:5
    |
399 |     &amp;x
    |     ^^ returns a reference to data owned by the current function
</code></pre>
<p>A Rust reference <code>&amp;T</code> allows read-only access to the underlying item (roughly equivalent to C++'s <code>const T&amp;</code>).  A
<a name="a007"></a>mutable reference that also allows the underlying item to be modified is written as <code>&amp;mut T</code>, and is also subject
to the borrow checking rules discussed in <a href="borrows.html">Item 15</a>.  This naming pattern reflects a slightly different mindset between
Rust and C++:</p>
<ul>
<li>In Rust, the default variant is read-only, and writable types are marked specially (with <code>mut</code>).</li>
<li>In C++, the default variant is writable, and read-only types are marked specially (with <code>const</code>).</li>
</ul>
<p>In the generated code, a Rust reference is a simple pointer, 8 bytes in size on a 64-bit platform (which this Item
assumes throughout):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct Point {
        x: u32,
        y: u32,
    }
    let pt = Point { x: 1, y: 2 };
    let x = 0u64;
    let ref_x = &amp;x;
    let ref_pt = &amp;pt;
<span class="boring">}</span></code></pre></pre>
<img alt="Stack layout with pointers to local variables" src="images/stack.svg" width=346>
<p>A Rust reference can refer to items that are located either on the <a name="a008"></a>stack or on the <a name="a009"></a>heap.
Rust allocates items on the stack by default, but the <a name="a010"></a><code>Box&lt;T&gt;</code> pointer type (roughly equivalent to C++'s
<a name="a011"></a><code>std::unique_ptr&lt;T&gt;</code>) forces allocation to occur on the heap, which in turn means that
the allocated item can outlive the scope of the current block.  Under the covers, <code>Box&lt;T&gt;</code> is also a simple 8 byte
pointer value.</p>
<pre><code class="language-rust ignore">    let box_pt = Box::new(Point { x: 10, y: 20 });</code></pre>
<img alt="Stack Box pointer to struct on heap" src="images/heap.svg" width=591>
<h2 id="pointer-traits"><a class="header" href="#pointer-traits">Pointer Traits</a></h2>
<p>A method that expects a reference argument like <code>&amp;Point</code> can also be fed a <code>&amp;Box&lt;Point&gt;</code>:</p>
<pre><code class="language-rust ignore">    fn show(pt: &amp;Point) {
        println!(&quot;({}, {})&quot;, pt.x, pt.y);
    }
    show(ref_pt);
    show(&amp;box_pt);</code></pre>
<pre><code class="language-text">(1, 2)
(10, 20)
</code></pre>
<p>This is possible because <code>Box&lt;T&gt;</code> implements the <a name="a012"></a><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a>
trait, with <code>Target = T</code>.  An implementation of this trait for some type means that the trait's
<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#tymethod.deref"><code>deref()</code></a> method can be used to create a reference
to the <code>Target</code> type.  There's also an equivalent
<a name="a013"></a><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a> trait, which emits a <em>mutable</em> reference to
the <code>Target</code> type.</p>
<p>The <code>Deref</code> / <code>DerefMut</code> traits are somewhat special, because the Rust compiler has specific behaviour when dealing with
types that implement them.  When the compiler encounters a dereferencing expression
(e.g. <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-dereference-operator"><code>*x</code></a>), it looks for
and uses an implementation of one of these traits, depending on whether the dereference requires mutable access or not.
This <em><code>Deref</code> <a name="a014"></a>coercion</em> allows various smart pointer types to behave like normal references, and is one of the few
mechanisms that allow implicit type conversion in Rust (as described in <a href="casts.html">Item 6</a>).</p>
<p>As a technical aside, it's worth understanding why the <code>Deref</code> traits can't be generic (<code>Deref&lt;Target&gt;</code>) for the
destination type.  If they were, then it would be possible for some type <code>ConfusedPtr</code> to implement both <code>Deref&lt;TypeA&gt;</code>
and <code>Deref&lt;TypeB&gt;</code>, and that would leave the compiler unable to deduce a single unique type for an expression like <code>*x</code>.
So instead the destination type is encoded as the <a name="a015"></a>associated type named <code>Target</code>.</p>
<p>This technical aside provides a contrast to two other standard pointer traits, the
<a name="a016"></a><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a> and
<a name="a017"></a><a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html"><code>AsMut</code></a> traits.  These traits don't induce special
behaviour in the compiler, but also allow conversions to a reference or mutable reference via an explicit call to their
trait functions ( <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html#tymethod.as_ref"><code>as_ref()</code></a> and
<a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html#tymethod.as_mut"><code>as_mut()</code></a> respectively).  The destination
type for these conversions <em>is</em> encoded as a type parameter (e.g. <code>AsRef&lt;Point&gt;</code>), which means that a single container
type can support multiple destinations.</p>
<p>For example, the standard <a name="a018"></a><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> type implements the
<code>Deref</code> trait with <code>Target = str</code>, meaning that an expression like <code>&amp;my_string</code> can be coerced to type <code>&amp;str</code>.  But it
also implements:</p>
<ul>
<li><code>AsRef&lt;[u8]&gt;</code>, allowing conversion to a byte slice <code>&amp;[u8]</code>.</li>
<li><code>AsRef&lt;OsStr&gt;</code>, allowing conversion to an OS string.</li>
<li><code>AsRef&lt;Path&gt;</code>, allowing conversion to a filesystem path.</li>
<li><code>AsRef&lt;str&gt;</code>, allowing conversion to a string slice <code>&amp;str</code> (as with <code>Deref</code>).</li>
</ul>
<p>We saw above that a function that takes a reference can automatically take any type that implements <code>Deref</code>, via the
<code>Deref</code> coercion that the compiler performs.  Such a function can be made even more general, by making it <a name="a019"></a><em>generic</em> over one of the <code>AsRef</code> / <code>AsMut</code> traits, and changing it to use <code>.as_ref()</code> on the input. This
means it accepts the widest range of reference-like types:</p>
<pre><code class="language-rust ignore">    fn show_as_ref&lt;T: AsRef&lt;Point&gt;&gt;(pt: T) {
        let pt: &amp;Point = pt.as_ref();
        println!(&quot;({}, {})&quot;, pt.x, pt.y);
    }</code></pre>
<h2 id="fat-pointer-types"><a class="header" href="#fat-pointer-types">Fat Pointer Types</a></h2>
<p>Rust has two built-in <em><a name="a020"></a>fat pointer</em> types: types that act as pointers, but which hold additional information about
the thing they are pointing to.</p>
<p>The first such type is the <em><a name="a021"></a>slice</em>: a reference to a subset of some contiguous collection of values.  It's built
from a (non-owning) simple pointer, together with a length field, making it twice the size of a simple pointer (16 bytes
on a 64-bit platform).  The type of a slice is written as <code>&amp;[T]</code> â€“ a reference to <code>[T]</code>, which is the notional
type for a contiguous collection of values of type <code>T</code>.</p>
<p>The notional type <code>[T]</code> can't be instantiated, but there are two common containers that embody it.  The first is the
<em><a name="a022"></a>array</em>: a contiguous collection of values whose size is known at compile time.  A slice can therefore refer to a
subset of an array:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let array = [0u64; 5];
    let slice = &amp;array[1..3];
<span class="boring">}</span></code></pre></pre>
<img alt="Stack slice pointing into stack array" src="images/arrayslice.svg" width=348>
<p>The other common container for contiguous values is a <a name="a023"></a><code>Vec&lt;T&gt;</code>.  This holds a contiguous collection of
values whose size can vary, and whose contents are held on the <a name="a024"></a>heap.  A slice can therefore refer to a subset of a
vector:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut vec = Vec::&lt;u64&gt;::with_capacity(8);
    for i in 0..5 {
        vec.push(i);
    }
    let slice = &amp;vec[1..3];
<span class="boring">}</span></code></pre></pre>
<img alt="Stack slice pointing into vector contents on heap" src="images/vecslice.svg" width=591>
<p>There's quite a lot going on under the covers for the expression <code>&amp;vec[1..3]</code>, so it's worth breaking down into its
components:</p>
<ul>
<li>The <code>1..3</code> part is a <a name="a025"></a><a href="https://doc.rust-lang.org/reference/expressions/range-expr.html">range expression</a>; the
compiler converts this into an instance of the
<a name="a026"></a><a href="https://doc.rust-lang.org/std/ops/struct.Range.html"><code>Range&lt;usize&gt;</code></a> type, which holds an inclusive
lower bound and an exclusive upper bound.</li>
<li>The <code>Range</code> type <a href="https://doc.rust-lang.org/std/ops/struct.Range.html#impl-SliceIndex%3C%5BT%5D%3E">implements</a> the
<a name="a027"></a><a href="https://doc.rust-lang.org/std/slice/trait.SliceIndex.html"><code>SliceIndex&lt;T&gt;</code></a> trait, which describes
indexing operations on slices of an arbitrary type <code>T</code> (so the <code>Output</code> type is <code>[T]</code>).</li>
<li>The <code>vec[ ]</code> part is an <a href="https://doc.rust-lang.org/reference/expressions/array-expr.html#array-and-slice-indexing-expressions">indexing
expression</a>; the
compiler converts this into an invocation of the <a name="a028"></a><a href="https://doc.rust-lang.org/std/ops/trait.Index.html"><code>Index</code></a>
trait's <a href="https://doc.rust-lang.org/std/ops/trait.Index.html#tymethod.index"><code>index</code></a> method on <code>vec</code>, together with a
dereference (i.e. <code>*vec.index( )</code>).
<ul>
<li>The equivalent trait for mutable expressions is
<a name="a029"></a><a href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html"><code>IndexMut</code></a>.</li>
</ul>
</li>
<li><code>vec[1..3]</code> therefore invokes <code>Vec&lt;T&gt;</code>'s
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-Index%3CI%3E">implementation</a> of <code>Index&lt;I&gt;</code>, which requires
<code>I</code> to be an instance of <code>SliceIndex&lt;[u64]&gt;</code>.  This works because <code>Range&lt;usize&gt;</code> implements <code>SliceIndex&lt;[T]&gt;</code> for any
<code>T</code>, including <code>u64</code>.</li>
<li><code>&amp;vec[1..3]</code> un-does the dereference, resulting in a final expression type of <code>&amp;[u64]</code>.</li>
</ul>
<p>The second built-in fat pointer type is a <em><a name="a030"></a>trait object</em>: a reference to some item that implements a particular
trait.  It's built from a simple pointer to the item, together with an internal pointer to the type's <em><a name="a031"></a>vtable</em>,
giving a size of 16 bytes (on a 64-bit platform).  The <a href="https://en.wikipedia.org/wiki/Virtual_method_table">vtable</a> for
a type's implementation of a trait holds function pointers for each of the method implementations, allowing dynamic
dispatch at runtime (<a href="generics.html">Item 12</a>)<sup><a name="to-footnote-2"><a href="references.html#footnote-2">2</a></a></sup>.</p>
<p>So a simple trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    trait Calculate {
        fn add(&amp;self, l: u64, r: u64) -&gt; u64;
        fn mul(&amp;self, l: u64, r: u64) -&gt; u64;
    }
<span class="boring">}</span></code></pre></pre>
<p>with a <code>struct</code> that implements it:</p>
<pre><code class="language-rust ignore">    struct Modulo(pub u64);

    impl Calculate for Modulo {
        fn add(&amp;self, l: u64, r: u64) -&gt; u64 {
            (l + r) % self.0
        }
        fn mul(&amp;self, l: u64, r: u64) -&gt; u64 {
            (l * r) % self.0
        }
    }

    let mod3 = Modulo(3);
</code></pre>
<p>can be converted to a trait object of type <code>&amp;dyn Trait</code> (where the <a href="https://doc.rust-lang.org/std/keyword.dyn.html"><code>dyn</code>
keyword</a> highlights the fact that dynamic dispatch is involved):</p>
<pre><code class="language-rust ignore">    // Need an explicit type to force dynamic dispatch.
    let tobj: &amp;dyn Calculate = &amp;mod3;
    let result = tobj.add(2, 2);
    assert_eq!(result, 1);</code></pre>
<img alt="Trait object with pointers to concrete object and vtable" src="images/traitobject.svg" width=844>
<!-- This picture doesn't show everything. In reality there are a few other things in the vtable: a pointer to the -->
<!-- `Drop` implementation for the type, size of type, alignment of type. -->
<p>Code that holds a trait object can invoke the methods of the trait via the function pointers in the vtable, passing in
the item pointer as the <code>&amp;self</code> parameter; see <a href="generics.html">Item 12</a> for more information and advice.</p>
<h2 id="more-pointer-traits"><a class="header" href="#more-pointer-traits">More Pointer Traits</a></h2>
<p>A previous section described two pairs of traits (<code>Deref</code> / <code>DerefMut</code>, <code>AsRef</code> / <code>AsMut</code>) that are used when dealing
with types that can be easily converted into references.  There are a few more standard traits that can also come into
play when working with pointer-like types, whether from the standard library or user defined.</p>
<p>The simplest of these is the <a name="a034"></a><a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html"><code>Pointer</code></a> trait, which
formats a pointer value for output. This can be helpful for low-level debugging, and the compiler will reach for this
trait automatically when it encounters the <code>{:p}</code> format specifier.</p>
<p>More intriguing are the <a name="a035"></a><a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow</code></a> and
<a name="a036"></a><a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html"><code>BorrowMut</code></a> traits, which each have a single method
(<a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html#tymethod.borrow"><code>borrow</code></a> and
<a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html#tymethod.borrow_mut"><code>borrow_mut</code></a> respectively). This method
has the same signature as the equivalent <code>AsRef</code> / <code>AsMut</code> trait methods.</p>
<p>The key difference in intents between these traits is visible via the <a name="a037"></a>blanket implementations that the standard
library provides.  Given an arbitrary Rust reference <code>&amp;T</code>, there is a blanket implementation of both <code>AsRef</code> and
<code>Borrow</code>; likewise, for a mutable reference <code>&amp;mut T</code>, there's a blanket implementation of both <code>AsMut</code> and <code>BorrowMut</code>.</p>
<p>However, <code>Borrow</code> also has a blanket implementation for (non-reference) types:</p>
<ul>
<li><code>impl&lt;T&gt; Borrow&lt;T&gt; for T</code></li>
</ul>
<p>This means that a method accepting the <code>Borrow</code> trait can cope equally with instances of <code>T</code> as well as references-to-<code>T</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn add_four&lt;T: std::borrow::Borrow&lt;i32&gt;&gt;(v: T) -&gt; i32 {
        v.borrow() + 4
    }
    assert_eq!(add_four(&amp;2), 6);
    assert_eq!(add_four(2), 6);
<span class="boring">}</span></code></pre></pre>
<p>The standard library's container types have more realistic uses of <code>Borrow</code>; for example,
<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.get"><code>HashMap::get</code></a> uses <code>Borrow</code> to allow
convenient retrieval of entries whether keyed by value or by reference.</p>
<p>The <a name="a038"></a><a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html"><code>ToOwned</code></a> trait builds on the <code>Borrow</code>
trait, adding a <a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned"><code>to_owned()</code></a> method that
produces a new owned item of the underlying type.  This is a generalization of the <code>Clone</code> trait: where <code>Clone</code>
specifically requires a Rust reference <code>&amp;T</code>, <code>ToOwned</code> instead copes with things that implement <code>Borrow</code>.</p>
<p>This means that:</p>
<ul>
<li>A function that operates on references to some type can accept <code>Borrow</code> so that it can also be called with moved items
as well as references.</li>
<li>A function that operates on owned items of some type can accept <code>ToOwned</code> so that it can also be called with
references to items as well as moved items; any references passed to it will be replicated into a locally owned item.</li>
</ul>
<p>Although it's not a pointer type, it's worth mentioning the
<a name="a039"></a><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow</code></a> type at this point, because it provides an alternative
way of dealing with the same kind of situation.  <code>Cow</code> is an <code>enum</code> that can hold either owned data, or a reference to
borrowed data. The peculiar name stands for &quot;clone-on-write&quot;: a <code>Cow</code> input can stay as borrowed data right up to the
point where it needs to be modified, but becomes an owned copy at the point where the data needs to be altered.</p>
<h2 id="smart-pointer-types"><a class="header" href="#smart-pointer-types">Smart Pointer Types</a></h2>
<p>The Rust standard library includes a variety of types that act like pointers to some degree or another, mediated by the
standard library traits described above.  These <em><a name="a040"></a>smart pointer</em> types each come with some particular semantics and
guarantees, which has the advantage that the right combination of them can give fine-grained control over the pointer's
behaviour, but has the disadvantage that the resulting types can seem overwhelming at first (<code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code>
anyone?).</p>
<p>The first smart pointer type is <a name="a041"></a><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a>, which is a
reference-counted pointer to an item (roughly analogous to C++'s <a name="a042"></a><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr&lt;T&gt;</code></a>).  It implements all of the
pointer-related traits, so acts like a <a name="a043"></a><code>Box&lt;T&gt;</code> in many ways.</p>
<p>This is useful for data structures where the same item can be reached in different ways, but it removes one of Rust's
core rules around ownership â€“ that each item has only one owner.  Relaxing this rule means that it is now
possible to leak data: if item A has an <code>Rc</code> pointer to item B, and item B has an <code>Rc</code> pointer to A, then the pair
will never be dropped. To put it another way: you need <code>Rc</code> to support cyclical data structures, but the downside is
that there are now cycles in your data structures.</p>
<p>The risk of leaks can be ameliorated in some cases by the related
<a name="a044"></a><a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak&lt;T&gt;</code></a> type, which holds a non-owning reference to
the underlying item (roughly analogous to C++'s <a name="a045"></a><a href="https://en.cppreference.com/w/cpp/memory/weak_ptr"><code>std::weak_ptr&lt;T&gt;</code></a>).  Holding a weak reference doesn't
prevent the underlying item being dropped (when all strong references are removed), so making use of the <code>Weak&lt;T&gt;</code>
involves an upgrade to an <code>Rc&lt;T&gt;</code> â€“ which can fail.</p>
<p>Under the hood, <code>Rc</code> is (currently) implemented as pair of reference counts together with the referenced items, all
stored on the <a name="a046"></a>heap.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::rc::Rc;
    let rc1: Rc&lt;u64&gt; = Rc::new(42);
    let rc2 = rc1.clone();
    let wk = Rc::downgrade(&amp;rc1);
<span class="boring">}</span></code></pre></pre>
<img alt="Rc and Weak pointers all referring to the same heap item" src="images/rc.svg" width=550>
<p>An <code>Rc</code> on its own gives you the ability to reach an item in different ways, but when you reach that item you can only
modify it (via <a name="a047"></a><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html#method.get_mut"><code>get_mut</code></a>) if there are no other
ways to reach the item â€“ i.e. there are no other extant <code>Rc</code> or <code>Weak</code> references to the same item.  That's hard
to arrange, so <code>Rc</code> is often combined with another smart pointer typeâ€¦</p>
<p>The next smart pointer type <a name="a048"></a><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a> relaxes the
rule (<a href="borrows.html">Item 15</a>) that an item can only be mutated by its owner or by code that holds the (only) mutable reference to the
item.  This <em><a name="a049"></a>interior mutability</em> allows for greater flexibility â€“ for example, allowing trait
implementations that mutate internals even when the method signature only allows <code>&amp;self</code>.  However, it also incurs
costs: as well as the extra storage overhead (an extra <code>isize</code> to track current borrows), the normal borrow checks are
moved from compile-time to run-time.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::cell::RefCell;
    let rc: RefCell&lt;u64&gt; = RefCell::new(42);
    let b1 = rc.borrow();
    let b2 = rc.borrow();
<span class="boring">}</span></code></pre></pre>
<img alt="Ref borrows referring to a RefCell container" src="images/refcell.svg" width=330>
<p>The run-time nature of these checks means that the <code>RefCell</code> user has to choose between two options, neither pleasant:</p>
<ul>
<li>Accept that borrowing is an operation that might fail, and cope with <code>Result</code> values from <code>try_borrow[_mut]</code></li>
<li>Use the allegedly-infallible borrowing methods <code>borrow[_mut]</code>, and accept the risk of a <code>panic!</code> at runtime (<a href="panic.html">Item 18</a>)
if the borrow rules have not been complied with.</li>
</ul>
<p>In either case, this run-time checking means that <code>RefCell</code> itself implements none of the standard pointer traits;
instead, its access operations return a <a name="a050"></a><a href="https://doc.rust-lang.org/std/cell/struct.Ref.html"><code>Ref&lt;T&gt;</code></a> or
<a name="a051"></a><a href="https://doc.rust-lang.org/std/cell/struct.RefMut.html"><code>RefMut&lt;T&gt;</code></a> smart pointer type that does implement those
traits.</p>
<p>If the underlying type <code>T</code> implements the <code>Copy</code> trait (indicating that a fast bit-for-bit copy
produces a valid item, see <a href="std-traits.html">Item 5</a>), then the <a name="a052"></a><code>Cell&lt;T&gt;</code> type allows interior mutation
with less overhead â€“ the <code>get(&amp;self)</code> method copies out the current value, and the <code>set(&amp;self, val)</code> method copies in a new value.  The <code>Cell</code> type is used internally by both the <code>Rc</code> and
<code>RefCell</code> implementations, for shared tracking of counters that can be mutated without a <code>&amp;mut self</code>.</p>
<p>The smart pointer types described so far are only suitable for single threaded use; their implementations assume that
there is no concurrent access to their internals.  If this is not the case, then different smart pointers are needed,
which include the additional synchronization overhead.</p>
<p>The thread-safe equivalent of <code>Rc&lt;T&gt;</code> is <a name="a053"></a><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>,
which uses atomic counters to ensure that the reference counts remain accurate. Like <code>Rc</code>, <code>Arc</code> implements all of the
various pointer-related traits.</p>
<p>However, <code>Arc</code> on its own does not allow any kind of mutable access to the underlying item. This is covered by the
<a name="a054"></a><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> type, which ensures that only one thread has
access â€“ whether mutably or immutably â€“ to the underlying item.  As with <code>RefCell</code>, <code>Mutex</code> itself does not
implement any pointer traits, but its <code>lock()</code> operation returns a value of a type that does:
<a name="a055"></a><a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a>, which implements <code>Deref[Mut]</code>.</p>
<p>If there are likely to be more readers than writers, the
<a name="a056"></a><a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a> type is preferable, as it allows multiple
readers access to the underlying item in parallel, provided that there isn't currently a (single) writer.</p>
<p>In either case, Rust's borrowing and threading rules force the use of one of these synchronization containers in
multi-threaded code (but this only guards against <em>some</em> of the problems of <a name="a057"></a>shared-state concurrency; see <a href="deadlock.html">Item 17</a>).</p>
<p>The same strategy â€“ see what the compiler rejects, and what it suggests instead â€“ can sometimes be
applied with the other smart pointer types; however, it's faster and less frustrating to understand what the behaviour
of the different smart pointers implies. To borrow<sup><a name="to-footnote-3"><a href="references.html#footnote-3">3</a></a></sup> <a href="https://doc.rust-lang.org/1.15.1/book/choosing-your-guarantees.html#composition">an example from the first edition of the
Rust book</a>,</p>
<ul>
<li><code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> holds a vector (<code>Vec</code>) with shared ownership (<code>Rc</code>), where the vector can be mutated â€“ but
only as a whole vector.</li>
<li><code>Rc&lt;Vec&lt;RefCell&lt;T&gt;&gt;&gt;</code> also holds a vector with shared ownership, but here each individual entry in the vector can be
mutated independently of the others.</li>
</ul>
<p>The types involved precisely describe these behaviours.</p>
<p><hr/>
<p><a name="footnote-1"><a href="references.html#to-footnote-1">1</a></a>: Albeit with a warning from modern
compilers.</p>
<p><a name="footnote-2"><a href="references.html#to-footnote-2">2</a></a>: This is somewhat simplified; a full vtable also includes information about the
size and <a name="a032"></a>alignment of the type, together with a <a name="a033"></a><code>drop()</code> function pointer so that the underlying
object can be safely dropped.</p>
<p><a name="footnote-3"><a href="references.html#to-footnote-3">3</a></a>: Pun intended</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-10-consider-using-iterator-transforms-instead-of-explicit-loops"><a class="header" href="#item-10-consider-using-iterator-transforms-instead-of-explicit-loops">Item 10: Consider using iterator transforms instead of explicit loops</a></h1>
<p>The humble loop has had a long journey of increasing convenience and increasing abstraction.  The
<a name="a001"></a><a href="https://web.archive.org/web/20150611114427/https://www.bell-labs.com/usr/dmr/www/kbman.pdf">B</a> language (the
precursor to <a name="a002"></a>C) only had <code>while (condition) { ... }</code>, but with the arrival of C the common scenario of iterating
through indexes of an array was made more convenient with the addition of the <a name="a003"></a><code>for</code> loop:</p>
<pre><code class="language-c">  // C code
  int i;
  for (i = 0; i &lt; len; i++) {
    Item item = collection[i];
    // body
  }
</code></pre>
<p>The early versions of <a name="a004"></a>C++ improved convenience and scoping further by allowing the loop variable declaration to be
embedded in the <code>for</code> statement (and this was also adopted by C in <a name="a005"></a>C99):</p>
<pre><code class="language-c++">  // C++98 code
  for (int i = 0; i &lt; len; i++) {
    Item item = collection[i];
    // ...
  }
</code></pre>
<p>Most modern languages abstract the idea of the loop further: the core function of a loop is often to move to the next
item of some container, and tracking the logistics that are required to reach that item (<code>index++</code> or <code>++it</code>) is mostly
an irrelevant detail.  This realization produced two core concepts:</p>
<ul>
<li><a name="a006"></a><strong>Iterators</strong>: a type whose purpose is to repeatedly emit the next item of a container<sup><a name="to-footnote-1"><a href="iterators.html#footnote-1">1</a></a></sup>, until exhausted.</li>
<li><a name="a007"></a><strong>For-Each Loops</strong>: a compact loop expression for iterating over all of the items in a container, binding a loop
variable to the <em>item</em> rather than to the details of reaching that item.</li>
</ul>
<p>These concepts allow for loop code that's shorter, and (more importantly) clearer about what's intended:</p>
<pre><code class="language-c++">  // C++11 code
  for (Item&amp; item : collection) {
    // ...
  }
</code></pre>
<p>Once these concepts were available, they were so obviously powerful that they were quickly retrofitted to those
languages that didn't already have them (e.g. for-each loops were added to <a href="https://docs.oracle.com/javase/1.5.0/docs/guide/language/foreach.html"><a name="a008"></a>Java
1.5</a> and <a name="a009"></a>C++11).</p>
<p>Rust includes iterators and for-each style loops, but it also includes the next step in abstraction: allowing the whole
loop to be expressed as an <em><a name="a010"></a>iterator transform</em>.  As with <a href="transform.html">Item 3</a>'s discussion of <code>Option</code> and <code>Result</code>, this
Item will attempt to show how these iterator transforms can be used instead of explicit loops, and to give guidance as
to when it's a good idea.</p>
<p>By the end of this Item, a C-like explicit loop to sum the squares of the first five even items of a vector:</p>
<pre><code class="language-rust ignore">    let mut even_sum_squares = 0;
    let mut even_count = 0;
    for i in 0..values.len() {
        if values[i] % 2 != 0 {
            continue;
        }
        even_sum_squares += values[i] * values[i];
        even_count += 1;
        if even_count == 5 {
            break;
        }
    }</code></pre>
<p>should start to feel more natural expressed as a functional style expression:</p>
<pre><code class="language-rust ignore">    let even_sum_squares: u64 = values
        .iter()
        .filter(|x| *x % 2 == 0)
        .take(5)
        .map(|x| x * x)
        .sum();</code></pre>
<p>Iterator transformation expressions like this can roughly be broken down into three parts:</p>
<ul>
<li>An initial source iterator, from one of Rust's iterator traits.</li>
<li>A sequence of iterator transforms.</li>
<li>A final consumer method to combine the results of the iteration into a final value.</li>
</ul>
<p>The first two of these effectively move functionality out of the loop body and into the <code>for</code> expression; the last
removes the need for the <code>for</code> statement altogether.</p>
<h2 id="iterator-traits"><a class="header" href="#iterator-traits">Iterator Traits</a></h2>
<p>The core <a name="a011"></a><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a> trait has a very simple interface:
a single method <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#tymethod.next"><code>next</code></a> that yields <a name="a012"></a><code>Some</code>
items until it doesn't (<a name="a013"></a><code>None</code>).</p>
<p>Collections that allow iteration over their contents â€“ called <em><a name="a014"></a>iterables</em> â€“ implement the
<a name="a015"></a><a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> trait; the
<a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html#tymethod.into_iter"><code>into_iter</code></a> method of this trait
consumes <a name="a016"></a><code>Self</code> and emits an <code>Iterator</code> in its stead.  The compiler will automatically use this trait for
expressions of the form</p>
<pre><code class="language-rust ignore">    for item in collection {
        // body
    }</code></pre>
<p>effectively converting them to code roughly like:</p>
<pre><code class="language-rust ignore">    let mut iter = collection.into_iter();
    loop {
        let item: Thing = match iter.next() {
            Some(item) =&gt; item,
            None =&gt; break,
        };
        // body
    }</code></pre>
<p>or more succinctly and more idiomatically:</p>
<pre><code class="language-rust ignore">    let mut iter = collection.into_iter();
    while let Some(item) = iter.next() {
        // body
    }</code></pre>
<p>(To keep things running smoothly, there's also an implementation of <code>IntoIterator</code> for any <code>Iterator</code>, which just
returns <code>self</code>; after all, it's easy to convert an <code>Iterator</code> into an <code>Iterator</code>!)</p>
<p>This initial form is a consuming iterator, using up the collection as it's created:</p>
<pre><code class="language-rust ignore">    let collection = vec![Thing(0), Thing(1), Thing(2), Thing(3)];
    for item in collection {
        println!(&quot;Consumed item {:?}&quot;, item);
    }</code></pre>
<p>Any attempt to use the collection after it's been iterated over fails:</p>
<pre><code class="language-rust ignore">    println!(&quot;Collection = {:?}&quot;, collection);</code></pre>
<pre><code class="language-text">error[E0382]: borrow of moved value: `collection`
   --&gt; iterators/src/main.rs:156:35
    |
148 |     let collection = vec![Thing(0), Thing(1), Thing(2), Thing(3)];
    |         ---------- move occurs because `collection` has type `Vec&lt;Thing&gt;`, which does not implement the `Copy` trait
149 |     for item in collection {
    |                 ----------
    |                 |
    |                 `collection` moved due to this implicit call to `.into_iter()`
    |                 help: consider borrowing to avoid moving into the for loop: `&amp;collection`
...
156 |     println!(&quot;Collection = {:?}&quot;, collection);
    |                                   ^^^^^^^^^^ value borrowed here after move
    |
note: this function takes ownership of the receiver `self`, which moves `collection`
</code></pre>
<p>While simple to understand, this all-consuming behaviour is often undesired; some kind of <em>borrow</em> of the iterated items
is needed.</p>
<p>To ensure that behaviour is clear, the examples here use an <code>Item</code> type that is <em>not</em> <code>Copy</code> (<a href="std-traits.html">Item 5</a>), as that would
hide questions of ownership (<a href="borrows.html">Item 15</a>) â€“ the compiler would silently make copies everywhere.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Deliberately not `Copy`
    #[derive(Clone, Debug, Eq, PartialEq)]
    struct Thing(u64);

    let collection = vec![Thing(0), Thing(1), Thing(2), Thing(3)];
<span class="boring">}</span></code></pre></pre>
<p>If the collection being iterated over is prefixed with <code>&amp;</code>:</p>
<pre><code class="language-rust ignore">    for item in &amp;collection {
        println!(&quot;{}&quot;, item.0);
    }
    println!(&quot;collection still around {:?}&quot;, collection);</code></pre>
<p>then the Rust compiler will look for an implementation of
<a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> for the type <code>&amp;Collection</code>. Properly
designed collection types will provide such an implementation; this implementation will still consume <code>Self</code>, but now
<a name="a017"></a><code>Self</code> is <code>&amp;Collection</code> rather than <code>Collection</code>, and the associated <code>Item</code> type will be a reference <code>&amp;Thing</code>.</p>
<p>This leaves the collection intact after iteration, and the equivalent expanded code is:</p>
<pre><code class="language-rust ignore">    let mut iter = (&amp;collection).into_iter();
    while let Some(item) = iter.next() {
        println!(&quot;{}&quot;, item.0);
    }</code></pre>
<p>If it makes sense to provide iteration over mutable references<sup><a name="to-footnote-2"><a href="iterators.html#footnote-2">2</a></a></sup>, then a similar pattern applies for <code>for item in &amp;mut collection</code>: the compiler
looks for and uses an implementation of <code>IntoIterator</code> for <code>&amp;mut Collection</code>, with each <code>Item</code> being of type <code>&amp;mut Thing</code>.</p>
<p>By convention, standard containers also provide an <code>iter()</code> method that returns an iterator over references to the
underlying item, and equivalent an <code>iter_mut()</code> method if appropriate, with the same behaviour as just described. These
methods can be used in <code>for</code> loops, but have a more obvious benefit when used as the start of an iterator
transformation:</p>
<pre><code class="language-rust ignore">    let result: u64 = (&amp;collection).into_iter().map(|thing| thing.0).sum();</code></pre>
<p>becomes:</p>
<pre><code class="language-rust ignore">    let result: u64 = collection.iter().map(|thing| thing.0).sum();</code></pre>
<h2 id="iterator-transforms"><a class="header" href="#iterator-transforms">Iterator Transforms</a></h2>
<p>The <a name="a020"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> trait has a single required method
(<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next"><code>next</code></a>), but also provides default
implementations (<a href="default-impl.html">Item 13</a>) of a large number of other methods that perform transformations on an iterator.</p>
<p>Some of these tranformations affect the overall iteration process:</p>
<ul>
<li><a name="a021"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take"><code>take(n)</code></a> restricts an iterator to
emitting at most <code>n</code> items.</li>
<li><a name="a022"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.skip"><code>skip(n)</code></a> skips over the first <code>n</code> elements of
the iterator.</li>
<li><a name="a023"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.step_by"><code>step_by(n)</code></a> converts an iterator so it only
emits every n-th item.</li>
<li><a name="a024"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain"><code>chain(other)</code></a> glues together two iterators,
to build a combined iterator that moves through one then the other.</li>
<li><a name="a025"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cycle"><code>cycle()</code></a> converts an iterator that terminates
into one that repeats forever, starting at the beginning again whenever it reaches the end.  (The iterator must
support <code>Clone</code> to allow this.)</li>
<li><a name="a026"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.rev"><code>rev()</code></a> reverses the direction of an
iterator. (The iterator must implement the
<a name="a027"></a><a href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> trait, which has an
additional <a href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html#tymethod.next_back"><code>next_back</code></a>
required method.)</li>
</ul>
<p>Other transformations affect the nature of the <code>Item</code> that's the subject of the <code>Iterator</code>:</p>
<ul>
<li><a name="a028"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map"><code>map(|item| {...})</code></a> is the most general
version, repeatedly applying a closure to transform each item in turn. Several of the following entries in this list
are convenience variants that could be equivalently implemented as a <code>map</code>.</li>
<li><a name="a029"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cloned"><code>cloned()</code></a> produces a clone of all of the
items in the original iterator; this is particularly useful with iterators over <code>&amp;Item</code> references. (This obviously
requires the underlying <code>Item</code> type to implement <code>Clone</code>).</li>
<li><a name="a030"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cloned"><code>copied()</code></a> produces a copy of all of the
items in the original iterator; this is particularly useful with iterators over <code>&amp;Item</code> references. (This obviously
requires the underlying <code>Item</code> type to implement <code>Copy</code>).</li>
<li><a name="a031"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.enumerate"><code>enumerate()</code></a> converts an iterator over
items to be an iterator over <code>(usize, Item)</code> pairs, providing an index to the items in the iterator.</li>
<li><a name="a032"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.zip"><code>zip(it)</code></a> joins an iterator with a second
iterator, to produce a combined iterator that emits pairs of items, one from each of the original iterators, until the
shorter of the two iterators is finished.</li>
</ul>
<p>Yet other transformations perform filtering on the <code>Item</code>s being emitted by the <code>Iterator</code>:</p>
<ul>
<li><a name="a033"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter"><code>filter(|item| {...})</code></a> is the
most general version, applying a <code>bool</code>-returning closure to each item reference to determine whether it should be
passed through.</li>
<li><a name="a034"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take_while"><code>take_while()</code></a> and
<a name="a035"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.skip_while"><code>skip_while()</code></a> are
mirror images of each other, emitting either an initial subrange or a final subrange of the iterator, based on a
predicate.</li>
</ul>
<p>The <a name="a036"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flatten"><code>flatten()</code></a> method deals
with an iterator whose items are themselves iterators, flattening the result.  On its own, this doesn't seem that
helpful, but it becomes much more useful when combined with the observation that both
<a name="a037"></a><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.iter"><code>Option</code></a> and
<a name="a038"></a><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.iter"><code>Result</code></a> act as iterators: they produce either zero
(for <code>None</code>, <code>Err(e)</code>) or one (for <code>Some(v)</code>, <code>Ok(v)</code>) items.  This means that <code>flatten</code>ing a stream of <code>Option</code> /
<code>Result</code> values is a simple way to extract just the valid values, ignoring the rest.</p>
<p>Taken as a whole, these methods allow iterators to be transformed so that they produce exactly the sequence of elements
that are needed for most situations.</p>
<h2 id="iterator-consumers"><a class="header" href="#iterator-consumers">Iterator Consumers</a></h2>
<p>The previous two sections described how to obtain an iterator, and how to transmute it into exactly the right form for
precise iteration.  This precisely-targetted iteration could happen as an explicit for-each loop:</p>
<pre><code class="language-rust ignore">    let mut even_sum_squares = 0;
    for value in values.iter().filter(|x| *x % 2 == 0).take(5) {
        even_sum_squares += value * value;
    }</code></pre>
<p>However, the large collection of <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code> methods</a> includes
many that allow an iteration to be consumed in a single method call, removing the need for an explicit <code>for</code> loop.</p>
<p>The most general of these methods is <a name="a039"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.for_each"><code>for_each(|item| {...})</code></a>, which runs a closure for each item
produced by the <code>Iterator</code>. This can do <em>most</em> of the things that an explicit <code>for</code> loop could do (the exceptions are
described below), but its generality also makes it a little awkward to use â€“ the closure needs to use mutable
references to external state in order to emit anything:</p>
<pre><code class="language-rust ignore">    let mut even_sum_squares = 0;
    values
        .iter()
        .filter(|x| *x % 2 == 0)
        .take(5)
        .for_each(|value| {
            // closure needs a mutable reference to state elsewhere
            even_sum_squares += value * value;
        });</code></pre>
<p>However, if the body of the <a name="a040"></a><code>for</code> loop matches one of a number of common patterns, there are more specific
iterator-consuming methods that are clearer, shorter and more idiomatic.</p>
<p>These patterns include shortcuts for building a single value out of the collection:</p>
<ul>
<li><a name="a041"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.sum"><code>sum()</code></a>, for summing a collection of
numeric values (integers or floats).</li>
<li><a name="a042"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.product"><code>product()</code></a>, for multiplying
together a collection of numeric values.</li>
<li><a name="a043"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.min"><code>min()</code></a> and
<a name="a044"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.max"><code>max()</code></a>, for finding the extreme
values of a collection, relative to the <code>Item</code>'s <a name="a045"></a><code>Ord</code> implementation (see <a href="std-traits.html">Item 5</a>).</li>
<li><a name="a046"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.min_by"><code>min_by(f)</code></a> and
<a name="a047"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.max_by"><code>max_by(f)</code></a>, for finding the
extreme values of a collection, relative to a user-specified comparison function <code>f</code>.</li>
<li><a name="a048"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.reduce"><code>reduce(f)</code></a> is a more general
operation that encompasses the previous methods, building an accumulated value of the <code>Item</code> type by running a closure
at each step that takes the value accumulated so far and the current item.</li>
<li><a name="a049"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.fold"><code>fold(f)</code></a> is a generalization of
<code>reduce</code>, allowing the &quot;accumulated value&quot; to be of an arbitrary type (not just the <code>Iterator::Item</code> type).</li>
<li><a name="a050"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.scan"><code>scan(f)</code></a> generalizes in a slightly
different way, giving the closure a mutable reference to some internal state at each step.</li>
</ul>
<p>There are also methods for <em>selecting</em> a single value out of the collection:</p>
<ul>
<li><a name="a051"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find"><code>find(p)</code></a> finds the first item that
satisfies a predicate.</li>
<li><a name="a052"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.position"><code>position(p)</code></a> also finds
the first item satisfying a predicate, but this time it returns the index of the item.</li>
<li><a name="a053"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.nth"><code>nth(n)</code></a> returns the <code>n</code>-th element
of the iterator, if available.</li>
</ul>
<p>There are methods for testing against every item in the collection:</p>
<ul>
<li><a name="a054"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any"><code>any(p)</code></a> indicates whether a
predicate is <code>true</code> for <em>any</em> item in the collection.</li>
<li><a name="a055"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any"><code>all(p)</code></a> indicates whether a
predicate is <code>true</code> for <em>all</em> items in the collection.</li>
</ul>
<p>(In either case, iteration will terminate early if the relevant counter-example is found.)</p>
<p>There are methods that allow for the possibility of failure in the closures used with each item; in each case, if a
closure returns a failure for an item, the iteration is terminated and the operation as a whole returns the first
failure.</p>
<ul>
<li><a name="a056"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_for_each"><code>try_for_each(f)</code></a>
is like <code>for_each</code>, but the closure can fail.</li>
<li><a name="a057"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_for_each"><code>try_fold(f)</code></a> is like
<code>fold</code>, but the closure can fail.</li>
<li><a name="a058"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_find"><code>try_find(f)</code></a> is like
<code>find</code>, but the closure can fail.</li>
</ul>
<p>Finally, there are methods that accumulate all of the iterated items into a new collection.  The most important of these
is <a name="a059"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect"><code>collect()</code></a>, which can be
used to build a new instance of any collection type that implements the
<a href="https://doc.rust-lang.org/core/iter/trait.FromIterator.html"><code>FromIterator</code></a> trait.</p>
<p>The <code>FromIterator</code> trait is implemented for all of the standard library collection types
(<a name="a060"></a><a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html#impl-FromIterator%3CT%3E"><code>Vec</code></a>,
<a name="a061"></a><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#impl-FromIterator%3C(K%2C%20V)%3E"><code>HashMap</code></a>,
<a name="a062"></a><a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html#impl-FromIterator%3CT%3E"><code>BTreeSet</code></a> etc.) but
this ubiquity also means that you often have to use explicit types, because otherwise the
compiler can't figure out whether you're trying to assemble (say) a <code>Vec&lt;i32&gt;</code> or <code>HashSet&lt;i32&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::collections::HashSet;

    // Build collections of even numbers.  Type must be specified, because
    // the expression is the same for either type.
    let myvec: Vec&lt;i32&gt; = (0..10).into_iter().filter(|x| x % 2 == 0).collect();
    let h: HashSet&lt;i32&gt; = (0..10).into_iter().filter(|x| x % 2 == 0).collect();
<span class="boring">}</span></code></pre></pre>
<p>(As an aside, this example also illustrates the use of <a name="a063"></a><a href="https://doc.rust-lang.org/reference/expressions/range-expr.html">range
expressions</a> to generate the initial data to be
iterated over.)</p>
<p>Other (more obscure) collection-producing methods include:</p>
<ul>
<li><a name="a064"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.unzip"><code>unzip()</code></a>, which divides an
iterator of pairs into two collections.</li>
<li><a name="a065"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.partition"><code>partition(p)</code></a>, which
splits an iterator into two collections based on a predicate that is applied to each item.</li>
</ul>
<p>This Item has touched on a wide selection of <code>Iterator</code> methods, but this is only a subset of the methods available;
for more information, consult the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">iterator documentation</a> or
read Chapter 15 of <a name="a066"></a><em>Programming Rust</em> (2nd edition), which has extensive coverage of the possibilities.</p>
<p>This rich collection of iterator transformations is meant to be used â€“ to produce code that is more idiomatic,
more compact, and with clearer intent.</p>
<h2 id="building-collections-from-result-values"><a class="header" href="#building-collections-from-result-values">Building Collections From <code>Result</code> Values</a></h2>
<p>The previous section described the use of <code>collect()</code> to build collections from iterators, but <code>collect()</code> also has  a
particularly helpful feature when dealing with <a name="a067"></a><code>Result</code> values.</p>
<p>Consider an attempt to convert a vector of <code>i64</code> values into bytes (<code>u8</code>), with the optimistic expectation that they
will all fit:</p>
<pre><code class="language-rust ignore panics">    use std::convert::TryFrom;
    let inputs: Vec&lt;i64&gt; = vec![0, 1, 2, 3, 4];
    let result: Vec&lt;u8&gt; = inputs
        .into_iter()
        .map(|v| &lt;u8&gt;::try_from(v).unwrap())
        .collect();</code></pre>
<p>This works until some unexpected input comes along:</p>
<pre><code class="language-rust ignore">    let inputs: Vec&lt;i64&gt; = vec![0, 1, 2, 3, 4, 512];</code></pre>
<p>and causes a run-time failure:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: TryFromIntError(())', iterators/src/main.rs:249:36
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Following the advice of <a href="transform.html">Item 3</a>, we want to keep the <code>Result</code> type in play, and use the <strong><code>?</code></strong> operator to make any
failure the problem of the calling code.  The obvious modification to emit the <code>Result</code> doesn't really help:</p>
<pre><code class="language-rust ignore">    let result: Vec&lt;Result&lt;u8, _&gt;&gt; =
        inputs.into_iter().map(|v| &lt;u8&gt;::try_from(v)).collect();
    // Now what?  Still need to iterate to extract results and detect errors.</code></pre>
<p>However, there's an alternative version of <code>collect()</code>, which can assemble a <code>Result</code> holding a <code>Vec</code>, instead of a
<code>Vec</code> holding <code>Result</code>s.</p>
<p>Forcing use of this version requires the turbofish (<code>::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;</code>):</p>
<pre><code class="language-rust ignore">    let result: Vec&lt;u8&gt; = inputs
        .into_iter()
        .map(|v| &lt;u8&gt;::try_from(v))
        .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;</code></pre>
<p>Combining this with the question mark operator gives useful behaviour:</p>
<ul>
<li>If the iteration encounters an error value, that error value is emitted to the caller and iteration stops.</li>
<li>If no errors are encountered, the remainder of the code can deal with a sensible collection of values of the right type.</li>
</ul>
<h2 id="loop-transformation"><a class="header" href="#loop-transformation">Loop Transformation</a></h2>
<p>The aim of this Item is to convince you that many explicit loops can be regarded as something to be converted to
iterator transformations.  This can feel somewhat unnatural for programmers who aren't used to it, so let's walk through
a transformation step by step.</p>
<p>Starting with a very C-like explicit loop to sum the squares of the first five even items of a vector:</p>
<pre><code class="language-rust ignore">    let mut even_sum_squares = 0;
    let mut even_count = 0;
    for i in 0..values.len() {
        if values[i] % 2 != 0 {
            continue;
        }
        even_sum_squares += values[i] * values[i];
        even_count += 1;
        if even_count == 5 {
            break;
        }
    }</code></pre>
<p>The first step is to replace vector indexing with direct use of an iterator in a for-each loop:</p>
<pre><code class="language-rust ignore">    let mut even_sum_squares = 0;
    let mut even_count = 0;
    for value in values.iter() {
        if value % 2 != 0 {
            continue;
        }
        even_sum_squares += value * value;
        even_count += 1;
        if even_count == 5 {
            break;
        }
    }</code></pre>
<p>An initial arm of the loop that uses <code>continue</code> to skip over some items is naturally expressed as a <code>filter()</code>:</p>
<pre><code class="language-rust ignore">    let mut even_sum_squares = 0;
    let mut even_count = 0;
    for value in values.iter().filter(|x| *x % 2 == 0) {
        even_sum_squares += value * value;
        even_count += 1;
        if even_count == 5 {
            break;
        }
    }</code></pre>
<p>Next, the early exit from the loop once 5 even items have been spotted maps to a <code>take(5)</code>:</p>
<pre><code class="language-rust ignore">    let mut even_sum_squares = 0;
    for value in values.iter().filter(|x| *x % 2 == 0).take(5) {
        even_sum_squares += value * value;
    }</code></pre>
<p>The value of the item is never used directly, only in the <code>value * value</code> combination, which makes it an ideal target
for a <code>map()</code>:</p>
<pre><code class="language-rust ignore">    let mut even_sum_squares = 0;
    for val_sqr in values.iter().filter(|x| *x % 2 == 0).take(5).map(|x| x * x)
    {
        even_sum_squares += val_sqr;
    }</code></pre>
<p>These refactorings of the original loop have resulting in a loop body that's the perfect nail to fit under the hammer of
the <code>sum()</code> method:</p>
<pre><code class="language-rust ignore">    let even_sum_squares: u64 = values
        .iter()
        .filter(|x| *x % 2 == 0)
        .take(5)
        .map(|x| x * x)
        .sum();</code></pre>
<h2 id="when-explicit-is-better"><a class="header" href="#when-explicit-is-better">When Explicit is Better</a></h2>
<p>This Item has highlighted the advantages of iterator transformations, particularly with respect to concision and
clarity.  So when are iterator transformations <em>not</em> appropriate or idiomatic?</p>
<ul>
<li>If the loop body is large and/or multi-functional, it makes sense to keep it as an explicit body rather than squeezing
it into a closure.</li>
<li>If the loop body involves error conditions that result in early termination of the surrounding function, these are
often best kept explicit â€“ the <code>try_..()</code> methods only help a little.  However, <code>collect()</code>'s ability to convert
a collection of <code>Result</code> values into a <code>Result</code> holding a collection of values often allows error conditions to still
be handled with the <strong><code>?</code></strong> operator.</li>
<li>If performance is vital, an iterator transform that involves a closure <em>should</em> get optimized so that it is <a href="https://doc.rust-lang.org/book/ch13-04-performance.html">just
as fast</a> as the equivalent explicit code.  But if performance
of a core loop is that important, <em>measure</em> different variants and tune appropriately.
<ul>
<li>Be careful to ensure that your measurements reflect real-world performance â€“ the compiler's optimizer can
give over-optimistic results on test data (as described in <a href="testing.html">Item 30</a>).</li>
<li>The <a name="a068"></a><a href="https://godbolt.org/">Godbolt compiler explorer</a> is an amazing tool for exploring what the compiler
spits out.</li>
</ul>
</li>
</ul>
<p>Most importantly, don't convert a loop into an iteration transformation if the conversion is forced or awkward.  This is
a matter of <a name="a069"></a>taste to be sure â€“ but be aware that your taste is likely to change as you become more familiar
with the <a name="a070"></a>functional style.</p>
<p><hr/>
<p><a name="footnote-1"><a href="iterators.html#to-footnote-1">1</a></a>: In fact, the
iterator can be more general â€“ the idea of emitting next items until done need not be associated with a
container.</p>
<p><a name="footnote-2"><a href="iterators.html#to-footnote-2">2</a></a>: This method can't be provided if a mutation to
the item might invalidate the container's internal guarantees. For example, changing the item's contents in a way that
alters its <a name="a018"></a><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a> value would invalidate the internal
data structures of a <a name="a019"></a><code>HashMap</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-11-implement-the-drop-trait-for-raii-patterns"><a class="header" href="#item-11-implement-the-drop-trait-for-raii-patterns">Item 11: Implement the <code>Drop</code> trait for RAII patterns</a></h1>
<blockquote>
<p>&quot;Never send a human to do a machine's job.&quot; â€“ <a name="a001"></a>Agent Smith</p>
</blockquote>
<p><a name="a002"></a>RAII stands for &quot;Resource Acquisition Is Initialization&quot;; this is a programming pattern where the lifetime of a value
is exactly tied to the lifecycle of some additional resource.  The RAII pattern was popularized by the <a href="https://abseil.io/tips/41"><a name="a003"></a>C++ programming
language</a>, and is one of C++'s biggest contributions to programming.</p>
<p>With an RAII type,</p>
<ul>
<li>the type's <em>constructor</em> acquires access to some resource, and</li>
<li>the type's <em>destructor</em> releases access to that resource.</li>
</ul>
<p>The result of this is that the RAII type has an <em>invariant</em>: access to the underlying resource is available if and only
if the item exists. Because the compiler ensures that local variables are destroyed at scope exit, this in turn
means that the underlying resources are also released at scope exit<sup><a name="to-footnote-1"><a href="raii.html#footnote-1">1</a></a></sup>.</p>
<p>This is particularly helpful for <em>maintainability</em>: if a subsequent change to the code alters the control flow, item
and resource lifetimes are still correct. To see this, consider some code that manually locks and unlocks a mutex;
this code is in C++, because Rust's <a name="a005"></a><code>Mutex</code> doesn't allow this kind of error-prone usage!</p>
<pre><code class="language-c++">// C++ code
class ThreadSafeInt {
 public:
  ThreadSafeInt(int v) : value_(v) {}

  void add(int delta) {
    mu_.lock();
    // ... more code here
    value_ += delta;
    // ... more code here
    mu_.unlock();
  }
</code></pre>
<p>A modification to catch an error condition with an early exit leaves the mutex locked:</p>
<pre><code class="language-c++ not_desired_behaviour">  // C++ code
  void add_with_modification(int delta) {
    mu_.lock();
    // ... more code here
    value_ += delta;
    // Check for overflow.
    if (value_ &gt; MAX_INT) {
      // Oops, forgot to unlock() before exit
      return;
    }
    // ... more code here
    mu_.unlock();
  }
</code></pre>
<p>However, encapsulating the locking behaviour into an RAII class:</p>
<pre><code class="language-c++">// C++ code
class MutexLock {
 public:
  MutexLock(Mutex* mu) : mu_(mu) { mu_-&gt;lock(); }
  ~MutexLock()                   { mu_-&gt;unlock(); }
 private:
  Mutex* mu_;
};
</code></pre>
<p>means the equivalent code is safe for this kind of modification:</p>
<pre><code class="language-c++">  // C++ code
  void add_with_modification(int delta) {
    MutexLock with_lock(&amp;mu_);
    // ... more code here
    value_ += delta;
    // Check for overflow.
    if (value_ &gt; MAX_INT) {
      return; // Safe, with_lock unlocks on the way out
    }
    // ... more code here
  }
</code></pre>
<p>In C++, RAII patterns were often originally used for memory management, to ensure that manual allocation (<code>new</code>,
<code>malloc()</code>) and deallocation (<code>delete</code>, <code>free()</code>) operations were kept in sync.  A general version of this memory
management was added to the C++ standard library in <a name="a006"></a>C++11: the <code>std::unique_ptr&lt;T&gt;</code> type ensures that a single
place has &quot;ownership&quot; of memory, but which allows a pointer to the memory to be &quot;borrowed&quot; for ephemeral use
(<code>ptr.get()</code>).</p>
<p>In Rust, this behaviour for memory pointers is built into the language (<a href="borrows.html">Item 15</a>), but the general principle of RAII is
still useful for other kinds of resources<sup><a name="to-footnote-2"><a href="raii.html#footnote-2">2</a></a></sup>.  <strong>Implement <a name="a008"></a><code>Drop</code> for any types that
hold resources that must be released</strong>, such as:</p>
<ul>
<li>Access to operating system resources.  For UNIX-derived systems, this usually means something that holds a <a href="https://en.wikipedia.org/wiki/File_descriptor"><em>file
descriptor</em></a>; failing to release these correctly will hold on to system
resources (and will also eventually lead to the program hitting the per-process file descriptor limit).</li>
<li>Access to synchronization resources.  The standard library already includes memory synchronization primitives, but
other resources (e.g. file locks, database locks, â€¦) may need similar encapsulation.</li>
<li>Access to raw memory, for <code>unsafe</code> types that deal with low-level memory management (e.g. for FFI).</li>
</ul>
<p>The most obvious instance of RAII in the Rust standard library is the
<a name="a009"></a><a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a> item returned by
<a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#method.lock"><code>Mutex::lock()</code></a> operations, which tend to be widely
used for programs that use the <a name="a010"></a>shared-state parallelism discussed in <a href="deadlock.html">Item 17</a>.  This is roughly analogous to the
final C++ example above, but in Rust the <code>MutexGuard</code> item acts as a proxy to the mutex-protected data in addition to
being an RAII item for the held lock:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;

struct ThreadSafeInt {
    value: Mutex&lt;i32&gt;,
}

impl ThreadSafeInt {
    fn new(val: i32) -&gt; Self {
        Self {
            value: Mutex::new(val),
        }
    }
    fn add(&amp;self, delta: i32) {
        let mut v = self.value.lock().unwrap();
        *v += delta;
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="deadlock.html">Item 17</a> advises against holding locks for large sections of code; to ensure this, <strong>use blocks to restrict the scope of
RAII items</strong>.  This leads to slightly odd indentation, but it's worth it for the added safety and lifetime precision.</p>
<pre><code class="language-rust ignore">    fn add_with_extras(&amp;self, delta: i32) {
        // ... more code here that doesn't need the lock
        {
            let mut v = self.value.lock().unwrap();
            *v += delta;
        }
        // ... more code here that doesn't need the lock
    }</code></pre>
<p>Having proselytized the uses of the RAII pattern, an explanation of how to implement it is in order. The
<a name="a011"></a><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> trait allows you to add user-defined behaviour to the
destruction of an item.  This trait has a single method,
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a>, which the compiler runs just before the
memory holding the item is released.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct MyStruct(i32);

impl Drop for MyStruct {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping {:?}&quot;, self);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>drop</code> method is specially reserved to the compiler and can't be manually invoked, because the item would be
left in a potentially messed-up state afterwards:</p>
<pre><code class="language-rust ignore does_not_compile">    x.drop();</code></pre>
<pre><code class="language-text">error[E0040]: explicit use of destructor method
  --&gt; raii/src/main.rs:65:7
   |
65 |     x.drop();
   |     --^^^^--
   |     | |
   |     | explicit destructor calls not allowed
   |     help: consider using `drop` function: `drop(x)`
</code></pre>
<p>(As suggested by the compiler, just call <a name="a012"></a><a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>drop(obj)</code></a>
instead to manually drop an item, or enclose it in a scope as suggested above.)</p>
<p>The <code>drop</code> method is therefore the key place for implementing RAII patterns; its implementation is the ideal place to
release associated resources.</p>
<p><hr/>
<p><a name="footnote-1"><a href="raii.html#to-footnote-1">1</a></a>: This also means that RAII as a technique
is mostly only available in languages that have a predictable time of destruction, which rules out most garbage
collected languages (although Go's <a name="a004"></a><a href="https://golang.org/ref/spec#Defer_statements"><code>defer</code> statement</a>
achieves some of the same ends.)</p>
<p><a name="footnote-2"><a href="raii.html#to-footnote-2">2</a></a>: RAII is also still useful for memory management in low-level
<a name="a007"></a><code>unsafe</code> code, but that is (mostly) beyond the scope of this book</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-12-prefer-generics-to-trait-objects"><a class="header" href="#item-12-prefer-generics-to-trait-objects">Item 12: Prefer generics to trait objects</a></h1>
<p><a href="use-types-2.html">Item 2</a> described the use of traits to encapsulate behaviour in the type system, as a collection of related methods,
and observed that there are two ways to make use of traits: as <em><a name="a001"></a>trait bounds</em> for <em><a name="a002"></a>generics</em>, or in
<em><a name="a003"></a>trait objects</em>.  This Item explores the trade-offs between these two possibilities.</p>
<p>Rust's generics are roughly equivalent to <a name="a004"></a>C++'s <a name="a005"></a>templates: they allow the programmer to write
code that works for some arbitrary type <code>T</code>, and specific uses of the generic code are generated at compile time â€“
a process known as <em><a name="a006"></a>monomorphization</em> in Rust, and <em>template instantiation</em> in C++.  Unlike C++, Rust explicitly
encodes the expectations for the type <code>T</code> in the type system, in the form of trait bounds for the generic.</p>
<p>In comparison, trait objects are <a name="a007"></a>fat pointers (<a href="references.html">Item 9</a>) that combine a pointer to the underlying concrete item
with a pointer to a <a name="a008"></a>vtable that in turn holds <a name="a009"></a>function pointers for all of the trait implementation's methods.</p>
<pre><code class="language-rust ignore">    let square = Square::new(1, 2, 2);
    let draw: &amp;dyn Drawable = &amp;square;</code></pre>
<img alt="Trait object layout, with pointers to concrete item and vtable" src="images/drawable.svg" width=844>
<p>These basic facts already allow some immediate comparisons between the two possibilities:</p>
<ul>
<li>Generics are likely to lead to bigger code sizes, because the compiler generates a fresh copy of the code
<code>generic::&lt;T&gt;(t: &amp;T)</code> for every type <code>T</code> that gets used; a <code>traitobj(t: &amp;dyn T)</code> method only needs a single instance.</li>
<li>Invoking a trait method from a generic will generally be ever-so-slightly faster than from code that uses a trait
object, because the latter needs to perform two dereferences to find the location of the code (trait object to vtable,
vtable to implementation location).</li>
<li>Compile times for generics are likely to be longer, as the compiler is building more code and the <a name="a010"></a>linker has
more work to do to fold duplicates.</li>
</ul>
<p>In most situations, these aren't significant differences; you should only use optimization-related concerns as a primary
decision driver if you've measured the impact and found that it has a genuine effect (a speed bottleneck or a
problematic occupancy increase).</p>
<p>A more significant difference is that generic trait bounds can be used to conditionally make methods available,
depending on whether the type parameter implements <em>multiple</em> traits.</p>
<pre><code class="language-rust ignore">trait Drawable {
    fn bounds(&amp;self) -&gt; Bounds;
}</code></pre>
<pre><code class="language-rust ignore">    struct Container&lt;T&gt;(T);

    impl&lt;T: Drawable&gt; Container&lt;T&gt; {
        // The `area` method is available for all `Drawable` containers.
        fn area(&amp;self) -&gt; i64 {
            let bounds = self.0.bounds();
            (bounds.bottom_right.x - bounds.top_left.x)
                * (bounds.bottom_right.y - bounds.top_left.y)
        }
    }

    impl&lt;T: Drawable + Debug&gt; Container&lt;T&gt; {
        // The `show` method is only available if `Debug` is also implemented.
        fn show(&amp;self) {
            println!(&quot;{:?} has bounds {:?}&quot;, self.0, self.0.bounds());
        }
    }</code></pre>
<pre><code class="language-rust ignore">    let square = Container(Square::new(1, 2, 2)); // Square is not Debug
    let circle = Container(Circle::new(3, 4, 1)); // Circle is Debug

    println!(&quot;area(square) = {}&quot;, square.area());
    println!(&quot;area(circle) = {}&quot;, circle.area());
    circle.show();
    // The following line would not compile.
    // square.show();</code></pre>
<p>A trait object only encodes the implementation vtable for a single trait, so doing something equivalent is much more
awkward. For example, a combination <code>DebugDrawable</code> trait could be defined for the <code>show()</code> case, together with some
conversion operations (<a href="casts.html">Item 6</a>) to make life easier.  However, if there are multiple different combinations of distinct
traits, it's clear that the combinatorics of this approach rapidly become unwieldy.</p>
<p><a href="use-types-2.html">Item 2</a> described the use of <a name="a011"></a>trait bounds to restrict what type parameters are acceptable for a generic function.
Trait bounds can also be applied to trait definitions themselves:</p>
<pre><code class="language-rust ignore">trait Shape: Drawable {
    fn render_in(&amp;self, bounds: Bounds);
    fn render(&amp;self) {
        self.render_in(overlap(SCREEN_BOUNDS, self.bounds()));
    }
}</code></pre>
<p>In this example, the <code>render()</code> method's <a name="a012"></a>default implementation (<a href="default-impl.html">Item 13</a>) makes use of the trait bound, relying
on the availability of the <code>bounds()</code> method from <code>Drawable</code>.</p>
<p>Programmers coming from object-oriented languages often confuse trait bounds with inheritance, under the mistaken
impression that a trait bound like this means that a <code>Shape</code> <strong>is-a</strong> <code>Drawable</code>.  That's not the case: the relationship
between the two types is better expressed as <code>Shape</code> <strong>also-implements</strong> <code>Drawable</code>.</p>
<p>Under the covers, trait objects for traits that have trait bounds</p>
<pre><code class="language-rust ignore">    let square = Square::new(1, 2, 2);
    let draw: &amp;dyn Drawable = &amp;square;
    let shape: &amp;dyn Shape = &amp;square;</code></pre>
<p>have a single combined <a name="a013"></a>vtable that includes the methods of the top-level trait, plus the methods of all of the trait
bounds:</p>
<img alt="Trait objects for trait bounds, with distinct vtables for Square and Shape" src="images/traitbounds.svg" width=714>
<p>This means that there is no way to &quot;upcast&quot; from <code>Shape</code> to <code>Drawable</code>, because the (pure) <code>Drawable</code> vtable can't be
recovered at runtime (see <a href="reflection.html">Item 19</a> for more on this).  There is no way to convert between related trait objects, which
in turn means there is no <a name="a014"></a><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution</a>.</p>
<p>Repeating the same point in different words, a method that accepts a <code>Shape</code> trait object</p>
<ul>
<li><em>can</em> make use of methods from <code>Drawable</code> (because <code>Shape</code> also-implements <code>Drawable</code>, and because the relevant
function pointers are present in the <code>Shape</code> vtable)</li>
<li><em>cannot</em> pass the trait object on to another method that expects a <code>Drawable</code> trait object (because <code>Shape</code> is-not
<code>Drawable</code>, and because the <code>Drawable</code> vtable isn't available).</li>
</ul>
<p>In contrast, a generic method that accepts items that implement <code>Shape</code></p>
<ul>
<li><em>can</em> use methods from <code>Drawable</code></li>
<li><em>can</em> pass the item on to another generic method that has a <code>Drawable</code> trait bound, because the trait bound is
monomorphized at compile time to use the <code>Drawable</code> methods of the concrete type.</li>
</ul>
<p>Another restriction on trait objects is the requirement for <a name="a015"></a><a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md"><em>object
safety</em></a>: only traits that comply with the
following two rules can be used as trait objects.</p>
<ul>
<li>The trait's methods must not be generic.</li>
<li>The trait's methods must not return a type that includes <a name="a016"></a><code>Self</code>.</li>
</ul>
<p>The first restriction is easy to understand: a generic method <code>f</code> is really an infinite set of methods, potentially
encompassing <code>f::&lt;i16&gt;</code>, <code>f::&lt;i32&gt;</code>, <code>f::&lt;i64&gt;</code>, <code>f::&lt;u8&gt;</code>, â€¦ The trait object's vtable, on the other, is very
much a finite collection of function pointers, and so it's not possible to fit an infinite quart into a finite pint
pot.</p>
<p>The second restriction is a little bit more subtle, but tends to be the restriction that's hit more often in practice
â€“ traits that impose <a name="a017"></a><code>Copy</code> or <a name="a018"></a><code>Clone</code> <a name="a019"></a>trait bounds (<a href="std-traits.html">Item 5</a>) immediately fall under this
rule. To see why it's disallowed, consider code that has a trait object in its hands; what happens if that code calls
(say) <code>let y = x.clone()</code>? The calling code needs to reserve enough space for <code>y</code> on the stack, but it has no idea of
the size of <code>y</code> because <code>Self</code> is an arbitrary type.  As a result, return types that mention<sup><a name="to-footnote-1"><a href="generics.html#footnote-1">1</a></a></sup> <code>Self</code> lead to a trait
that is not object safe.</p>
<p>There is an exception to this second restriction.  A method returning some <code>Self</code>-related type does not affect object
safety if <code>Self</code> comes with an explicit restriction to types whose <a name="a020"></a>size is known at compile time: <code>Self: Sized</code>. This trait bound means that the method can't be used with trait objects anyway, because trait objects are
explicitly of unknown size (<a name="a021"></a><code>!Sized</code>), and so the method is irrelevant for object safety.</p>
<p>The balance of factors so far leads to the advice to <strong>prefer generics to trait objects</strong>, but there are situations
where trait objects are the right tool for the job.</p>
<p>The first is a practical consideration: if generated code size or
compilation time is a concern, then trait objects will perform better (as described at the start of this Item).</p>
<p>A more theoretical aspect that leads towards trait objects is that they fundamentally involve <em><a name="a022"></a>type erasure</em>:
information about the concrete type is lost in the conversion to a trait object.  This can be a downside (see <a href="reflection.html">Item 19</a>),
but it can also be useful because it allows for collections of heterogeneous objects â€“ because the code <em>just</em>
relies on the methods of the trait, it can invoke and combine the methods of differently (concretely) typed items.</p>
<p>The traditional <a name="a023"></a>OO example of rendering a list of shapes would be one example of this: the same
<code>render()</code> method could be used for squares, circles, ellipses and stars in the same loop.</p>
<pre><code class="language-rust ignore">    let shapes: Vec&lt;&amp;dyn Shape&gt; = vec![&amp;square, &amp;circle];
    for shape in shapes {
        shape.render()
    }</code></pre>
<p>A much more obscure potential advantage for trait objects is when the available types are not known at compile-time; if
new code is dynamically loaded at run-time (e.g via <a href="https://man7.org/linux/man-pages/man3/dlopen.3.html"><code>dlopen(3)</code></a>),
then items that implement traits in the new code can only be invoked via a trait object, because there's no source code
to monomorphize over.</p>
<p><hr/>
<p><a name="footnote-1"><a href="generics.html#to-footnote-1">1</a></a>: At present, the
restriction on methods that return <code>Self</code> includes types like <code>Box&lt;Self&gt;</code> that <em>could</em> be safely stored on the stack;
this restriction <a href="https://github.com/rust-lang/rust/issues/47649">might be relaxed in future</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-13-use-default-implementations-to-minimize-required-trait-methods"><a class="header" href="#item-13-use-default-implementations-to-minimize-required-trait-methods">Item 13: Use default implementations to minimize required trait methods</a></h1>
<p>The designer of a trait has two different audiences to consider: the programmers who will be <em>implementing</em> the trait, and
those who will be <em>using</em> the trait.  These two audiences lead to a degree of tension in the trait design:</p>
<ul>
<li>To make the implementor's life easier, it's better for a trait to have the absolute minimum number of methods to
achieve its purpose.</li>
<li>To make the user's life more convenient, it's helpful to provide a range of variant methods that cover all of the
common ways that the trait might be used.</li>
</ul>
<p>This tension can be balanced by including the wider range of methods that makes the user's life easier, but with
<em><a name="a001"></a>default implementations</em> provided for any methods that can be built from other, more primitive, operations on the
interface.</p>
<p>A simple example of this is the
<a name="a002"></a><a href="https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html#method.is_empty"><code>is_empty()</code></a> method for an
<a name="a003"></a><a href="https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html"><code>ExactSizeIterator</code></a>; it has a default
implementation that relies on the <a href="https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html#method.len"><code>len()</code></a>
trait method:</p>
<pre><code class="language-rust ignore">    fn is_empty(&amp;self) -&gt; bool {
        self.len() == 0
    }</code></pre>
<p>The existence of a default implementation is just that: a default.  If an implementation of the trait has a more optimal
way of determining whether the iterator is empty, it can replace the default <code>is_empty()</code> with its own.</p>
<p>This approach leads to trait definitions that have a small number of <em><a name="a004"></a>required methods</em>, plus a much larger number of
default-implemented methods.  An implementor for the trait only has to implement the former, and gets all of the latter
for free.</p>
<p>It's also an approach that is widely followed by the Rust standard library; perhaps the best example there is the
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> trait, which has a single required method
(<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next"><code>next</code></a>) but which includes a panoply of
pre-provided methods (<a href="iterators.html">Item 10</a>), over 50 at the time of writing.</p>
<p>Trait methods can impose <em><a name="a005"></a>trait bounds</em>, indicating that a method is only available if the types involved
implement particular traits.  The <a name="a006"></a><code>Iterator</code> trait also shows that this is useful in combination with default
method implementations.  For example, the
<a name="a007"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cloned"><code>cloned()</code></a> iterator method has a
trait bound and a default implementation:</p>
<pre><code class="language-rust ignore">    fn cloned&lt;'a, T: 'a&gt;(self) -&gt; Cloned&lt;Self&gt;
    where
        Self: Sized + Iterator&lt;Item = &amp;'a T&gt;,
        T: Clone,
    {
        Cloned::new(self)
    }</code></pre>
<p>In other words, the <code>cloned()</code> method is only available if the underlying <code>Item</code> type implements
<a name="a008"></a><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>; when it does, the implementation is automatically
available.</p>
<p>The final observation about trait methods with default implementations is that new ones can be safely added to a trait
even after an initial version of the trait is released.  An addition like this preserves
<a name="a009"></a>backwards compatibility (see <a href="semver.html">Item 21</a>) for both users and implementors<sup><a name="to-footnote-1"><a href="default-impl.html#footnote-1">1</a></a></sup> of the trait.</p>
<p>So follow the example of the standard library and provide a minimal API surface for implementors, but a convenient and
comprehensive API for users, by adding methods with default implementations (and trait bounds as appropriate).</p>
<p><hr/>
<p><a name="footnote-1"><a href="default-impl.html#to-footnote-1">1</a></a>: This is true
even if an implementor was unlucky enough to have already added a method of the same name in the concrete type, as the
concrete method â€“ known as an <a href="https://doc.rust-lang.org/reference/items/implementations.html#inherent-implementations"><em>inherent
implementation</em></a> â€“ will
be used ahead of trait method.  The trait method can be explicitly selected instead by casting: <code>&lt;Concrete as Trait&gt;::method()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>The first section of this book covered Rust's type system, which helps provide the vocabulary needed to work with some
of the <em>concepts</em> involved in writing Rust code.</p>
<p>The <a name="a001"></a>borrow checker and <a name="a002"></a>lifetime checks are central to what makes Rust unique; they are also a common stumbling block for
newcomers to Rust.</p>
<p>However, it's a good idea to try to align your code with the consequences of these concepts.  It's <em>possible</em> to
re-create (some of) the behaviour of C/<a name="a003"></a>C++ in Rust, but why bother to use Rust if you do?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-14-understand-lifetimes"><a class="header" href="#item-14-understand-lifetimes">Item 14: Understand lifetimes</a></h1>
<blockquote>
<p>&quot;Eppur si muove&quot; â€“  <a name="a001"></a>Galileo Galilei</p>
</blockquote>
<p>This Item describes Rust's <em><a name="a002"></a>lifetimes</em>, which are a more precise formulation of a concept that existed in previous
compiled languages like C and C++ â€“ in practice if not in theory.  Lifetimes are a required input for the <em>borrow
checker</em> described in <a href="borrows.html">Item 15</a>; taken together these features form the heart of Rust's <a name="a003"></a>memory safety guarantees.</p>
<h2 id="introduction-to-the-stack"><a class="header" href="#introduction-to-the-stack">Introduction to the Stack</a></h2>
<p>Lifetimes are fundamentally related to the <em>stack</em>, so a quick introduction/reminder is in order.</p>
<p>While a program is running, the memory that it uses is divided up into different chunks, sometimes called
<em><a name="a004"></a>segments</em>.  Some of these chunks are a fixed size, such as the ones that hold the program code or the program's
global data, but two of the chunks â€“ the <em><a name="a005"></a>heap</em> and the <em><a name="a006"></a>stack</em> â€“ change size as the program
runs.  To allow for this, they are typically arranged at opposite ends of the program's virtual memory space, so one
can grow downwards and the other can grow upwards (at least until your program runs out of memory and crashes).</p>
<p><img alt="Program memory layout, including heap growing up and stack growing down" src="images/memorylayout.svg"
width=756></p>
<p>Of these two dynamically sized chunks, the stack is used to hold state related to the currently executing function,
specifically its parameters, local variables and temporary values, held in a <em><a name="a007"></a>stack frame</em>.  When a function <code>f()</code>
is called, a new stack frame is added to the stack, beyond where the stack frame for the calling function ends, and the
CPU normally updates a register â€“ the <em><a name="a008"></a>stack pointer</em> â€“ to point to the new stack frame.</p>
<p>When the inner function <code>f()</code> returns, the stack pointer is reset to where it was before the call, which will be the
caller's stack frame, intact and unmodified.</p>
<p>When the caller invokes a different function <code>g()</code>, the process happens again, which means that the stack frame for
<code>g()</code> will re-use the same area of memory that <code>f()</code> previously used.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn caller() -&gt; u64 {
    let x = 42u64;
    let y = 19u64;
    f(x) + g(y)
}

fn f(f_param: u64) -&gt; u64 {
    let two = 2;
    f_param + two
}

fn g(g_param: u64) -&gt; u64 {
    let arr = [2, 3];
    g_param + arr[1]
}
<span class="boring">}</span></code></pre></pre>
<img alt="Evolution of stack usage as functions are called and returned from" src="images/stackuse.svg" width=756>
<p>Of course, this is a dramatically simplified version of what really goes on; putting things on and off the stack takes
time and so there are many optimizations for real processors.  However, the simplified conceptual picture is enough for
understanding the subject of this Item.</p>
<h2 id="evolution-of-lifetimes"><a class="header" href="#evolution-of-lifetimes">Evolution of Lifetimes</a></h2>
<p>The previous section explained how parameters and local variables are stored on the stack, but only ephemerally.
Historically, this allowed for some dangerous footguns: what happens if you hold onto a pointer to one of these
ephemeral stack values?</p>
<p>Starting back with <a name="a009"></a>C, it was perfectly OK to return a pointer to a local variable (although modern compilers will
emit a warning for it):</p>
<pre><code class="language-c not_desired_behaviour">/* C code. */
struct File* open_bugged() {
  struct File f = { open(&quot;README.md&quot;, O_RDONLY) };
  return &amp;f;  // return address of stack object
}
</code></pre>
<p>You <em>might</em> get away with this, if you're unlucky and the calling code uses the returned value immediately:</p>
<pre><code class="language-c not_desired_behaviour">  struct File* f = open_bugged();
  printf(&quot;in caller: file at %p has fd=%d\n&quot;, f, f-&gt;fd);
</code></pre>
<pre><code class="language-text">in caller: file at 0x7ff7b5ca9408 has fd=3
</code></pre>
<p>This is unlucky because it only <em>appears</em> to work.  As soon as any other function calls happen, the stack area will
be re-used and the memory that used to hold the object will be overwritten:</p>
<pre><code class="language-c not_desired_behaviour">  investigate_file(f);
</code></pre>
<pre><code class="language-c">/* C code. */
void investigate_file(struct File* f) {
  long array[4] = {1, 2, 3, 4}; // put things on the stack
  printf(&quot;in function: file at %p has fd=%d\n&quot;, f, f-&gt;fd);
}
</code></pre>
<pre><code class="language-text">in function: file at 0x7ff7b5ca9408 has fd=1842872565
</code></pre>
<p>Trashing the contents of the object has an additional bad effect for this example: the file descriptor corresponding to
the open file is lost, and so the program leaks the resource that was held in the data structure.</p>
<p>Moving forwards in time to <a name="a010"></a>C++, this problem of losing access to resources was solved by the inclusion of <em>destructors</em>,
enabling <a name="a011"></a>RAII (cf. <a href="raii.html">Item 11</a>).  Now, the things on the stack have the ability to tidy themselves up: if the object holds
some kind of resource, the destructor can tidy it up and the C++ compiler guarantees that the destructor of an object on
the stack gets called as part of tidying up the stack frame.</p>
<pre><code class="language-c++">  // C++ code.
  ~File() {
    std::cout &lt;&lt; &quot;~File(): close fd &quot; &lt;&lt; fd &lt;&lt; &quot;\n&quot;;
    close(fd);
    fd = -1;
  }
</code></pre>
<p>The caller now gets an (invalid) pointer to an object that's been destroyed and its resources reclaimed:</p>
<pre><code class="language-c++ not_desired_behaviour">  File* f = open_bugged();
  printf(&quot;in caller: file at %p has fd=%d\n&quot;, f, f-&gt;fd);
</code></pre>
<pre><code class="language-text">~File(): close fd 3
in caller: file at 0x7ff7b57ef408 has fd=-1
</code></pre>
<p>However, C++ did nothing to help with the problem of dangling pointers: it's still possible to hold on to a pointer to an
object that's gone (and whose destructor has been called).</p>
<pre><code class="language-c">// C++ code.
void investigate_file(File* f) {
  long array[4] = {1, 2, 3, 4}; // put things on the stack
  std::cout &lt;&lt; &quot;in function: file at &quot; &lt;&lt; f &lt;&lt; &quot; has fd=&quot; &lt;&lt; f-&gt;fd &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<pre><code class="language-text">in function: file at 0x7ff7b57ef408 has fd=1711145032
</code></pre>
<p>As a C/C++ programmer, it's up to you to notice this, and make sure that you don't dereference a pointer that points to
something that's gone.  Alternatively, if you're an <a name="a012"></a>attacker and you find one of these dangling pointers, you're
more likely to <a name="a013"></a>cackle maniacally and gleefully dereference the pointer on your way to an exploit.</p>
<p>Enter Rust.  One of Rust's core attractions is that it fundamentally solves the problem of dangling pointers,
immediately solving a large fraction<sup><a name="to-footnote-1"><a href="lifetimes.html#footnote-1">1</a></a></sup> of security problems.</p>
<p>Doing so requires that the concept of lifetimes move from the background (where C/C++ programmers have to just know to
watch out for them, without any language support) to the foreground: every type that includes an ampersand <strong><code>&amp;</code></strong> has
an associated lifetime (<strong><code>'a</code></strong>), even if the compiler lets you omit mention of it much of the time.</p>
<h2 id="scope-of-a-lifetime"><a class="header" href="#scope-of-a-lifetime">Scope of a Lifetime</a></h2>
<p>The lifetime of an item on the stack is the period where that item is guaranteed to stay in the same place; in other
words, this is exactly the period where a <em><a name="a015"></a>reference</em> (pointer) to item is guaranteed not to become invalid.</p>
<p>This starts at the point where the item is created, and extends to where it is either:</p>
<ul>
<li><a name="a016"></a><strong>dropped</strong> (Rust's equivalent to object destruction in C++), or</li>
<li><a name="a017"></a><strong>moved</strong>.</li>
</ul>
<p>(The ubiquity of the latter is sometimes surprising for programmers coming from C/C++: Rust moves items from one place on
the stack to another, or from the stack to the heap, or from the heap to the stack, in lots of situations.)</p>
<p>Precisely where an item gets automatically dropped depends on whether an item has a name or not.</p>
<p>Local variables and function parameters have names, and the corresponding item's lifetime starts when the item is
created and the name is populated:</p>
<ul>
<li>For a local variable: at the <code>let var = ...</code> declaration.</li>
<li>For a function parameter: as part of setting up the execution frame for the function invocation.</li>
</ul>
<p>The lifetime for a named item ends when the item is either moved somewhere else, or when the name goes out of
<a name="a018"></a>scope:</p>
<pre><code class="language-rust ignore">        {
            let item1 = Item { contents: 1 }; // `item1` created here
            let item2 = Item { contents: 2 }; // `item2` created here
            println!(&quot;item1 = {:?}, item2 = {:?}&quot;, item1, item2);
            consuming_fn(item2); // `item2` moved here
        } // `item1` dropped here</code></pre>
<p>It's also possible to build an item &quot;on the fly&quot;, as part of an expression that's then fed into something else.  These
unnamed temporary items are then dropped when they're no longer needed.  One over-simplified but helpful way to think
about this is to imagine that each branch of the expression's syntax tree gets expanded to its own block, with temporary
variables being inserted by the compiler.  For example, an expression like:</p>
<pre><code class="language-rust ignore">    let x = f((a + b) * 2);</code></pre>
<p>would be roughly equivalent to:</p>
<pre><code class="language-rust ignore">    let x = {
        let temp1 = a + b;
        {
            let temp2 = temp1 * 2;
            f(temp2)
        } // `temp2` dropped here
    }; // `temp1` dropped here</code></pre>
<p>By the time execution reaches the <a name="a019"></a>semicolon at the end of the line, the <a name="a020"></a>temporaries have all been dropped.</p>
<p>One way to see what the compiler calculates as an item's lifetime is to insert a deliberate error for the borrow checker
(<a href="borrows.html">Item 15</a>) to detect.  For example, hold onto a reference beyond the lifetime's scope:</p>
<pre><code class="language-rust ignore does_not_compile">        let r: &amp;Item;
        {
            let item = Item { contents: 42 };
            r = &amp;item;
        }
        println!(&quot;r.contents = {}&quot;, r.contents);</code></pre>
<p>The error message indicates the exact endpoint of <code>item</code>'s lifetime:</p>
<pre><code class="language-text">error[E0597]: `item` does not live long enough
   --&gt; lifetimes/src/main.rs:206:17
    |
206 |             r = &amp;item;
    |                 ^^^^^ borrowed value does not live long enough
207 |         }
    |         - `item` dropped here while still borrowed
208 |         println!(&quot;r.contents = {}&quot;, r.contents);
    |                                     ---------- borrow later used here
</code></pre>
<p>Similarly, for an unnamed temporary:</p>
<pre><code class="language-rust ignore does_not_compile">        let r: &amp;Item = fn_returning_ref(&amp;mut Item { contents: 42 });
        println!(&quot;r.contents = {}&quot;, r.contents);</code></pre>
<p>the error message shows the endpoint at the end of the expression:</p>
<pre><code class="language-text">error[E0716]: temporary value dropped while borrowed
   --&gt; lifetimes/src/main.rs:236:46
    |
236 |         let r: &amp;Item = fn_returning_ref(&amp;mut Item { contents: 42 });
    |                                              ^^^^^^^^^^^^^^^^^^^^^ - temporary value is freed at the end of this statement
    |                                              |
    |                                              creates a temporary which is freed while still in use
237 |         println!(&quot;r.contents = {}&quot;, r.contents);
    |                                     ---------- borrow later used here
    |
    = note: consider using a `let` binding to create a longer lived value
</code></pre>
<p>One final point about the lifetimes of <em>references</em>: if the compiler can prove to itself that there is no use of a
reference beyond a certain point in the code, then it treats the endpoint of the reference's lifetime as the last place
it's used, rather than the end of the enclosing scope.  This feature (known as <a name="a021"></a><a href="https://rust-lang.github.io/rfcs/2094-nll.html">non-lexical
lifetimes</a>) allows the borrow checker to be a little bit more
generous:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    {
        let mut s: String = &quot;Hello, world&quot;.to_string(); // `s` owns the `String`

        let greeting = &amp;mut s[..5]; // mutable reference to `String`
        greeting.make_ascii_uppercase();
        // .. no use of `greeting` after this point

        let r: &amp;str = &amp;s; // immutable reference to `String`
        println!(&quot;s = '{}'&quot;, r); // s = 'HELLO, world'
    } // where the mutable reference `greeting` would naively be dropped
<span class="boring">}</span></code></pre></pre>
<h2 id="algebra-of-lifetimes"><a class="header" href="#algebra-of-lifetimes">Algebra of Lifetimes</a></h2>
<p>Although lifetimes are ubiquitous when dealing with references in Rust, you don't get to specify them in any detail
â€“ there's no way to say &quot;I'm dealing with a lifetime that extends from line 17 to line 32 of <code>ref.rs</code>&quot;.  (There's
one partial exception to this, covered below: <a name="a022"></a><code>'static</code>.)</p>
<p>Instead, your code refers to lifetimes with arbitrary labels, conventionally <code>'a</code>, <code>'b</code>, <code>'c</code>, â€¦, and the
compiler has its own internal, inaccessible representation of what that equates to in the source code.</p>
<p>You don't get to do much with these lifetime labels; the main thing that's possible is to compare one label with
another, repeating a label to indicate that two lifetimes are the &quot;same&quot;.  (Later, we'll see that it's also possible to
specify that one lifetime must be bigger than another, when expressed as the <a name="a023"></a>lifetime bounds for a generic.)</p>
<p>This algebra of lifetimes is easiest to illustrate with function signatures: if the inputs and outputs of a function
deal with references, what's the relationship between their lifetimes?</p>
<p>The most common case is a function that receives a single reference as input, and emits a reference as output.  The
output reference must have a lifetime, but what can it be?  There's only one possibility to choose from: the lifetime of
the input, which means that they both share the same label, say <code>'a</code>:</p>
<pre><code class="language-rust ignore">    pub fn first&lt;'a&gt;(data: &amp;'a [Item]) -&gt; Option&lt;&amp;'a Item&gt; {</code></pre>
<p>Because this variant is so common, and because there's (almost) no choice about what the output lifetime can be, Rust has
<em><a name="a024"></a>lifetime elision</em> rules that mean you don't have to explicitly write the lifetimes for this case.  A more idiomatic
version of the same function signature would be:</p>
<pre><code class="language-rust ignore">    pub fn first(data: &amp;[Item]) -&gt; Option&lt;&amp;Item&gt; {</code></pre>
<p>What if there's more than one choice of input lifetimes to map to an output lifetime?  In this case, the compiler can't
figure out what to do:</p>
<pre><code class="language-rust ignore does_not_compile">    pub fn find(haystack: &amp;[u8], needle: &amp;[u8]) -&gt; Option&lt;&amp;[u8]&gt; {</code></pre>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
   --&gt; lifetimes/src/main.rs:399:59
    |
399 |     pub fn find(haystack: &amp;[u8], needle: &amp;[u8]) -&gt; Option&lt;&amp;[u8]&gt; {
    |                           -----          -----            ^ expected named lifetime parameter
    |
    = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `haystack` or `needle`
help: consider introducing a named lifetime parameter
    |
399 |     pub fn find&lt;'a&gt;(haystack: &amp;'a [u8], needle: &amp;'a [u8]) -&gt; Option&lt;&amp;'a [u8]&gt; {
    |                ++++            ++                ++                  ++
</code></pre>
<p>A shrewd guess based on the function and parameter names is that the intended lifetime for the output here is expected
to match the <code>haystack</code> input:</p>
<pre><code class="language-rust ignore">    pub fn find&lt;'a, 'b&gt;(
        haystack: &amp;'a [u8],
        needle: &amp;'b [u8],
    ) -&gt; Option&lt;&amp;'a [u8]&gt; {</code></pre>
<p>Interestingly, the compiler suggested a different alternative: having both inputs to the function use the <em>same</em>
lifetime <code>'a'</code>.  For example, a function where this combination of lifetimes might make sense is:</p>
<pre><code class="language-rust ignore">    pub fn smaller&lt;'a&gt;(left: &amp;'a Item, right: &amp;'a Item) -&gt; &amp;'a Item {</code></pre>
<p>This <em>appears</em> to imply that the two input lifetimes are the &quot;same&quot;, but the scare quotes (here and above) are included
to signify that that's not quite what's going on.</p>
<p>The <em>raison d'Ãªtre</em> of lifetimes is to ensure that references to items don't out-live the items themselves; with this in
mind, an output lifetime <code>'a</code> that's the &quot;same&quot; as an input lifetime <code>'a</code> just means that the input has to live longer
than the output.</p>
<p>When there are two input lifetimes <code>'a</code> that are the &quot;same&quot;, that just means that the output lifetime has to be
contained within the lifetimes of <em>both</em> of the inputs:</p>
<pre><code class="language-rust ignore">    {
        let outer = Item { contents: 7 };
        {
            let inner = Item { contents: 8 };
            {
                let min = smaller(&amp;inner, &amp;outer);
                println!(&quot;smaller of {:?} and {:?} is {:?}&quot;, inner, outer, min);
            } // `min` dropped
        } // `inner` dropped
    } // `outer` dropped</code></pre>
<p>To put it another way, the output lifetime has to be subsumed within the <em>smaller</em> of the lifetimes of the two inputs.</p>
<p>In contrast, if the output lifetime is unrelated to the lifetime of one of the inputs, then there's no requirement for
those lifetimes to nest:</p>
<pre><code class="language-rust ignore">    {
        let haystack = b&quot;123456789&quot;; // start of  lifetime 'a
        let found = {
            let needle = b&quot;234&quot;; // start of lifetime 'b
            find(haystack, needle)
        }; // end of lifetime 'b
        println!(&quot;found = {:?}&quot;, found); // `found` use within 'a, outside of 'b
    } // end of lifetime 'a</code></pre>
<h3 id="lifetime-elision-rules"><a class="header" href="#lifetime-elision-rules">Lifetime Elision Rules</a></h3>
<p>In addition to the &quot;one in, one out&quot; elision rule described above, there are two other elision rules that mean that
lifetimes can be omitted.</p>
<p>The first occurs when there are no references in the outputs from a function; in this case, each of the input references
automatically gets its own lifetime, different from any of the other input parameters.</p>
<p>The second occurs for methods that use a reference to <code>self</code> (either <code>&amp;self</code> or <code>&amp;mut self</code>); in this case, the compiler
assumes that any output references take the lifetime of <code>self</code>, as this turns out to be (by far) the most common situation.</p>
<p>Summarizing the <a name="a025"></a>elision rules for functions:</p>
<ul>
<li>One input, one or more outputs: assume outputs have the &quot;same&quot; lifetime as the input.
<pre><code class="language-rust ignore">fn f(x: &amp;Item) -&gt; (&amp;Item, &amp;Item)
// ... is equivalent to ...
fn f&lt;'a&gt;(x: &amp;'a Item) -&gt; (&amp;'a Item, &amp;'a Item)</code></pre>
</li>
<li>Multiple inputs, no output: assume all the inputs have different lifetimes.
<pre><code class="language-rust ignore">fn f(x: &amp;Item, y: &amp;Item, z: &amp;Item) -&gt; i32
// ... is equivalent to ...
fn f&lt;'a, 'b, 'c&gt;(x: &amp;'a Item, y: &amp;'b Item, z: &amp;'c Item) -&gt; i32</code></pre>
</li>
<li>Multiple inputs including <code>&amp;self</code>, one or more outputs: assume output lifetime(s) are the &quot;same&quot; as <code>&amp;self</code>'s lifetime.
<pre><code class="language-rust ignore">fn f(&amp;self, y: &amp;Item, z: &amp;Item) -&gt; &amp;Thing
// ... is equivalent to ...
fn f(&amp;'a self, y: &amp;'b Item, z: &amp;'c Item) -&gt; &amp;'a Thing</code></pre>
</li>
</ul>
<h2 id="the-static-lifetime"><a class="header" href="#the-static-lifetime">The <code>'static</code> Lifetime</a></h2>
<p>The previous section described various different possible mappings between the input and output reference lifetimes for
a function, but it neglected to cover one special case.  What happens if there are <em>no</em> input lifetimes, but the output
return value includes a reference anyway?</p>
<pre><code class="language-rust ignore does_not_compile">    pub fn the_answer() -&gt; &amp;Item {</code></pre>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
   --&gt; lifetimes/src/main.rs:411:28
    |
411 |     pub fn the_answer() -&gt; &amp;Item {
    |                            ^ expected named lifetime parameter
    |
    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
    |
411 |     pub fn the_answer() -&gt; &amp;'static Item {
    |                            ~~~~~~~~
</code></pre>
<p>The only allowed possibility is for the returned reference to have a lifetime that's guaranteed to never go out of
scope.  This is indicated by the special lifetime <strong><a name="a026"></a><code>'static</code></strong>, which is also the only lifetime that has a
specific name rather than a placeholder label.</p>
<pre><code class="language-rust ignore">    pub fn the_answer() -&gt; &amp;'static Item {</code></pre>
<p>The simplest way to get something with the <code>'static</code> lifetime is to take a reference to a <a name="a027"></a>global variable that's
been marked as <a name="a028"></a><a href="https://doc.rust-lang.org/std/keyword.static.html"><code>static</code></a>:</p>
<pre><code class="language-rust ignore">    static ANSWER: Item = Item { contents: 42 };
    pub fn the_answer() -&gt; &amp;'static Item {
        &amp;ANSWER
    }</code></pre>
<p>The Rust compiler guarantees that a <code>static</code> item always has the same address for the entire duration of the program,
and never moves.  This means that a reference to a <code>static</code> item has a <code>'static</code> lifetime, logically enough.</p>
<p>Note that a <a name="a029"></a><code>const</code> global variable does <em>not</em> have the same guarantee: only the <em>value</em> is guaranteed to be the same
everywhere, and the compiler is allowed to make as many copies as it likes, wherever the variable is used.  These
potential copies may be ephemeral, and so won't satisfy the <code>'static</code> requirements:</p>
<pre><code class="language-rust ignore does_not_compile">    const ANSWER: Item = Item { contents: 42 };
    pub fn the_answer() -&gt; &amp;'static Item {
        &amp;ANSWER
    }</code></pre>
<pre><code class="language-text">error[E0515]: cannot return reference to temporary value
   --&gt; lifetimes/src/main.rs:424:9
    |
424 |         &amp;ANSWER
    |         ^------
    |         ||
    |         |temporary value created here
    |         returns a reference to data owned by the current function
</code></pre>
<p>There's one more possible way to get something with a <code>'static</code> lifetime.  The key promise of <code>'static</code> is that the
lifetime should outlive any other lifetime in the program; a value that's allocated on the <a name="a030"></a>heap but <em>never freed</em>
also satisfies this constraint.</p>
<p>A normal heap-allocated <code>Box&lt;T&gt;</code> doesn't work for this, because there's no guarantee (as described in the next section)
that the item won't get dropped along the way:</p>
<pre><code class="language-rust ignore does_not_compile">    {
        let boxed = Box::new(Item { contents: 12 });
        let r: &amp;'static Item = &amp;boxed;
        println!(&quot;'static item is {:?}&quot;, r);
    }</code></pre>
<pre><code class="language-text">error[E0597]: `boxed` does not live long enough
   --&gt; lifetimes/src/main.rs:318:32
    |
318 |         let r: &amp;'static Item = &amp;boxed;
    |                -------------   ^^^^^^ borrowed value does not live long enough
    |                |
    |                type annotation requires that `boxed` is borrowed for `'static`
319 |         println!(&quot;'static item is {:?}&quot;, r);
320 |     }
    |     - `boxed` dropped here while still borrowed
</code></pre>
<p>However, the <a name="a031"></a><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak"><code>Box::leak</code></a> function
converts an owned <code>Box&lt;T&gt;</code> to a mutable reference to <code>T</code>.  There's no longer an owner for the value, so it can never be
dropped â€“ which satisfies the requirements for the <code>'static</code> lifetime:</p>
<pre><code class="language-rust ignore">    {
        let boxed = Box::new(Item { contents: 12 });
        // `leak()` consumes the `Box&lt;T&gt;` and returns `&amp;mut T`.
        let r: &amp;'static Item = Box::leak(boxed);
        println!(&quot;'static item is {:?}&quot;, r);
    } // `boxed` not dropped here, because it was already moved</code></pre>
<p>The inability to drop the item also means that the memory that holds the item can never be reclaimed using safe Rust,
possibly leading to a permanent memory leak. Recovering the memory requires <code>unsafe</code> code, which makes this a technique
to reserve for special circumstances.</p>
<h2 id="lifetimes-and-the-heap"><a class="header" href="#lifetimes-and-the-heap">Lifetimes and the Heap</a></h2>
<p>The discussion so far has concentrated on the lifetimes of items on the stack, whether function parameters, local
variables or temporaries. But what about items on the <a name="a032"></a>heap?</p>
<p>The key thing to realize about heap values is that every item has an owner (excepting special cases like the deliberate
leaks described in the previous section).  For example, a simple <code>Box&lt;T&gt;</code> puts the <code>T</code> value on the heap, with the owner
being the variable holding the <code>Box&lt;T&gt;</code>:</p>
<pre><code class="language-rust ignore">    {
        let b: Box&lt;Item&gt; = Box::new(Item { contents: 42 });
    } // `b` dropped here, so `Item` dropped too.</code></pre>
<p>The owning <code>Box&lt;Item&gt;</code> drops its contents when it goes out of scope, so the lifetime of the <code>Item</code> on the heap is the
same as the lifetime of the <code>Box&lt;Item&gt;</code> variable on the stack.</p>
<p>The owner of a value on the heap may itself be on the heap rather than the stack, but then who owns the owner?</p>
<pre><code class="language-rust ignore">    {
        let b: Box&lt;Item&gt; = Box::new(Item { contents: 42 });
        let bb: Box&lt;Box&lt;Item&gt;&gt; = Box::new(b); // `b` moved onto heap here
    } // `b` dropped here, so `Box&lt;Item&gt;` dropped too, so `Item` dropped too</code></pre>
<p>The chain of ownership has to end somewhere, and there are only two possibilities:</p>
<ul>
<li>The chain ends at a local variable or function parameter â€“ in which case the lifetime of everything in the chain
is just the lifetime <code>'a</code> of that stack variable.  When the stack variable goes out of scope, everything in the chain
is dropped too.</li>
<li>The chain ends at a global variable marked as <code>static</code> â€“ in which case the lifetime of everything in the chain
is <code>'static</code>.  The <code>static</code> variable never goes out of scope, so nothing in the chain ever gets automatically dropped.</li>
</ul>
<p>As a result, the lifetimes of items on the heap are fundamentally tied to stack lifetimes.</p>
<h2 id="lifetimes-in-data-structures"><a class="header" href="#lifetimes-in-data-structures">Lifetimes in Data Structures</a></h2>
<p>The earlier section on the algebra of lifetimes concentrated on inputs and outputs for functions, but there are similar
concerns when references are stored in data structures.</p>
<p>If we try to sneak a reference into a data structure without mentioning an associated lifetime, the compiler brings us
up sharply:</p>
<pre><code class="language-rust ignore does_not_compile">    pub struct ReferenceHolder {
        pub index: usize,
        pub item: &amp;Item,
    }</code></pre>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
   --&gt; lifetimes/src/main.rs:452:19
    |
452 |         pub item: &amp;Item,
    |                   ^ expected named lifetime parameter
    |
help: consider introducing a named lifetime parameter
    |
450 ~     pub struct ReferenceHolder&lt;'a&gt; {
451 |         pub index: usize,
452 ~         pub item: &amp;'a Item,
    |
</code></pre>
<p>As usual, the compiler error message tells what to do. The first part is simple enough: give the reference type an
explicit lifetime <code>'a</code>, because there are no lifetime elision rules when using references in data structures.</p>
<p>The second part is less obvious and has deeper consequences: the data structure itself has to have a
<a name="a033"></a>lifetime annotation <code>&lt;'a&gt;</code> that matches the lifetime of the reference contained within it:</p>
<pre><code class="language-rust ignore">    pub struct ReferenceHolder&lt;'a&gt; {
        pub index: usize,
        pub item: &amp;'a Item,
    }</code></pre>
<p>The lifetime annotation for the data structure is infectious: any containing data structure that uses the type also has
to acquire a lifetime annotation:</p>
<pre><code class="language-rust ignore">    // Annotation includes lifetimes of all fields
    pub struct MultiRefHolder&lt;'a, 'b&gt; {
        pub left: ReferenceHolder&lt;'a&gt;,
        pub right: ReferenceHolder&lt;'b&gt;, // Could choose 'a instead here
    }</code></pre>
<p>This makes sense: anything that contains a reference, no matter how deeply nested, is only valid for the lifetime of the
item referred to. If that item is moved or dropped, then the whole chain of data structures is no longer valid.</p>
<p>However, this does also mean that data structures involving references are harder to use â€“ the owner of the data
structure has to ensure that the lifetimes all line up.  As a result, <strong>prefer data structures that own their contents</strong>
where possible, particularly if the code doesn't need to be highly optimized (<a href="optimize.html">Item 20</a>).  Where that's not possible, the
various smart pointer types (e.g. <a name="a034"></a><a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html"><code>Rc</code></a>) described in
<a href="references.html">Item 9</a> can help untangle the lifetime constraints.</p>
<h3 id="lifetime-bounds"><a class="header" href="#lifetime-bounds">Lifetime Bounds</a></h3>
<p>Generic<a name="a035"></a> code (<a href="generics.html">Item 12</a>) involves some unknown type <code>T</code>, often constrained by a <a name="a036"></a>trait bound <code>T: SomeTrait</code>.  But what happens if the code that's built around <code>T</code> is a reference type?</p>
<p>There's various different ways that references can make their way into the generics mix:</p>
<ul>
<li>A generic might take a <code>&lt;T&gt;</code>, but include code that deals with references-to-<code>T</code>, for example <code>&amp;T</code>.</li>
<li>The type <code>T</code> might itself be a reference type, for example <code>&amp;Thing</code>, or some bigger data structure <code>MultiRefHolder&lt;'a, 'b&gt;</code> that includes references.</li>
</ul>
<p>Regardless of the route by which references arise, any generic data structure needs to propagate their associated
lifetimes, as in the previous section.</p>
<p>The main way to allow for this is to specify <a name="a037"></a><a href="https://doc.rust-lang.org/reference/trait-bounds.html#lifetime-bounds">lifetime
bounds</a>, which indicate that either a type
(<code>T: 'b</code>) or specific lifetime <code>'a: 'b</code> has to outlive some other lifetime <code>'b</code>.</p>
<p>For example, consider a type that wraps a reference (somewhat akin to the <a name="a038"></a><code>Ref</code> type returned by
<a name="a039"></a><code>RefCell::borrow()</code>):</p>
<pre><code class="language-rust ignore">pub struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);</code></pre>
<p>This generic data structure holds an explicit reference <code>&amp;'a T</code>, as per the first bullet above.  But the type <code>T</code> might
itself contain references with some lifetime <code>'b</code>, as per the second bullet above.  If <code>T</code>'s inherent lifetime <code>'b</code> were
smaller than the exterior lifetime <code>'a</code> we'd have a potential disaster: the <code>Ref</code> would be holding a reference to a data
structure whose own references have gone bad.</p>
<p>To prevent this, we need <code>'b</code> to be larger than <code>'a</code>; for named lifetimes this would be written as <code>'b: 'a</code>, but we need
to say that slightly differently, as <code>T: 'a</code>.  Roughly translated into words, that says &quot;any references in the type <code>T</code>
must have a lifetime that outlives <code>'a</code>&quot;, and that makes <code>Ref</code> safe: if its own lifetime (<code>'a</code>) is still valid, then so
are any references hidden inside <code>T</code>.</p>
<p>Translating lifetime bounds into words also helps with a <code>'static</code> lifetime bound like <code>T: 'static</code>. This says that &quot;any
references in the type <code>T</code> must have a <code>'static</code> lifetime&quot;, which means that <code>T</code> can't have any dynamic references.  Any
non-reference type <code>T</code> that owns its contents â€“ <code>String</code>, <code>Vec</code> etc. â€“ satisfies this bound, but any type
that has an <code>&lt;'a&gt;</code> creeping in does not.</p>
<p>One common place this shows up is when you try to move values between threads with
<a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>std::thread::spawn</code></a>. The moved values need to be of types that
implement <a name="a040"></a><code>Send</code> (see <a href="deadlock.html">Item 17</a>), indicating that they're safe to move between threads, but they also need to not contain
any dynamic references (the <code>'static</code> lifetime bound).  This makes sense when you realize that a reference to something
on the stack now raises the question: which stack?  Each thread's stack is independent, and so lifetimes can't be
tracked between them.</p>
<p><hr/>
<p><a name="footnote-1"><a href="lifetimes.html#to-footnote-1">1</a></a>: For example, the <a name="a014"></a>Chromium project estimates that <a href="https://www.chromium.org/Home/chromium-security/memory-safety/">70% of security
bugs are due to memory safety</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-15-understand-the-borrow-checker"><a class="header" href="#item-15-understand-the-borrow-checker">Item 15: Understand the borrow checker</a></h1>
<blockquote>
<p>&quot;The power to destroy a thing is the absolute control over it.&quot; â€“ Frank Herbert</p>
</blockquote>
<p>Values in Rust have an owner, but that owner can lend the values out to other places in the code. This <em>borrowing</em>
mechanism involves the creation and use of <a name="a001"></a><em>references</em>, subject to rules policed by the <em><a name="a002"></a>borrow
checker</em>.</p>
<p>Under the covers this uses the same kind of <em>pointer</em> values (<a href="references.html">Item 9</a>) that are so prevalent in <a name="a003"></a>C or <a name="a004"></a>C++
code, but girded with rules and restrictions to make sure that the sins of C/C++ are avoided. As a quick comparison:</p>
<ul>
<li>Like a C/C++ pointer, a Rust reference is created with an ampersand: <code>&amp;value</code>.</li>
<li>Like a C++ reference, a Rust reference can never be <a name="a005"></a><code>nullptr</code>.</li>
<li>Like a C/C++ pointer or reference, a Rust reference can be modified after creation to refer to something different.</li>
<li>Unlike C++, producing a reference from a value always involves an explicit (<strong><code>&amp;</code></strong>) conversion â€“ if you see
code like <code>f(value)</code>, you know that <code>f</code> is receiving ownership of the value<sup><a name="to-footnote-1"><a href="borrows.html#footnote-1">1</a></a></sup>.</li>
<li>Unlike C/C++, the mutability of a newly-created reference is always explicit (<strong><code>&amp; mut</code></strong>); if you see code like
<code>f(&amp;value)</code>, you know that <code>value</code> won't modified (i.e. is <code>const</code> in C/C++ terminology).  Only expressions<sup><a name="to-footnote-2"><a href="borrows.html#footnote-2">2</a></a></sup> like <code>f(&amp;mut value)</code> have the possibility of changing the contents of <code>value</code>.</li>
</ul>
<p>The most important difference between a C/C++ pointer and a Rust reference is indicated by the term <em><a name="a008"></a>borrow</em>: you
can take a reference (pointer) to an item, <em>but you have to give it back</em>.  In particular, you have to give it back
<em>before</em> the lifetime of the underlying item expires, as tracked by the compiler and explored in <a href="lifetimes.html">Item 14</a>.</p>
<p>These restrictions on the use of references are at the heart of Rust's memory safety guarantees, but they do mean you
have to accept the cognitive costs of the borrow rules â€“ accept that it will change how you design your software,
particularly its data structures.</p>
<h2 id="access-control"><a class="header" href="#access-control">Access Control</a></h2>
<p>There are three different ways that a Rust item can be accessed: via the item's <em>owner</em> (<code>item</code>), via a <em>reference</em>
(<code>&amp;item</code>), or via a <em>mutable reference</em> (<code>&amp;mut item</code>).</p>
<p>Each of these different ways of accessing the item comes with different powers over the item.  Putting things in
<a name="a009"></a><a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a>e terms:</p>
<ul>
<li>The owner of an item gets to <strong>c</strong>reate it, <strong>r</strong>ead from it, <strong>u</strong>pdate it, and <strong>d</strong>rop it (CRUD).</li>
<li>A mutable reference can be used to <strong>r</strong>ead from the underlying item, and to <strong>u</strong>pdate it (_RU_).</li>
<li>A (normal) reference can only be used to <strong>r</strong>ead from the underlying item (_R__).</li>
</ul>
<p>There's an important Rust-specific extension to these data access rules: only the item's owner can <a name="a010"></a><em>move</em> the item.  This makes sense if you think of a move as being some combination of <strong>c</strong>reating (in the
new location) and <strong>d</strong>ropping the item's memory (at the old location).</p>
<p>This can lead to some oddities for code that has a mutable reference to an item.  For example, it's OK to overwrite an
<code>Option</code>:</p>
<pre><code class="language-rust ignore">fn overwrite(item: &amp;mut Option&lt;Item&gt;, val: Item) {
    *item = Some(val);
}</code></pre>
<p>but a modification to return the previous value falls foul of the move restriction:</p>
<pre><code class="language-rust ignore does_not_compile">    pub fn replace(item: &amp;mut Option&lt;Item&gt;, val: Item) -&gt; Option&lt;Item&gt; {
        let previous = *item; // move out
        *item = Some(val); // replace
        previous
    }</code></pre>
<pre><code class="language-text">error[E0507]: cannot move out of `*item` which is behind a mutable reference
  --&gt; borrows/src/main.rs:27:24
   |
27 |         let previous = *item; // move out
   |                        ^^^^^ move occurs because `*item` has type `Option&lt;Item&gt;`, which does not implement the `Copy` trait
   |
help: consider borrowing the `Option`'s content
   |
27 |         let previous = *item.as_ref(); // move out
   |                             +++++++++
help: consider borrowing here
   |
27 |         let previous = &amp;*item; // move out
   |                        ~~~~~~
</code></pre>
<p>It's valid to read from a mutable reference, and it's valid to write to a mutable reference, and so the ability to do
both at once is provided by the <a name="a011"></a><a href="https://doc.rust-lang.org/std/mem/fn.replace.html"><code>std::mem::replace</code></a>
function in the standard library.  This uses <a name="a012"></a><code>unsafe</code> code under the covers (as per <a href="unsafe.html">Item 16</a>) to perform the swap
in one go:</p>
<pre><code class="language-rust ignore">    pub fn replace(item: &amp;mut Option&lt;Item&gt;, val: Item) -&gt; Option&lt;Item&gt; {
        std::mem::replace(item, Some(val)) // returns previous value
    }</code></pre>
<p>For <a name="a013"></a><code>Option</code> types in particular, this is a sufficiently common pattern that there is also a
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.replace"><code>replace</code></a> method on <code>Option</code> itself:</p>
<pre><code class="language-rust ignore">    pub fn replace(item: &amp;mut Option&lt;Item&gt;, val: Item) -&gt; Option&lt;Item&gt; {
        item.replace(val)
    }</code></pre>
<h2 id="borrow-rules"><a class="header" href="#borrow-rules">Borrow Rules</a></h2>
<p>The first rule for borrowing references in Rust is that the scope of any reference must be smaller than the lifetime of
the item that it refers to. However, the compiler is smarter than just assuming that a reference lasts until it is
dropped â€“ the <em><a name="a014"></a>non-lexical lifetimes</em> feature allows reference lifetimes to be shrunk so they end at the
point of last use, rather than the enclosing block (as described in <a href="lifetimes.html">Item 14</a>).</p>
<p>The second rule for borrowing references is that, in addition to the owner of an item, there can be</p>
<ul>
<li>any number of immutable references to the item, <em>or</em></li>
<li>a single mutable reference to the item</li>
</ul>
<p>but not both.</p>
<p>So a method that takes multiple immutable references can be fed references to the same item:</p>
<pre><code class="language-rust ignore">    fn both_zero(left: &amp;Item, right: &amp;Item) -&gt; bool {
        left.contents == 0 &amp;&amp; right.contents == 0
    }

    let item = Item { contents: 0 };
    assert!(both_zero(&amp;item, &amp;item));</code></pre>
<p>but one that takes <em>mutable</em> references cannot:</p>
<pre><code class="language-rust ignore does_not_compile">    fn zero_both(left: &amp;mut Item, right: &amp;mut Item) {
        left.contents = 0;
        right.contents = 0;
    }

    let mut item = Item { contents: 42 };
    zero_both(&amp;mut item, &amp;mut item);</code></pre>
<pre><code class="language-text">error[E0499]: cannot borrow `item` as mutable more than once at a time
   --&gt; borrows/src/main.rs:115:26
    |
115 |     zero_both(&amp;mut item, &amp;mut item);
    |     --------- ---------  ^^^^^^^^^ second mutable borrow occurs here
    |     |         |
    |     |         first mutable borrow occurs here
    |     first borrow later used by call
</code></pre>
<p>and similarly for a mixture of the two:</p>
<pre><code class="language-rust ignore does_not_compile">    fn copy_contents(left: &amp;mut Item, right: &amp;Item) {
        left.contents = right.contents;
    }

    let mut item = Item { contents: 42 };
    copy_contents(&amp;mut item, &amp;item);</code></pre>
<pre><code class="language-text">error[E0502]: cannot borrow `item` as immutable because it is also borrowed as mutable
   --&gt; borrows/src/main.rs:140:30
    |
140 |     copy_contents(&amp;mut item, &amp;item);
    |     ------------- ---------  ^^^^^ immutable borrow occurs here
    |     |             |
    |     |             mutable borrow occurs here
    |     mutable borrow later used by call
</code></pre>
<p>The borrowing rules allow the compiler to make better decisions around
<a name="a015"></a><a href="https://en.wikipedia.org/wiki/Aliasing_(computing)"><em>aliasing</em></a>: tracking when two different pointers
may or may not refer to the same underlying item in memory.  If the compiler can be sure (as in Rust) that the memory
location pointed to by a collection of immutable references cannot be altered via an aliased <em>mutable</em> reference, then
it can generate code that is:</p>
<ul>
<li>better optimized: values can be (e.g.) cached in registers, secure in the knowledge that the underlying memory
contents will not change in the meanwhile</li>
<li>safer: data races arising from unsynchronized access to memory between threads (<a href="deadlock.html">Item 17</a>) are not possible.</li>
</ul>
<h3 id="owner-operations"><a class="header" href="#owner-operations">Owner Operations</a></h3>
<p>One important consequence of the rules around the existence of references is that they also affect what operations can
be performed by the owner of the item.  To help understand this, consider operations involving the owner as though they
make use of references along the way.</p>
<p>For example, an attempt to update the item via its owner while a reference exists fails, because of this transient
second mutable reference:</p>
<pre><code class="language-rust ignore does_not_compile">    let mut item = Item { contents: 42 };
    let r = &amp;item;
    item.contents = 0;
    // ^^^ Changing the item is roughly equivalent to:
    //   (&amp;mut item).contents = 0;
    println!(&quot;reference to item is {:?}&quot;, r);</code></pre>
<pre><code class="language-text">error[E0506]: cannot assign to `item.contents` because it is borrowed
   --&gt; borrows/src/main.rs:164:5
    |
163 |     let r = &amp;item;
    |             ----- borrow of `item.contents` occurs here
164 |     item.contents = 0;
    |     ^^^^^^^^^^^^^^^^^ assignment to borrowed `item.contents` occurs here
...
167 |     println!(&quot;reference to item is {:?}&quot;, r);
    |                                           - borrow later used here
</code></pre>
<p>On the other hand, because multiple <em>immutable</em> references are allowed, it's OK for the owner to read from the item
while there are immutable references in existence:</p>
<pre><code class="language-rust ignore">    let item = Item { contents: 42 };
    let r = &amp;item;
    let contents = item.contents;
    // ^^^ Reading from the item is roughly equivalent to:
    //   let contents = (&amp;item).contents;
    println!(&quot;reference to item is {:?}&quot;, r);</code></pre>
<p>but not if there is a <em>mutable</em> reference:</p>
<pre><code class="language-rust ignore does_not_compile">    let mut item = Item { contents: 42 };
    let r = &amp;mut item;
    let contents = item.contents; // i64 is `Copy`
    r.contents = 0;</code></pre>
<pre><code class="language-text">error[E0503]: cannot use `item.contents` because it was mutably borrowed
   --&gt; borrows/src/main.rs:194:20
    |
193 |     let r = &amp;mut item;
    |             --------- borrow of `item` occurs here
194 |     let contents = item.contents; // i64 is `Copy`
    |                    ^^^^^^^^^^^^^ use of borrowed `item`
195 |     r.contents = 0;
    |     -------------- borrow later used here
</code></pre>
<p>Finally, the existence of any sort of reference prevents the owner of the item from moving or <a name="a016"></a>dropping the
item, exactly because this mean that the reference now refers to an invalid item.</p>
<pre><code class="language-rust ignore does_not_compile">    let item = Item { contents: 42 };
    let r = &amp;item;
    let new_item = item; // move
    println!(&quot;reference to item is {:?}&quot;, r);</code></pre>
<pre><code class="language-text">error[E0505]: cannot move out of `item` because it is borrowed
   --&gt; borrows/src/main.rs:151:20
    |
150 |     let r = &amp;item;
    |             ----- borrow of `item` occurs here
151 |     let new_item = item; // move
    |                    ^^^^ move out of `item` occurs here
152 |     println!(&quot;reference to item is {:?}&quot;, r);
    |                                           - borrow later used here
</code></pre>
<h2 id="winning-fights-against-the-borrow-checker"><a class="header" href="#winning-fights-against-the-borrow-checker">Winning Fights against the Borrow Checker</a></h2>
<p>Newcomers to Rust (and even more experienced folk!) can often feel that they are spending time fighting against the
borrow checker. What kinds of things can help you win these battles?</p>
<h3 id="local-code-refactoring"><a class="header" href="#local-code-refactoring">Local Code Refactoring</a></h3>
<p>The first tactic is to pay attention to the compiler's error messages, because the Rust developers have put a lot of
effort into making them as helpful as possible.</p>
<pre><code class="language-rust ignore does_not_compile">/// If `needle` is present in `haystack`, return a slice containing it.
pub fn find&lt;'a, 'b&gt;(a: &amp;'a str, b: &amp;'b str) -&gt; Option&lt;&amp;'a str&gt; {
    a.find(b).map(|i| &amp;a[i..i + b.len()])
}

// ...

    let found = find(&amp;format!(&quot;{} to search&quot;, &quot;Text&quot;), &quot;ex&quot;);
    if let Some(text) = found {
        println!(&quot;Found '{}'!&quot;, text);
    }</code></pre>
<pre><code class="language-text">error[E0716]: temporary value dropped while borrowed
   --&gt; borrows/src/main.rs:312:23
    |
312 |     let found = find(&amp;format!(&quot;{} to search&quot;, &quot;Text&quot;), &quot;ex&quot;);
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^       - temporary value is freed at the end of this statement
    |                       |
    |                       creates a temporary which is freed while still in use
313 |     if let Some(text) = found {
    |                         ----- borrow later used here
    |
    = note: consider using a `let` binding to create a longer lived value
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<p>The first part of the error message is the important part, because it describes what borrowing rule the compiler thinks
you have broken, and why.  As you encounter enough of these errors â€“ which you will â€“ you can build up an
intuition about the borrow checker that matches the more theoretical version encapsulated in the rules above.</p>
<p>The second part of the error message includes the compiler's suggestions for how to fix the problem, which in this
case is simple:</p>
<pre><code class="language-rust ignore">    let haystack = format!(&quot;{} to search&quot;, &quot;Text&quot;);
    let found = find(&amp;haystack, &quot;ex&quot;);
    if let Some(text) = found {
        println!(&quot;Found '{}'!&quot;, text);
    }
    // `found` now references `haystack`, which out-lives it</code></pre>
<p>This is an instance of one of the two simple code tweaks that can help mollify the borrow checker:</p>
<ul>
<li><em>Lifetime extension</em>: convert a temporary (whose lifetime only extends to the end of the expression) to be a new named
local variable (whose lifetime extends to the end of the block) with a <a name="a017"></a><code>let</code> binding.</li>
<li><em>Lifetime reduction</em>: add an additional block <code>{ ... }</code> around the use of a reference so that its lifetime ends at the
end of the new block.</li>
</ul>
<p>The latter is less common, because of the existence of <a name="a018"></a>non-lexical lifetimes: the compiler can often figure out
that a reference is no longer used, ahead of its official drop point at the end of the block. However, if you do find
yourself repeatedly introducing an artificial block around similar small chunks of code, consider whether that code
should be encapsulated into a method of its own.</p>
<p>The compiler's suggested fixes are helpful for simpler problems, but as you write more sophisticated code you're likely
to find that the suggestions are no longer useful, and that the explanation of the broken borrowing rule is harder to
follow.</p>
<pre><code class="language-rust ignore does_not_compile">    let x = Some(Rc::new(RefCell::new(Item { contents: 42 })));

    // Call function with signature: `check_item(item: Option&lt;&amp;Item&gt;)`
    check_item(x.as_ref().map(|r| r.borrow().deref()));</code></pre>
<pre><code class="language-text">error[E0515]: cannot return reference to temporary value
   --&gt; borrows/src/main.rs:257:35
    |
257 |     check_item(x.as_ref().map(|r| r.borrow().deref()));
    |                                   ----------^^^^^^^^
    |                                   |
    |                                   returns a reference to data owned by the current function
    |                                   temporary value created here
</code></pre>
<p>In this situation it can be helpful to temporarily introduce a sequence of local variables, one for each step of a
complicated transformation, and each with an explicit type annotation.</p>
<pre><code class="language-rust ignore does_not_compile">    let x: Option&lt;Rc&lt;RefCell&lt;Item&gt;&gt;&gt; =
        Some(Rc::new(RefCell::new(Item { contents: 42 })));

    let x1: Option&lt;&amp;Rc&lt;RefCell&lt;Item&gt;&gt;&gt; = x.as_ref();
    let x2: Option&lt;std::cell::Ref&lt;Item&gt;&gt; = x1.map(|r| r.borrow());
    let x3: Option&lt;&amp;Item&gt; = x2.map(|r| r.deref());
    check_item(x3);</code></pre>
<pre><code class="language-text">error[E0515]: cannot return reference to function parameter `r`
   --&gt; borrows/src/main.rs:269:40
    |
269 |     let x3: Option&lt;&amp;Item&gt; = x2.map(|r| r.deref());
    |                                        ^^^^^^^^^ returns a reference to data owned by the current function
</code></pre>
<p>This narrows down the precise conversion that the compiler is complaining about, which in turn allows the code to be
restructured:</p>
<pre><code class="language-rust ignore">    let x: Option&lt;Rc&lt;RefCell&lt;Item&gt;&gt;&gt; =
        Some(Rc::new(RefCell::new(Item { contents: 42 })));

    let x1: Option&lt;&amp;Rc&lt;RefCell&lt;Item&gt;&gt;&gt; = x.as_ref();
    let x2: Option&lt;std::cell::Ref&lt;Item&gt;&gt; = x1.map(|r| r.borrow());
    match x2 {
        None =&gt; check_item(None),
        Some(r) =&gt; {
            let x3: &amp;Item = r.deref();
            check_item(Some(x3));
        }
    }</code></pre>
<p>Once the underlying problem is clear and has been fixed, you're then free to re-coalesce the local variables back
together, so that you can pretend that you got it right all along:</p>
<pre><code class="language-rust ignore">    let x = Some(Rc::new(RefCell::new(Item { contents: 42 })));

    match x.as_ref().map(|r| r.borrow()) {
        None =&gt; check_item(None),
        Some(r) =&gt; check_item(Some(r.deref())),
    };</code></pre>
<h3 id="data-structure-design"><a class="header" href="#data-structure-design">Data Structure Design</a></h3>
<p>The next tactic that helps for battles against the borrow checker is to design your data structures with the borrow
checker in mind.  The panacea is if your data structures can own all of the data that they use, avoiding any use of
references and the consequent propagation of <a name="a019"></a>lifetime annotations described in <a href="lifetimes.html">Item 14</a>.</p>
<p>However, that's not always possible for real-world data structures; any time the internal connections of the data
structure form a graph that's more inter-connected than a tree pattern (a <code>Root</code> that owns multiple <code>Branch</code>es, each of
which owns multiple <code>Leaf</code>s etc.), then simple single-ownership isn't possible.</p>
<p>To take a simple example, imagine a simple register of guest details recorded in the order in which they arrive.</p>
<pre><code class="language-rust ignore">#[derive(Clone)]
struct Guest {
    name: String,
    phone: PhoneNumber,
    address: String,
    // ... many other fields
}

#[derive(Default, Debug)]
struct GuestRegister(Vec&lt;Guest&gt;);

impl GuestRegister {
    fn register(&amp;mut self, guest: Guest) {
        self.0.push(guest)
    }
    fn nth(&amp;self, idx: usize) -&gt; Option&lt;&amp;Guest&gt; {
        if idx &lt; self.0.len() {
            Some(&amp;self.0[idx])
        } else {
            None
        }
    }
}</code></pre>
<p>If this code <em>also</em> needs to be able to efficiently look up guests by arrival and alphabetically by name, then there are
fundamentally two distinct data structures involved, and only one of them can own the data.</p>
<p>If the data involved is both small and immutable, then just taking a copy can give a quick solution.</p>
<pre><code class="language-rust ignore">#[derive(Default, Debug)]
struct ClonedGuestRegister {
    by_arrival: Vec&lt;Guest&gt;,
    by_name: BTreeMap&lt;String, Guest&gt;,
}

impl ClonedGuestRegister {
    fn register(&amp;mut self, guest: Guest) {
        self.by_arrival.push(guest.clone()); // requires `Guest` to be `Clone`
        self.by_name.insert(guest.name.clone(), guest);
    }
    fn named(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Guest&gt; {
        self.by_name.get(name)
    }
    fn nth(&amp;self, idx: usize) -&gt; Option&lt;&amp;Guest&gt; {
        // snip
    }
}</code></pre>
<p>This approach of taking copies copes poorly if the data can be modified â€“ if the telephone number for a <code>Guest</code>
needs to be updated, you have to find both versions and ensure they stay in sync.</p>
<p>Another possible approach is to add another layer of indirection, treating the <code>Vec&lt;Guest&gt;</code> as the owner and using an
index into that vector for the name lookups.</p>
<p>This approach copes fine with a changing phone number â€“ the (single) <code>Guest</code> is owned by the <code>Vec</code>, and will
always be reached that way under the covers:</p>
<pre><code class="language-rust ignore">    let new_number = PhoneNumber::new(123456);
    ledger.named_mut(&quot;Bob&quot;).unwrap().phone = new_number;
    assert_eq!(ledger.named(&quot;Bob&quot;).unwrap().phone, new_number);</code></pre>
<p>However, it copes less well with a different kind of modification: what happens if guests can de-register:</p>
<pre><code class="language-rust ignore not_desired_behaviour">    // Deregister the `Guest` at position `idx`, moving up all subsequent guests.
    fn deregister(&amp;mut self, idx: usize) -&gt; Result&lt;(), Error&gt; {
        if idx &gt;= self.by_arrival.len() {
            return Err(Error::new(&quot;out of bounds&quot;));
        }
        self.by_arrival.remove(idx);
        // Oops, forgot to update `by_name`.
        Ok(())
    }</code></pre>
<p>Now that the <code>Vec</code> can be shuffled, the <code>by_name</code> indexes into it are effectively acting like pointers, and we've
re-introduced a world where those &quot;pointers&quot; can point to nothing (beyond the <code>Vec</code> bounds) or can point to incorrect
data.</p>
<pre><code class="language-rust ignore not_desired_behaviour">    ledger.register(alice);
    ledger.register(bob);
    ledger.register(charlie);
    println!(&quot;Register starts as: {:?}&quot;, ledger);

    ledger.deregister(0).unwrap();
    println!(&quot;Register after deregister(0): {:?}&quot;, ledger);

    let also_alice = ledger.named(&quot;Alice&quot;);
    // Alice still has index 0, which is now Bob
    println!(&quot;Alice is {:?}&quot;, also_alice);

    let also_bob = ledger.named(&quot;Bob&quot;);
    // Bob still has index 1, which is now Charlie
    println!(&quot;Bob is {:?}&quot;, also_bob);

    let also_charlie = ledger.named(&quot;Charlie&quot;);
    // Charlie still has index 2, which is now beyond the Vec
    println!(&quot;Charlie is {:?}&quot;, also_charlie);</code></pre>
<pre><code class="language-text">Register starts as: {
  by_arrival: [{n: 'Alice', ...}, {n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: {&quot;Alice&quot;: 0, &quot;Bob&quot;: 1, &quot;Charlie&quot;: 2}
}
Register after deregister(0): {
  by_arrival: [{n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: {&quot;Alice&quot;: 0, &quot;Bob&quot;: 1, &quot;Charlie&quot;: 2}
}
Alice is Some({n: 'Bob', ...})
Bob is Some({n: 'Charlie', ...})
Charlie is None
</code></pre>
<p>Regardless of approach, the code needs to be fixed to ensure the data structures stay in sync.  However, a better
approach to the underlying data structure would be to use Rust's smart pointers instead (<a href="references.html">Item 9</a>).  Shifting to a
combination of <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> and
<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> avoids the invalidation problems of using indices as
pseudo-pointers:</p>
<pre><code class="language-rust ignore">#[derive(Default)]
struct RcGuestRegister {
    by_arrival: Vec&lt;Rc&lt;RefCell&lt;Guest&gt;&gt;&gt;,
    by_name: BTreeMap&lt;String, Rc&lt;RefCell&lt;Guest&gt;&gt;&gt;,
}

impl RcGuestRegister {
    fn register(&amp;mut self, guest: Guest) {
        let name = guest.name.clone();
        let guest = Rc::new(RefCell::new(guest));
        self.by_arrival.push(guest.clone());
        self.by_name.insert(name, guest);
    }
    fn deregister(&amp;mut self, idx: usize) -&gt; Result&lt;(), Error&gt; {
        if idx &gt;= self.by_arrival.len() {
            return Err(Error::new(&quot;out of bounds&quot;));
        }
        self.by_arrival.remove(idx);
        // Oops, still forgot to update `by_name`.
        Ok(())
    }
    // snip
}</code></pre>
<pre><code class="language-text">Register starts as: {
  by_arrival: [{n: 'Alice', ...}, {n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: [(&quot;Alice&quot;, {n: 'Alice', ...}), (&quot;Bob&quot;, {n: 'Bob', ...}), (&quot;Charlie&quot;, {n: 'Charlie', ...})]
}
Register after deregister(0): {
  by_arrival: [{n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: [(&quot;Alice&quot;, {n: 'Alice', ...}), (&quot;Bob&quot;, {n: 'Bob', ...}), (&quot;Charlie&quot;, {n: 'Charlie', ...})]
}
Alice is Some(RefCell { value: {n: 'Alice', ...} })
Bob is Some(RefCell { value: {n: 'Bob', ...} })
Charlie is Some(RefCell { value: {n: 'Charlie', ...} })
</code></pre>
<p>The output is now valid, but there's a lingering entry for Alice that remains until we ensure that the two collections
stay in sync:</p>
<pre><code class="language-rust ignore">    fn deregister_fixed(&amp;mut self, idx: usize) -&gt; Result&lt;(), Error&gt; {
        if idx &gt;= self.by_arrival.len() {
            return Err(Error::new(&quot;out of bounds&quot;));
        }
        let guest: Rc&lt;RefCell&lt;Guest&gt;&gt; = self.by_arrival.remove(idx);
        self.by_name.remove(&amp;guest.borrow().name);
        Ok(())
    }</code></pre>
<pre><code class="language-text">Register after deregister(0): {
  by_arrival: [{n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: [(&quot;Bob&quot;, {n: 'Bob', ...}), (&quot;Charlie&quot;, {n: 'Charlie', ...})]
}
Alice is None
Bob is Some(RefCell { value: {n: 'Bob', ...} })
Charlie is Some(RefCell { value: {n: 'Charlie', ...} })
</code></pre>
<h3 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h3>
<p>The final variation of the previous section is an example of a more general approach: <strong>use Rust's smart pointers for
interconnected data structures</strong>.</p>
<p><a href="references.html">Item 9</a> described the most common <a name="a020"></a>smart pointer types provided by Rust's standard library.</p>
<ul>
<li><a name="a021"></a><code>Rc</code> allows shared ownership, with multiple things referring to the same item. Often combined withâ€¦</li>
<li><a name="a022"></a><code>RefCell</code> allows interior mutability, so that internal state can be modified without needing a mutable
reference.  This comes at the cost of moving borrow checks from compile-time to run-time.</li>
<li><a name="a023"></a><code>Arc</code> is the multi-threading equivalent to <code>Rc</code>.</li>
<li><a name="a024"></a><code>Mutex</code> (and <a name="a025"></a><code>RwLock</code>) allows interior mutability in a multi-threading environment, roughly equivalent to
<code>RefCell</code>.</li>
<li><a name="a026"></a><code>Cell</code> allows interior mutability for <code>Copy</code> types.</li>
</ul>
<p>For programmers and designs that are adapting from C++ to Rust, the most common tool to reach for is <code>Rc&lt;T&gt;</code> (and its
thread-safe cousin <code>Arc&lt;T&gt;</code>), often combined with <code>RefCell</code> (or the thread-safe alternative <code>Mutex</code>).  A naÃ¯ve
translation of shared pointers (or even <a name="a027"></a><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a>s) to <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> instances will
generally give something that works in Rust without too much complaint from the borrow checker.  However, this approach
means that you miss out on some of the protections that Rust gives you; in particular, situations where the same item is
mutably borrowed (via <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.borrow_mut"><code>borrow_mut()</code></a>) while
another reference exists result in a run-time <a name="a028"></a><code>panic!</code> rather than a compile-time error.</p>
<p>For example, one pattern that breaks the one-way flow of ownership in tree-like data structures is when there's an
&quot;owner&quot; pointer back from an item to the thing that owns it:</p>
<pre><code class="language-c++">// C++ code (with lackadaisical pointer use)
struct Tree {
  std::string id() const;

  std::string tree_id_;
  std::vector&lt;Branch*&gt; branches_; // `Tree` owns `Branch` objects
};

struct Branch {
  std::string id() const;  // hierarchical identifier for `Branch`

  std::string branch_id_;
  std::vector&lt;Leaf*&gt; leaves_; // `Branch` owns `Leaf` objects
  Tree* owner_; // back-reference to owning `Tree`
};

struct Leaf {
  std::string id() const;  // hierarchical identifier for `Leaf`

  std::string leaf_id_;
  Branch* owner_; // back-reference to owning `Branch`
};

std::string Branch::id() const {
  if (owner_ == nullptr) {
    return &quot;&lt;unowned&gt;.&quot; + branch_id_;
  } else {
    return owner_-&gt;id()+ &quot;.&quot; + branch_id_;
  }
}
</code></pre>
<p>Implementing the equivalent pattern in Rust can make use of <code>Rc&lt;T&gt;</code>'s more tentative partner,
<a name="a029"></a><a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak&lt;T&gt;</code></a>:</p>
<pre><code class="language-rust ignore">struct Tree {
    tree_id: String,
    branches: Vec&lt;Rc&lt;RefCell&lt;Branch&gt;&gt;&gt;,
}

struct Branch {
    branch_id: String,
    leaves: Vec&lt;Rc&lt;RefCell&lt;Leaf&gt;&gt;&gt;,
    owner: Option&lt;Weak&lt;RefCell&lt;Tree&gt;&gt;&gt;,
}

struct Leaf {
    leaf_id: String,
    owner: Option&lt;Weak&lt;RefCell&lt;Branch&gt;&gt;&gt;,
}</code></pre>
<p>The <code>Weak</code> reference doesn't increment the refcount, and so has to explicitly check whether the underlying item
has gone away:</p>
<pre><code class="language-rust ignore">impl Branch {
    fn add_leaf(branch: Rc&lt;RefCell&lt;Branch&gt;&gt;, mut leaf: Leaf) {
        leaf.owner = Some(Rc::downgrade(&amp;branch));
        branch.borrow_mut().leaves.push(Rc::new(RefCell::new(leaf)));
    }
    fn id(&amp;self) -&gt; String {
        match &amp;self.owner {
            None =&gt; format!(&quot;&lt;unowned&gt;.{}&quot;, self.branch_id),
            Some(t) =&gt; {
                let tree = t.upgrade().expect(&quot;internal error: owner gone!&quot;);
                format!(&quot;{}.{}&quot;, tree.borrow().id(), self.branch_id)
            }
        }
    }
}</code></pre>
<p>If Rust's smart pointer don't seem to cover what's needed for your data structures, there's always the final fallback of
writing <a name="a030"></a><code>unsafe</code> code that uses raw (and decidedly un-smart) pointers.  However, as per <a href="unsafe.html">Item 16</a> this should very
much be a last resort â€“ someone else might already have implemented the semantics you want, inside a safe
interface, and if you search the standard library and <a name="a031"></a><code>crates.io</code> you might find it.</p>
<p>For example, imagine that you have a function that sometimes returns a reference to one of its inputs, but sometimes
needs to return some freshly allocated data. In line with <a href="use-types.html">Item 1</a>, an <a name="a032"></a><code>enum</code> that encodes these two possibilities
is the natural way to express this in the type system, and you could then implement various of the pointer traits
described in <a href="references.html">Item 9</a>.  But you don't have to: the standard library already includes the
<a name="a033"></a><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>std::borrow::Cow</code></a> type<sup><a name="to-footnote-3"><a href="borrows.html#footnote-3">3</a></a></sup> that covers
exactly this scenario once you know it exists.</p>
<h3 id="self-referential-data-structures"><a class="header" href="#self-referential-data-structures">Self-Referential Data Structures</a></h3>
<p>One particular style of data structure always stymies programmers arriving at Rust from other languages:
attempting to create self-referential data structures, which contain a mixture of owned data together with references to
within that owned data.</p>
<pre><code class="language-rust ignore does_not_compile">struct SelfRef {
    text: String,
    // The slice of `text` that holds the title text.
    title: Option&lt;&amp;str&gt;,
}</code></pre>
<p>At a syntactic level, this code won't compile because it doesn't comply with the lifetime rules described in <a href="references.html">Item 9</a>:
the reference needs a lifetime annotation, but we wouldn't want that lifetime annotation to be propagated to the
containing data structure, because the intent is not to refer to anything external.</p>
<p>It's worth thinking about the reason for this restriction at a more semantic level.  Data structures in Rust can <em>move</em>:
from the stack to the heap, from the heap to the stack, and from one place to another.  If that happens, the &quot;interior&quot;
<code>title</code> pointer would no longer be valid, and there's no way to keep it in sync.</p>
<p>A simple alternative for this case is to use the indexing approach explored earlier; a range of offsets into the <code>text</code>
is not invalidated by a move, and is invisible to the borrow checker because it doesn't involve references:</p>
<pre><code class="language-rust ignore">struct SelfRefIdx {
    text: String,
    // Indices into `text` where the title text is.
    title: Option&lt;Range&lt;usize&gt;&gt;,
}</code></pre>
<p>However, this indexing approach only works for simple examples. A more general version of the self-reference problem
turns up when the compiler deals with <a name="a034"></a><code>async</code> code<sup><a name="to-footnote-4"><a href="borrows.html#footnote-4">4</a></a></sup>.  Roughly speaking, the compiler
bundles up a pending chunk of <code>async</code> code into a lambda, and the data for that lambda can include both values and
references to those values.</p>
<p>That's inherently a self-referential data structure, and so <code>async</code> support was a prime motivation for the
<a name="a037"></a><a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin</code></a> type in the standard library.  This pointer type &quot;pins&quot;
its value in place, forcing the value to remain at the same location in memory, thus ensuring that internal
self-references remain valid.</p>
<p>So <code>Pin</code> is available as a possibility for self-referential types, but it's tricky to use correctly (as its <a href="https://doc.rust-lang.org/std/pin/index.html">official
docs</a> make clear):</p>
<ul>
<li>The internal reference fields need to use raw pointers, or near relatives
(e.g. <a name="a038"></a><a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html"><code>NonNull</code></a>) thereof.</li>
<li>The type being pinned needs to <em>not</em> implement the
<a name="a039"></a><a href="https://doc.rust-lang.org/std/marker/trait.Unpin.html"><code>Unpin</code></a> <a name="a040"></a>marker trait.  This trait is
automatically implemented for almost every type, so this typically involves adding a (zero-sized) field of type
<a name="a041"></a><a href="https://doc.rust-lang.org/std/marker/struct.PhantomPinned.html"><code>PhantomPinned</code></a> to the <a name="a042"></a><code>struct</code>
definition<sup><a name="to-footnote-5"><a href="borrows.html#footnote-5">5</a></a></sup>.</li>
<li>The item is only pinned once it's on the <a name="a043"></a>heap and held via <code>Pin</code>; in other words, only the contents of something
like <code>Pin&lt;Box&lt;MyType&gt;&gt;</code> is pinned. This means that the internal reference fields can only be safely filled in after
this point, but as they are raw pointers the compiler will give you no warning if you incorrectly set them <em>before</em>
calling <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.pin"><code>Box::pin</code></a>.</li>
</ul>
<p>Where possible, <strong>avoid self-referential data structures</strong> or try to find library crates that encapsulate the
difficulties for you (e.g. <a name="a044"></a><a href="https://crates.io/crates/ouroboros"><code>ouroborous</code></a>).</p>
<p><hr/>
<p><a name="footnote-1"><a href="borrows.html#to-footnote-1">1</a></a>: However, it may be ownership of
a <em>copy</em> of the item, if the <code>value</code>'s type is <a name="a006"></a><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>;
see <a href="std-traits.html">Item 5</a>.</p>
<p><a name="footnote-2"><a href="borrows.html#to-footnote-2">2</a></a>: Note that all bets are off with expressions like <code>m!(value)</code> that involve a <a name="a007"></a>macro (<a href="macros.html">Item 28</a>), because it can
expand to arbitrary code.</p>
<p><a name="footnote-3"><a href="borrows.html#to-footnote-3">3</a></a>: <code>Cow</code> stands for
copy-on-write; a copy of the underlying data is only made if a change (write) needs to be made to it.</p>
<p><a name="footnote-4"><a href="borrows.html#to-footnote-4">4</a></a>: Dealing with <code>async</code> code is beyond the scope of
this book; to understand more about its need for self-referential data structures, see chapter 8 of <a name="a035"></a><a href="https://rust-for-rustaceans.com/"><em>Rust for
Rustaceans</em></a> by <a name="a036"></a>Jon Gjengset.</p>
<p><a name="footnote-5"><a href="borrows.html#to-footnote-5">5</a></a>: In <a href="https://github.com/rust-lang/rust/issues/68318">future</a> it may be possible to just declare
<code>impl !Unpin for MyType {}</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-16-avoid-writing-unsafe-code"><a class="header" href="#item-16-avoid-writing-unsafe-code">Item 16: Avoid writing <code>unsafe</code> code</a></h1>
<p>The memory safety guarantees of Rust are its unique selling point; it is the Rust language feature that is not found in
any other mainstream language.  These guarantees come at a cost; writing Rust requires you to re-organize your code to
mollify the <a name="a001"></a>borrow checker (<a href="borrows.html">Item 15</a>), and to precisely specify the <a name="a002"></a>pointer types that you use (<a href="references.html">Item 9</a>).</p>
<p>Unsafe Rust weakens some of those guarantees, in particular by allowing the use of <em><a name="a003"></a>raw pointers</em> that work more
like old-style C pointers. These pointers are not subject to the borrowing rules, and the programmer is responsible for
ensuring that they still point to valid memory whenever they're used.</p>
<p>So at a superficial level, the advice of this Item is trivial: why move to Rust if you're just going to write C code in
Rust?  However, there are occasions where <a name="a004"></a><code>unsafe</code> code is absolutely required: for low-level library code, or for
when your Rust code has to interface with code in other languages (<a href="ffi.html">Item 34</a>).</p>
<p>The wording of this Item is quite precise, though: <strong>avoid <em>writing</em> <code>unsafe</code> code</strong>.  The emphasis is on the &quot;writing&quot;,
because much of the time the <code>unsafe</code> code you're likely to need has already been written for you.</p>
<p>The Rust standard libraries contain a lot of <code>unsafe</code> code; a quick search finds around 1000 uses of <code>unsafe</code> in the
<code>alloc</code> library, 1500 in <code>core</code> and a further 2000 in <code>std</code>. This code has been written by experts and is
battle-hardened by use in many thousands of Rust codebases.</p>
<p>Some of this <code>unsafe</code> code happens under the covers in standard library features that we've already covered:</p>
<ul>
<li>The <a name="a005"></a>smart pointer types â€“ <a name="a006"></a><code>Rc</code>, <a name="a007"></a><code>RefCell</code>, <a name="a008"></a><code>Arc</code> and friends â€“ described in
<a href="references.html">Item 9</a> use <code>unsafe</code> code (often raw pointers) internally in order to be able to present their particular semantics
to their users.</li>
<li>The synchronization primitives â€“ <a name="a009"></a><code>Mutex</code>, <a name="a010"></a><code>RwLock</code> and associated guards â€“ from <a href="deadlock.html">Item 17</a> use
<code>unsafe</code>, OS-specific code internally.</li>
</ul>
<p>The standard library<sup><a name="to-footnote-1"><a href="unsafe.html#footnote-1">1</a></a></sup> also has other functionality covering more advanced
features, implemented with <code>unsafe</code> internally:</p>
<ul>
<li><a name="a011"></a><a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>std::pin::Pin</code></a> forces an item to not move in memory
(<a href="lifetimes.html">Item 14</a>).  This allows self-referential data structures, often a <a href="https://rust-unofficial.github.io/too-many-lists/"><em>bÃªte
noire</em></a> for new arrivals to Rust.</li>
<li><a name="a012"></a><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>std::borrow::Cow</code></a> provides a clone-on-write smart
pointer: the same pointer can be used for both reading and writing, and a clone of the underlying data only happens if
and when a write occurs.</li>
<li>Various functions (<a name="a013"></a><a href="https://doc.rust-lang.org/stable/std/mem/fn.take.html"><code>take</code></a>,
<a name="a014"></a><a href="https://doc.rust-lang.org/stable/std/mem/fn.swap.html"><code>swap</code></a>,
<a name="a015"></a><a href="https://doc.rust-lang.org/stable/std/mem/fn.replace.html"><code>replace</code></a>) in
<a href="https://doc.rust-lang.org/stable/std/mem/index.html"><code>std::mem</code></a> allow items in memory to be manipulated without
falling foul of the <a name="a016"></a>borrow checker.</li>
</ul>
<p>These features may still need a little caution to be used correctly, but the <code>unsafe</code> code has been encapsulated in a
way that removes whole classes of problems.</p>
<p>Moving beyond the standard library, the <a name="a017"></a><a href="https://crates.io"><code>crates.io</code></a> ecosystem also includes many crates that
encapsulate <code>unsafe</code> code to provide a frequently-used feature.  For example:</p>
<ul>
<li><a name="a018"></a><a href="https://docs.rs/once_cell"><code>once_cell</code></a> provides a way to have something like global variables, initialized
exactly once.</li>
<li><a name="a019"></a><a href="https://docs.rs/rand"><code>rand</code></a> provides random number generation, making use of the lower-level underlying features
provided by the operating system and CPU.</li>
<li><a name="a020"></a><a href="https://docs.rs/byteorder"><code>byteorder</code></a> allows raw bytes of data to be converted to and from numbers.</li>
<li><a name="a021"></a><a href="https://docs.rs/cxx"><code>cxx</code></a> allows <a name="a022"></a>C++ code and Rust code to interoperate.</li>
</ul>
<p>There are many other examples, but hopefully the general idea is clear.  If you want to do something that doesn't
obviously fit with the constraints of Rust (especially <a href="borrows.html">Item 15</a> and <a href="lifetimes.html">Item 14</a>) hunt through the standard library to see
if there's existing functionality that does what you need.  If you don't find it, try also hunting through <code>crates.io</code>;
after all, most of the time your problem will not be a unique one that no-one else has ever faced before.</p>
<p>Of course there will always be places where <code>unsafe</code> is forced, for example when you need to interact with code written
in other languages via a foreign-function interface (<a name="a023"></a>FFI; see <a href="ffi.html">Item 34</a>).  But when it's necessary, <strong>consider writing a
wrapper layer that holds all the <code>unsafe</code> code</strong> that's required, so that other programmers can then follow the advice
of this Item.  This also helps to localize problems: when something goes wrong, the <code>unsafe</code> wrapper can be the first
suspect.</p>
<p>Also, if you're forced to write <code>unsafe</code> code, pay attention to the warning implied by the keyword itself: &quot;Hic sunt
dracones&quot;.</p>
<ul>
<li>Write even more tests (<a href="testing.html">Item 30</a>) than usual.</li>
<li>Run additional diagnostic tools (<a href="use-tools.html">Item 31</a>) over the code. In particular, <strong>run <a name="a024"></a>Miri over your <code>unsafe</code> code</strong> â€“
<a href="https://github.com/rust-lang/miri">Miri</a> interprets the intermediate level output from the compiler, which allows it
to detect classes of errors that are invisible to the Rust compiler.</li>
<li>Think about multi-threaded use, particularly if there's <a name="a025"></a>shared state (<a href="deadlock.html">Item 17</a>).</li>
</ul>
<p><hr/>
<p><a name="footnote-1"><a href="unsafe.html#to-footnote-1">1</a></a>: In practice, most of this<code>std</code> functionality is actually provided by <code>core</code>, and so is
available to <code>no_std</code> code as described in <a href="no-std.html">Item 33</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-17-be-wary-of-shared-state-parallelism"><a class="header" href="#item-17-be-wary-of-shared-state-parallelism">Item 17: Be wary of shared-state parallelism</a></h1>
<blockquote>
<p>&quot;Even the most daring forms of sharing are guaranteed safe in Rust.&quot; â€“ <a name="a001"></a><a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Aaron
Turon</a></p>
</blockquote>
<p>The official documentation describes Rust as enabling <a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">&quot;fearless
concurrency&quot;</a> but this Item will explore why (sadly) there are
still some <a name="a002"></a>reasons to be afraid.</p>
<p>This Item is specific to <em><a name="a003"></a>shared-state</em> parallelism: where different threads of execution communicate with each
other by sharing memory.</p>
<h2 id="data-races"><a class="header" href="#data-races">Data Races</a></h2>
<p>Let's start with the good news, by exploring <em><a name="a004"></a>data races</em> and Rust. The definition is roughly:</p>
<blockquote>
<p>A data race is defined to occur when two distinct threads access the same memory location, where</p>
<ul>
<li>at least one of them is a write, and</li>
<li>there is no synchronization mechanism that enforces an ordering on the accesses.</li>
</ul>
</blockquote>
<p>The basics of this are best illustrated with an example:</p>
<pre><code class="language-c++">// C++ code.
class BankAccount {
 public:
  BankAccount() : balance_(0) {}

  int64_t balance() const {
    return balance_;
  }
  void deposit(uint32_t amount) {
    balance_ += amount;
  }
  bool withdraw(uint32_t amount) {
    if (balance_ &lt; amount) {
      return false;
    }
    // What if another thread changes `balance_` at this point?
    std::this_thread::sleep_for(std::chrono::milliseconds(500));

    balance_ -= amount;
    return true;
  }

 private:
  int64_t balance_;
};
</code></pre>
<p>This example is in <a name="a005"></a>C++, not Rust, for reasons which will become clear shortly.  However, the same general concepts apply
in lots of other languages (that aren't Rust) â€“ <a name="a006"></a>Java, or <a name="a007"></a>Go, or <a name="a008"></a>Python â€¦</p>
<p>This class works fine in a single-threaded setting, but in a multi-threaded setting:</p>
<pre><code class="language-c++">  std::thread taker(take_out, &amp;account, 100);
  std::thread taker2(take_out, &amp;account, 100);
  std::thread taker3(take_out, &amp;account, 100);
  std::thread payer(pay_in, &amp;account, 300);
</code></pre>
<p>where several threads are repeatedly trying to withdraw from the account:</p>
<pre><code class="language-c++">int64_t check_balance(const BankAccount* account) {
    int64_t bal = account-&gt;balance();
    if (bal &lt; 0) {
      std::cerr &lt;&lt; &quot;** Oh no, gone overdrawn: &quot; &lt;&lt; bal &lt;&lt; &quot; **!\n&quot;;
      abort();
    }
    std::cout &lt;&lt; &quot;Balance now &quot; &lt;&lt; bal &lt;&lt; &quot;\n&quot;;
    return bal;
}
</code></pre>
<pre><code class="language-c++">void take_out(BankAccount* account, int count) {
  for (int ii = 0; ii &lt; count; ii++) {
    if (account-&gt;withdraw(100)) {
      log(&quot;Withdrew 100&quot;);
    } else {
      log(&quot;Failed to withdraw 100&quot;);
    }
    check_balance(account);
    std::this_thread::sleep_for(std::chrono::milliseconds(6));
  }
}
</code></pre>
<p>then eventually things will go wrong.</p>
<pre><code class="language-text">** Oh no, gone overdrawn: -100 **!
</code></pre>
<p>The problem isn't hard to spot, particularly with the helpful comment in the <code>withdraw()</code> method: when multiple threads
are involved, the value of the balance can change between the check and the modification. However, real-world <a name="a009"></a>bugs
of this sort are much harder to spot â€“ particularly if the compiler is allowed to perform all kinds of tricks and
re-orderings of code under the covers (as is the case for C++).</p>
<p>The <a name="a010"></a><code>sleep</code> call also artificially raises the chances of this bug being hit and thus detected early; when these problems
are encountered in the wild they're likely to occur rarely and intermittently â€“ making them very hard to debug.</p>
<p>The <code>BankAccount</code> class is <em><a name="a011"></a>thread-compatible</em>, which means that it can be used in a multithreaded environment as long
as the users of class ensure that access to it is governed by some kind of external synchronization mechanism.</p>
<p>The class can be converted to a <em><a name="a012"></a>thread-safe</em> class<sup><a name="to-footnote-1"><a href="deadlock.html#footnote-1">1</a></a></sup> â€“ meaning that it is safe to use from multiple threads â€“ by adding internal synchronization
operations:</p>
<pre><code class="language-c++">// C++ code.
class BankAccount {
 public:
  BankAccount() : balance_(0) {}

  int64_t balance() const {
    const std::lock_guard&lt;std::mutex&gt; with_lock(mu_);
    return balance_;
  }
  void deposit(uint32_t amount) {
    const std::lock_guard&lt;std::mutex&gt; with_lock(mu_);
    balance_ += amount;
  }
  bool withdraw(uint32_t amount) {
    const std::lock_guard&lt;std::mutex&gt; with_lock(mu_);
    if (balance_ &lt; amount) {
      return false;
    }
    // What if another thread changes `balance_` at this point?
    balance_ -= amount;
    return true;
  }

 private:
  mutable std::mutex mu_;
  int64_t balance_;
};
</code></pre>
<p>The internal <code>balance_</code> field is now protected by a <em>mutex</em> <code>mu_</code>: a synchronization object that ensures that only one
thread can successfully <code>lock()</code> at a time. The second and subsequent callers will block until <code>unlock()</code> is called
â€“ and even then, only <em>one</em> of the blocked threads will unblock and proceed through <code>lock()</code>.</p>
<p>All access to the balance now takes place with the mutex held, ensuring that its value is consistent between check and
modification. The <a name="a014"></a><a href="https://en.cppreference.com/w/cpp/thread/lock_guard"><code>std::lock_guard</code></a> is
also worth highlighting: it's an <a name="a015"></a>RAII class (cf. <a href="raii.html">Item 11</a>) that ensures that the mutex is unlocked when the scope
exits, reducing the chances of making a mistake around balancing manual <code>lock()</code> and <code>unlock()</code> calls.</p>
<p>However, the thread-safety here is still fragile; all it takes is one erroneous modification to the class:</p>
<pre><code class="language-c++">  bool transfer(BankAccount* destination, uint32_t amount) {
    // oops, forgot about mu_
    if (balance_ &lt; amount) {
      return false;
    }
    balance_ -= amount;
    destination-&gt;balance_ += amount;
    return true;
  }
</code></pre>
<p>and the thread-safety has been destroyed<sup><a name="to-footnote-2"><a href="deadlock.html#footnote-2">2</a></a></sup>.</p>
<p>For a book about Rust, this Item has covered a lot of C++, so consider a straightforward translation of this class into
Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub struct BankAccount {
        balance: i64,
    }

    impl BankAccount {
        pub fn new() -&gt; Self {
            BankAccount { balance: 0 }
        }
        pub fn balance(&amp;self) -&gt; i64 {
            self.balance
        }
        pub fn deposit(&amp;mut self, amount: i64) {
            self.balance += amount
        }
        pub fn withdraw(&amp;mut self, amount: i64) -&gt; bool {
            if self.balance &lt; amount {
                return false;
            }
            self.balance -= amount;
            true
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>This works fine in a single-threaded context â€“ even if that thread is not the main thread:</p>
<pre><code class="language-rust ignore">        let mut account = BankAccount::new();
        let payer = std::thread::spawn(move || pay_in(&amp;mut account, 30));
        // Wait for thread completion
        payer.join().unwrap();</code></pre>
<p>but a naÃ¯ve attempt to use the <code>BankAccount</code> across multiple threads:</p>
<pre><code class="language-rust ignore does_not_compile">        let mut account = BankAccount::new();
        let taker = std::thread::spawn(move || take_out(&amp;mut account, 100));
        let payer = std::thread::spawn(move || pay_in(&amp;mut account, 300));
        payer.join().unwrap();
        taker.join().unwrap();</code></pre>
<p>immediately falls foul of the compiler:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `account`
  --&gt; deadlock/src/main.rs:76:40
   |
74 |         let mut account = BankAccount::new();
   |             ----------- move occurs because `account` has type `broken::BankAccount`, which does not implement the `Copy` trait
75 |         let taker = std::thread::spawn(move || take_out(&amp;mut account, 100));
   |                                        -------               ------- variable moved due to use in closure
   |                                        |
   |                                        value moved into closure here
76 |         let payer = std::thread::spawn(move || pay_in(&amp;mut account, 300));
   |                                        ^^^^^^^             ------- use occurs due to use in closure
   |                                        |
   |                                        value used here after move
</code></pre>
<p>With experience of the <a name="a017"></a>borrow checker (<a href="borrows.html">Item 15</a>), the problem sticks out clearly: there are two mutable references
to the same item, one more than is allowed.  The rules of the borrow checker are that you can have a single mutable
reference to an item, or multiple (immutable) references, but not both at the same time.</p>
<p>This has a curious resonance with the definition of a data race at the start of this Item: enforcing that there is a
single writer, or multiple readers (but never both) means that there can be no data races.  By enforcing memory safety,
<a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Rust gets thead safety &quot;for free&quot;</a>.</p>
<p>As with C++, some kind of <a name="a018"></a>synchronization is needed to make this <code>struct</code> <a name="a019"></a>thread-safe. The most common
mechanism is also called <a name="a020"></a><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>, but the Rust version
&quot;wraps&quot; the protected data rather than being a standalone object (as in C++):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub struct BankAccount {
        balance: std::sync::Mutex&lt;i64&gt;,
    }
<span class="boring">}</span></code></pre></pre>
<p>The <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#method.lock"><code>lock()</code></a> method on this <code>Mutex</code> generic returns
a <a name="a021"></a><a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a> object with an RAII behaviour, like
C++'s <code>std::lock_guard</code>: the mutex is automatically released at the end of the scope when the guard is <code>drop</code>ped.
(Rust's <code>Mutex</code> has no manual lock/unlock methods, as they would expose developers to the danger of forgetting to keep
<code>lock()</code> and <code>unlock()</code> calls exactly in sync.)</p>
<p>The <code>MutexGuard</code> object also acts as a proxy for the data that is enclosed by the <code>Mutex</code>, by implementing the
<a name="a022"></a><code>Deref</code> and <a name="a023"></a><code>DerefMut</code> traits (<a href="references.html">Item 9</a>), allowing it to be used for both read operations:</p>
<pre><code class="language-rust ignore">        pub fn balance(&amp;self) -&gt; i64 {
            *self.balance.lock().unwrap()
        }</code></pre>
<p>and write operations:</p>
<pre><code class="language-rust ignore">        // Note: no longer needs `&amp;mut self`.
        pub fn deposit(&amp;self, amount: i64) {
            *self.balance.lock().unwrap() += amount
        }</code></pre>
<p>There's an interesting detail lurking in the signature of this method: although it is modifying the balance of the
<code>BankAccount</code>, this method now takes <code>&amp;self</code> rather than <code>&amp;mut self</code>.  This is inevitable: if multiple threads are going
to hold references to the same <code>BankAccount</code>, by the rules of the borrow checker those references had better not be
mutable.  It's also another instance of the <em><a name="a024"></a>interior mutability</em> pattern described in <a href="references.html">Item 9</a>: borrow checks are
effectively moved from compile-time to run-time, but now with a specific concern for cross-thread synchronization.</p>
<p>Wrapping up shared state in a <code>Mutex</code> mollifies the borrow checker, but there are still lifetime issues (<a href="lifetimes.html">Item 14</a>) to fix.</p>
<pre><code class="language-rust ignore does_not_compile">        {
            let account = BankAccount::new();
            let taker = std::thread::spawn(|| take_out(&amp;account, 100));
            let payer = std::thread::spawn(|| pay_in(&amp;account, 300));
        }</code></pre>
<pre><code class="language-text">error[E0373]: closure may outlive the current function, but it borrows `account`, which is owned by the current function
   --&gt; deadlock/src/main.rs:190:44
    |
190 |             let taker = std::thread::spawn(|| take_out(&amp;account, 100));
    |                                            ^^           ------- `account` is borrowed here
    |                                            |
    |                                            may outlive borrowed value `account`
    |
note: function requires argument type to outlive `'static`
   --&gt; deadlock/src/main.rs:190:25
    |
190 |             let taker = std::thread::spawn(|| take_out(&amp;account, 100));
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `account` (and any other referenced variables), use the `move` keyword
    |
190 |             let taker = std::thread::spawn(move || take_out(&amp;account, 100));
    |                                            ++++
error[E0373]: closure may outlive the current function, but it borrows `account`, which is owned by the current function
   --&gt; deadlock/src/main.rs:191:44
    |
191 |             let payer = std::thread::spawn(|| pay_in(&amp;account, 300));
    |                                            ^^         ------- `account` is borrowed here
    |                                            |
    |                                            may outlive borrowed value `account`
    |
note: function requires argument type to outlive `'static`
   --&gt; deadlock/src/main.rs:191:25
    |
191 |             let payer = std::thread::spawn(|| pay_in(&amp;account, 300));
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `account` (and any other referenced variables), use the `move` keyword
    |
191 |             let payer = std::thread::spawn(move || pay_in(&amp;account, 300));
    |                                            ++++
</code></pre>
<p>The error message makes the problem clear: the <code>BankAccount</code> is going to be <a name="a025"></a><code>drop</code>ped at the end of the
block, but there are two new threads which have a reference to it, and which will carry on running afterwards.</p>
<p>The standard tool for ensuring that an object remains active until all references to it are gone is a reference counted
pointer, and Rust's variant of this for multi-threaded use is
<a name="a026"></a><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>std::sync::Arc</code></a>:</p>
<pre><code class="language-rust ignore">        let account = std::sync::Arc::new(BankAccount::new());

        let account2 = account.clone();
        let taker = std::thread::spawn(move || take_out(&amp;account2, 100));

        let account3 = account.clone();
        let payer = std::thread::spawn(move || pay_in(&amp;account3, 300));</code></pre>
<p>Each thread gets its own (moved) copy of the reference counting pointer, and the underlying <code>BankAccount</code> will only be
<code>drop</code>ped when the refcount drops to zero. This combination of <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> is common in Rust programs that use
<a name="a027"></a>shared-state parallelism.</p>
<p>Stepping back from the technical details, observe that Rust has entirely avoided the problem of data races that plagues
multi-threaded programming in other languages.  Of course, this good news is restricted to <em>safe</em> Rust â€“
<a name="a028"></a><code>unsafe</code> code (<a href="unsafe.html">Item 16</a>) and FFI boundaries in particular (<a href="ffi.html">Item 34</a>) may not be data race free â€“ but it's
still a remarkable phenomenon.</p>
<h3 id="standard-marker-traits"><a class="header" href="#standard-marker-traits">Standard Marker Traits</a></h3>
<p>There are two standard traits that affect the use of Rust objects between threads.  Both of these traits are <em><a name="a029"></a>marker
traits</em> (<a href="std-traits.html">Item 5</a>) that have no associated methods, but they have special significance to the compiler in multi-threaded
scenarios.</p>
<ul>
<li>The <a name="a030"></a><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> trait indicates that items of a type are safe
to transfer between threads; ownership of an item of this type can be passed from one thread to another.</li>
<li>The <a name="a031"></a><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> trait indicates that items of a type can be
safely accessed by multiple threads, subject to the rules of the borrow checker.</li>
</ul>
<p>Another way of saying this is to observe that <code>Send</code> means <code>T</code> can be transferred between threads,
and <code>Sync</code> means that <code>&amp;T</code> can be transferred between threads.</p>
<p>Both of these traits are <a name="a032"></a><a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits"><strong>auto
traits</strong></a>: the compiler automatically
derives them for new types, as long as the constituent parts of the type are also <code>Send</code>/<code>Sync</code>.</p>
<p>The majority of safe types are <code>Send</code> and <code>Sync</code>, so much so that it's clearer to understand what types <em>don't</em>
implement these traits (written in the form <code>impl !Sync for Type</code>).</p>
<p>A non-<code>Send</code> type is one that can only be used in a single thread. The canonical example of this is the unsynchronized
reference counting pointer <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> (<a href="references.html">Item 9</a>).  The implementation of
this type explicitly assumes single-threaded use (for speed); there is no attempt at synchronizing the internal refcount
for multi-threaded use. As such, transferring an <code>Rc&lt;T&gt;</code> between threads is not allowed; use <code>Arc&lt;T&gt;</code> (with its
additional synchronization overhead) for this case.</p>
<p>A non-<code>Sync</code> type is one that's not safe to use from multiple threads via <strong>non-<code>mut</code></strong> references (as the borrow
checker will ensure there are never multiple <code>mut</code> references).  The canonical examples of this are the types that
provide <em>interior mutability</em> in an unsynchronized way, such as
<a name="a033"></a><a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a> and
<a name="a034"></a><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a>.  Use <code>Mutex&lt;T&gt;</code> or
<a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock&lt;T&gt;</code></a> to provide interior mutability in a multi-threaded
environment.</p>
<p>(Raw<a name="a035"></a> pointer types like <code>*const T</code> and <code>*mut T</code> are also neither <code>Send</code> nor <code>Sync</code>; see <a href="unsafe.html">Item 16</a> and
<a href="ffi.html">Item 34</a>.)</p>
<h2 id="deadlocks"><a class="header" href="#deadlocks">Deadlocks</a></h2>
<p>Now for the bad news.  Multi-threaded code comes with <em>two</em> terrible problems:</p>
<ul>
<li><strong><a name="a036"></a>data races</strong>, which can lead to corrupted data, and</li>
<li><strong><a name="a037"></a>deadlocks</strong>, which can lead to your program grinding to a halt.</li>
</ul>
<p>Both of these problems are terrible because they can be very hard to debug in practice: the failures occur
non-deterministically and are often more likely to happen under load â€“ which means that they don't show up in
<a name="a038"></a>unit tests, <a name="a039"></a>integration tests, or any other sort of test (<a href="testing.html">Item 30</a>), but they
do show up in production.</p>
<p>Rust has solved the problem of data races (as described above), but the problem of deadlocks applies to Rust as much as
it does to any other language that supports multi-threading.</p>
<p>Consider a simplified multiple player game server, implemented as a multithreaded application in order to service many
players in parallel.  Two core data structures might be a collection of players, indexed by username:</p>
<pre><code class="language-rust ignore">    players: Mutex&lt;HashMap&lt;String, Player&gt;&gt;,</code></pre>
<p>and a collection of games in progress indexed by some unique identifier:</p>
<pre><code class="language-rust ignore">    games: Mutex&lt;HashMap&lt;GameID, Game&gt;&gt;,</code></pre>
<p>Both of these data structures are <code>Mutex</code>-protected and so safe from data races; however, code that manipulates <em>both</em>
data structures opens up potential problems.  A single interaction between the two might work fine:</p>
<pre><code class="language-rust ignore">    fn add_and_join(&amp;self, username: &amp;str, info: Player) -&gt; Option&lt;GameID&gt; {
        // Add the new player.
        let mut players = self.players.lock().unwrap();
        players.insert(username.to_owned(), info);

        // Find a game with available space for them to join.
        let mut games = self.games.lock().unwrap();
        for (id, game) in games.iter_mut() {
            if game.add_player(username) {
                return Some(*id);
            }
        }
        None
    }</code></pre>
<p>However, a second interaction between the two independently locked data structures is where problems start:</p>
<pre><code class="language-rust ignore">    fn ban_player(&amp;self, username: &amp;str) {
        // Find all games that the user is in and remove them.
        let mut games = self.games.lock().unwrap();
        games
            .iter_mut()
            .filter(|(_id, g)| g.has_player(username))
            .for_each(|(_id, g)| g.remove_player(username));

        // Wipe them from the user list.
        let mut players = self.players.lock().unwrap();
        players.remove(username);
    }</code></pre>
<p>To understand the problem, imagine two separate threads using these two methods:</p>
<ul>
<li>Thread 1 enters <code>add_and_join()</code> and immediately acquires the <code>players</code> lock.</li>
<li>â€‚â€‚ Thread 2 enters <code>ban_player()</code> and immediately acquires the <code>games</code> lock.</li>
<li>Thread 1 now tries to acquire the <code>games</code> lock; this is held by thread 2, so thread 1 blocks.</li>
<li>â€‚â€‚ Thread 2 tries to acquire the <code>players</code> lock; this is held by thread 1, so thread 2 blocks.</li>
</ul>
<p>At this point the program is <strong><a name="a040"></a>deadlocked</strong>: neither thread will ever progress, and nor will any other thread that
does anything with either of the two <code>Mutex</code>-protected data structures.</p>
<p>The root cause of this is a <strong><a name="a041"></a>lock inversion</strong>: one function acquires the locks in the order <code>players</code> then <code>games</code>,
whereas the other uses the opposite order (<code>games</code> then <code>players</code>).  This is the simplest example of a more general
description of the problem:</p>
<ul>
<li>Build a <a name="a042"></a><a href="https://en.wikipedia.org/wiki/Directed_graph">directed graph</a> where:
<ul>
<li>Each <code>Mutex</code> instance is a vertex.</li>
<li>Each edge indicates a situation where one <code>Mutex</code> gets acquired while another <code>Mutex</code> is already held.</li>
</ul>
</li>
<li>If there are any cycles in the graph, a deadlock can occur.</li>
</ul>
<p>A simplistic attempt to solve this problem involves reducing the scope of the locks, so there is no point where both
locks are held at the same time:</p>
<pre><code class="language-rust ignore">    fn add_and_join(&amp;self, username: &amp;str, info: Player) -&gt; Option&lt;GameID&gt; {
        // Add the new player.
        {
            let mut players = self.players.lock().unwrap();
            players.insert(username.to_owned(), info);
        }

        // Find a game with available space for them to join.
        {
            let mut games = self.games.lock().unwrap();
            for (id, game) in games.iter_mut() {
                if game.add_player(username) {
                    return Some(*id);
                }
            }
        }
        None
    }
    fn ban_player(&amp;self, username: &amp;str) {
        // Find all games that the user is in and remove them.
        {
            let mut games = self.games.lock().unwrap();
            games
                .iter_mut()
                .filter(|(_id, g)| g.has_player(username))
                .for_each(|(_id, g)| g.remove_player(username));
        }

        // Wipe them from the user list.
        {
            let mut players = self.players.lock().unwrap();
            players.remove(username);
        }
    }</code></pre>
<p>(A better version of this would be to encapsulate the manipulation of the <code>players</code> data structure into <code>add_player()</code>
and <code>remove_player()</code> helper methods, to reduce the chances of forgetting to close out a scope.)</p>
<p>This solves the deadlock problem, but leaves behind a data consistency problem: the <code>players</code> and <code>games</code> data
structures can get out of sync with each other.</p>
<ul>
<li>Thread 1 enters <code>add_and_join(&quot;Alice&quot;)</code> and adds Alice to the <code>players</code> data structure (then releases the <code>players</code> lock).</li>
<li>â€‚â€‚ Thread 2 enters <code>ban_player(&quot;Alice&quot;)</code> and removes Alice from all <code>games</code> (then releases the <code>games</code> lock).</li>
<li>â€‚â€‚ Thread 2 now removes Alice from the <code>players</code> data structure; thread 1 has already released the lock so
this does not block.</li>
<li>Thread 1 now carries on and acquires the <code>games</code> lock (already released by thread 2). With the lock held, thread 1
adds &quot;Alice&quot; to a game in progress.</li>
</ul>
<p>At this point, there is a game that includes a player that doesn't exist, according to the <code>players</code> data structure!</p>
<p>The heart of the problem is that there are two data structures that need to be kept in sync with each other; the
best way to do this is to have a single sychronization primitive that covers both of them.</p>
<pre><code class="language-rust ignore">    struct GameState {
        players: HashMap&lt;String, Player&gt;,
        games: HashMap&lt;GameID, Game&gt;,
    }

    struct GameServer {
        state: Mutex&lt;GameState&gt;,
        // ...
    }</code></pre>
<h3 id="advice"><a class="header" href="#advice">Advice</a></h3>
<p>The most obvious advice for how to avoid the problems that come with <a name="a043"></a>shared-state parallelism is simply to avoid
shared-state parallelism.  The <a href="https://doc.rust-lang.org/book/ch16-02-message-passing.html">Rust book</a> quotes from the
<a href="https://golang.org/doc/effective_go.html#concurrency"><a name="a044"></a>Go language documentation</a>: &quot;Do not communicate by sharing
memory; instead, share memory by communicating&quot;.</p>
<p>The Go language has <a name="a045"></a><em>channels</em> that are suitable for this <a href="https://go.dev/ref/spec#Channel_types">built into the
language</a>; for Rust, equivalent functionality is included in the standard library
in the <a name="a046"></a><a href="https://doc.rust-lang.org/std/sync/mpsc/index.html"><code>std::sync::mpsc</code> module</a>: the <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html"><code>channel()</code>
function</a> returns a <code>(Sender, Receiver)</code> pair that allows
values of a particular type to be communicated between threads.</p>
<p>If shared-state concurrency can't be avoided, then there are some ways to reduce the chances of writing deadlock-prone
code:</p>
<ul>
<li><strong>Put data structures that must be kept consistent with each other under a single lock</strong>.</li>
<li><strong>Keep lock scopes small and obvious</strong>; wherever possible, use helper methods that get and set things under the
relevant lock.</li>
<li><strong>Avoid invoking closures with locks held</strong>; this puts the code at the mercy of whatever closure gets added to the
codebase in the future.</li>
<li>Similarly, <strong>avoid returning a <code>MutexGuard</code> to a caller</strong>: it's like handing out a loaded gun from a deadlock
perspective.</li>
<li><strong>Include deadlock detection tools</strong> in your CI system (<a href="ci.html">Item 32</a>), such as
<a name="a047"></a><a href="https://docs.rs/no_deadlocks"><code>no_deadlocks</code></a>,
<a name="a048"></a><a href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a>, or
<a name="a049"></a><a href="https://amanieu.github.io/parking_lot/parking_lot/deadlock/index.html"><code>parking_lot::deadlock</code></a>.</li>
<li>As a last resort: design, document, test and police a <em><a name="a050"></a>locking hierarchy</em> that describes what lock orderings are
allowed/required. This should be a last resort because any strategy that relies on engineers never making a mistake is
obviously doomed to failure in the long term.</li>
</ul>
<p>More abstractly, multi-threaded code is an ideal place to apply the general advice: prefer code that's so simple that
it is obviously not wrong, rather than code that's so complex that it's not obviously wrong.</p>
<p><hr/>
<p><a name="footnote-1"><a href="deadlock.html#to-footnote-1">1</a></a>: The third category of behaviour is
<em><a name="a013"></a>thread-hostile</em>: code that's dangerous in a multithreaded environment <em>even if</em> all access to it is externally
synchronized.</p>
<p><a name="footnote-2"><a href="deadlock.html#to-footnote-2">2</a></a>: The <a name="a016"></a>Clang C++ compiler includes a
<a href="https://clang.llvm.org/docs/ThreadSafetyAnalysis.html"><code>-Wthread-safety</code></a> option, sometimes known as <em>annotalysis</em>,
that allows data to be annotated with information about which mutexes protect which data, and functions to be annotated
with information about the locks they acquire. This gives <em>compile-time</em> errors when these invariants are broken, like
Rust; however, there is nothing to enforce the use of these annotations in the first place â€“ for example, when a
thread-compatible library is used in a multi-threaded environment for the first time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-18-dont-panic"><a class="header" href="#item-18-dont-panic">Item 18: Don't panic</a></h1>
<blockquote>
<p>&quot;It looked insanely complicated, and this was one of the reasons why the snug plastic cover it fitted into had the
words DONâ€™T PANIC printed on it in large friendly letters.&quot; â€“ <a name="a001"></a>Douglas Adams</p>
</blockquote>
<p>The title of this Item would be more accurately described as: <strong>prefer returning a <a name="a002"></a><code>Result</code> to using
<a name="a003"></a><code>panic!</code></strong> (but <strong>don't panic</strong> is much catchier).</p>
<p>The first thing to understand about Rust's panic system is that it is <em>not</em> equivalent to an <a name="a004"></a>exception system (like the
ones in <a name="a005"></a>Java or <a name="a006"></a>C++), even though there appears to be a <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html">mechanism for catching
panics</a> at a point further up the call stack.</p>
<p>Consider a function that panics on an invalid input:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(a: i64, b: i64) -&gt; i64 {
    if b == 0 {
        panic!(&quot;Cowardly refusing to divide by zero!&quot;);
    }
    a / b
}
<span class="boring">}</span></code></pre></pre>
<p>Trying to invoke this with an invalid input fails as expected:</p>
<pre><code class="language-rust ignore">    // Attempt to discover what 0/0 is...
    let result = divide(0, 0);</code></pre>
<pre><code class="language-text">thread 'main' panicked at 'Cowardly refusing to divide by zero!', panic/src/main.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>A wrapper that uses
<a name="a007"></a><a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>std::panic::catch_unwind</code></a> to catch the
panic</p>
<pre><code class="language-rust ignore">fn divide_recover(a: i64, b: i64, default: i64) -&gt; i64 {
    let result = std::panic::catch_unwind(|| divide(a, b));
    match result {
        Ok(x) =&gt; x,
        Err(_) =&gt; default,
    }
}</code></pre>
<p><em>appears</em> to work:</p>
<pre><code class="language-rust ignore">    let result = divide_recover(0, 0, 42);
    println!(&quot;result = {}&quot;, result);</code></pre>
<pre><code class="language-text">result = 42
</code></pre>
<p>Appearances can be deceptive, however.  The first problem with this approach is that panics don't always unwind; there
is a <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#panic">compiler option</a> (which is also accessible via a
<a name="a008"></a><code>Cargo.toml</code> <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#panic">profile setting</a>) that shifts panic
behaviour so that it immediately aborts the process.</p>
<pre><code class="language-text">thread 'main' panicked at 'Cowardly refusing to divide by zero!', panic/src/main.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
Abort trap: 6
</code></pre>
<p>This leaves any attempt to simulate exceptions entirely at the mercy of the wider project settings. It's also the case
that some target platforms (for example <a name="a009"></a>WebAssembly) <em>always</em> abort on panic, regardless of any compiler or
project settings.</p>
<p>A more subtle problem that's surfaced by panic handling is <a href="https://en.wikipedia.org/wiki/Exception_safety"><em><a name="a010"></a>exception
safety</em></a>: if a panic occurs midway through an operation on a data
structure, it removes any guarantees that the data structure has been left in a self-consistent state.  Preserving
internal invariants in the presence of exceptions has been known to be extremely difficult since the 1990s <sup><a name="to-footnote-1"><a href="panic.html#footnote-1">1</a></a></sup>; this is one of the main reasons why <a href="https://google.github.io/styleguide/cppguide.html#Exceptions">Google (famously) bans the use of
exceptions in its C++ code</a>.</p>
<p>Finally, panic propagation also <a href="https://doc.rust-lang.org/nomicon/ffi.html#ffi-and-panics">interacts poorly</a> with
<a name="a013"></a>FFI (foreign function interface) boundaries (<a href="ffi.html">Item 34</a>); <strong>use <code>catch_unwind</code> to prevent panics in Rust code from
propagating to non-Rust calling code</strong> across an FFI boundary.</p>
<p>So what's the alternative to <code>panic!</code> for dealing with error conditions?  For library code, the best alternative is to
make the error <a href="https://en.wikipedia.org/wiki/Somebody_else%27s_problem">someone else's problem</a>, by returning a
<a name="a014"></a><code>Result</code> with an appropriate error type (<a href="errors.html">Item 4</a>).  This allows the library user to make their own decisions
about what to do next â€“ which may involve passing the problem on to the next caller in line, via the <code>?</code> operator.</p>
<p>The buck has to stop somewhere, and a useful rule of thumb is that it's OK to <code>panic!</code> (or to <code>unwrap()</code>, <code>expect()</code>
etc.) if you have control of <a name="a015"></a><code>main</code>; at that point, there's no further caller that the buck could be passed to.</p>
<p>Another sensible use of <code>panic!</code>, even in library code, is in situations where it's very rare to encounter errors, and
you don't want users to have to litter their code with <code>.unwrap()</code> calls.</p>
<p>If an error situation <em>should</em> only occur because (say) internal data is corrupted, rather than as a result of invalid
inputs, then triggering a <code>panic!</code> is legitimate.</p>
<p>It can even be occasionally useful to allow panics that can be triggered by invalid input, but where such invalid inputs
are out of the ordinary.  This works best when the relevant entrypoints come in pairs:</p>
<ul>
<li>an &quot;<a name="a016"></a>infallible&quot; version whose signature implies it always succeeds (and which panics if it can't succeed),</li>
<li>a &quot;<a name="a017"></a>fallible&quot; version that returns a <code>Result</code>.</li>
</ul>
<p>For the former, Rust's <a href="https://rust-lang.github.io/api-guidelines/documentation.html#function-docs-include-error-panic-and-safety-considerations-c-failure">API guidelines
suggest</a>
that the <code>panic!</code> should be documented in a specific section of the inline documentation (<a href="documentation.html">Item 27</a>).</p>
<p>The
<a name="a018"></a><a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8_unchecked"><code>String::from_utf8_unchecked</code></a>
/ <a name="a019"></a><a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8"><code>String::from_utf8</code></a>
entrypoints in the standard library are an example of the latter (although in this case, the panics are actually
deferred to the point where a <code>String</code> constructed from invalid input gets usedâ€¦).</p>
<p>Assuming that you are trying to comply with the advice of this item, there are a few things to bear in mind.  The first
is that <code>panic</code>s can appear in different guises; avoiding <code>panic!</code> also involves avoiding:</p>
<ul>
<li><a name="a020"></a><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>unwrap()</code></a> and
<a name="a021"></a><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_err"><code>unwrap_err()</code></a></li>
<li><a name="a022"></a><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect()</code></a> and
<a name="a023"></a><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect_err"><code>expect_err()</code></a></li>
<li><a name="a024"></a><a href="https://doc.rust-lang.org/std/macro.unreachable.html"><code>unreachable!()</code></a></li>
</ul>
<p>Harder to spot are things like:</p>
<ul>
<li><code>slice[index]</code> when the index is out of range</li>
<li><code>x / y</code> when <code>y</code> is zero.</li>
</ul>
<p>The second observation around avoiding <code>panic</code>s is that a plan that involves <a name="a025"></a>constant
vigilance of humans is never a good idea.</p>
<p>However, constant vigilance of machines is another matter: adding a check to your continuous integration (<a href="ci.html">Item 32</a>)
system that spots new panics is much more reliable.  A simple version could be a simple grep for the most common
panicking entrypoints (as above); a more thorough check could involve additional tooling from the Rust ecosystem
(<a href="use-tools.html">Item 31</a>), such as setting up a build variant that pulls in the <a name="a026"></a><a href="https://docs.rs/no-panic"><code>no_panic</code></a> crate.</p>
<p><hr/>
<p><a name="footnote-1"><a href="panic.html#to-footnote-1">1</a></a>: <a name="a011"></a>Tom Cargill's 1994 <a href="https://ptgmedia.pearsoncmg.com/imprint_downloads/informit/aw/meyerscddemo/DEMO/MAGAZINE/CA_FRAME.HTM">article in the <em>C++
Report</em></a> explored
just how difficult exception safety is for C++ template code, as did <a name="a012"></a>Herb Sutter's <a href="http://www.gotw.ca/gotw/008.htm">Guru of the Week
#8</a> column.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-19-avoid-reflection"><a class="header" href="#item-19-avoid-reflection">Item 19: Avoid reflection</a></h1>
<p>Programmers coming to Rust from other languages are often used to reaching for <a name="a001"></a>reflection as a tool in their toolbox.
They can waste a lot of time trying to implement reflection-based designs in Rust, only to discover that what they're
attempting can only be done poorly, if at all.  This Item hopes to save that time wasted exploring dead-ends, by
describing what Rust does and doesn't have in the way of reflection, and what can be used instead.</p>
<p><em>Reflection</em> is the ability of a program to examine itself at run-time.  Given an item at run-time, it covers:</p>
<ul>
<li>What information can be determined about the item's type?</li>
<li>What can be done with that information?</li>
</ul>
<p>Programming languages with full reflection support have extensive answers to these questions â€“ as well as
determining an item's type at run-time, its contents can be explored, its fields modified and its methods invoked.
Languages that have this level of reflection support <em>tend</em> to be dynamically typed languages (e.g.
<a href="https://docs.python.org/3/library/types.html#module-types"><a name="a002"></a>Python</a>, Ruby), but there are also some notable statically
typed languages that also support this, particularly
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html"><a name="a003"></a>Java</a>
and <a href="https://golang.org/pkg/reflect/"><a name="a004"></a>Go</a>.</p>
<p>Rust does not support this type of reflection, which makes the advice to <strong>avoid reflection</strong> easy to follow at this
level â€“ it's just not possible.  For programmers coming from languages with support for full reflection, this
absence may seem like a significant gap at first, but Rust's other features provide alternative ways of solving many of
the same problems.</p>
<p><a name="a005"></a>C++ has a more limited form of reflection, known as <em>run-time type identification</em> (<a name="a006"></a>RTTI).  The
<a name="a007"></a><a href="https://en.cppreference.com/w/cpp/language/typeid"><code>typeid</code></a> operator returns a unique identifier
for every type, for objects of <em>polymorphic type</em> (roughly: classes with virtual functions):</p>
<ul>
<li><code>typeid</code> can recover the concrete class of an object referred to via a base class reference</li>
<li><a name="a008"></a><a href="https://en.cppreference.com/w/cpp/language/dynamic_cast"><code>dynamic_cast&lt;T&gt;</code></a> allows base
class references to be converted to derived classes, when it is safe and correct to do so.</li>
</ul>
<p>Rust does not support this RTTI style of reflection either, continuing the theme that the advice of this Item is easy to
follow.</p>
<p>Rust does support some features that provide <em>similar</em> functionality (in the
<a href="https://doc.rust-lang.org/std/any/index.html"><code>std::any</code></a> module), but they're limited (in ways explored below) and so
best avoided unless no other alternatives are possible.</p>
<p>The first reflection-like feature <em>looks</em> magic at first â€“ a way of determining the name of an item's type:</p>
<pre><code class="language-rust ignore">    let x = 42u32;
    let y = Square::new(3, 4, 2);
    println!(&quot;x: {} = {}&quot;, tname(&amp;x), x);
    println!(&quot;y: {} = {:?}&quot;, tname(&amp;y), y);</code></pre>
<pre><code class="language-text">x: u32 = 42
y: reflection::Square = Square { top_left: Point { x: 3, y: 4 }, size: 2 }
</code></pre>
<p>The implementation of <code>tname()</code> reveals what's up the compiler's sleeve; the function is <a name="a009"></a>generic
(as per <a href="generics.html">Item 12</a>) and so each invocation of it is actually a <a name="a010"></a>different function (<code>tname::&lt;u32&gt;</code>
or <code>tname::&lt;Square&gt;</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn tname&lt;T: ?Sized&gt;(_v: &amp;T) -&gt; &amp;'static str {
    std::any::type_name::&lt;T&gt;()
}
<span class="boring">}</span></code></pre></pre>
<p>The <a name="a011"></a><a href="https://doc.rust-lang.org/std/any/fn.type_name.html"><code>std::any::type_name&lt;T&gt;</code></a> library function
only has access to <em>compile-time</em> information; nothing clever is happening at run-time.</p>
<p>The string returned by <code>type_name</code> is only suitable for diagnostics â€“ it's explicitly a &quot;best-effort&quot; helper whose
contents may change, and may not be unique â€“ so <strong>don't attempt to parse <code>type_name</code> results</strong>. If you need a
globally unique type identifier, use <a name="a012"></a><a href="https://doc.rust-lang.org/std/any/struct.TypeId.html"><code>TypeId</code></a> instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::any::TypeId;

fn type_id&lt;T: 'static + ?Sized&gt;(_v: &amp;T) -&gt; TypeId {
    TypeId::of::&lt;T&gt;()
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-rust ignore">    println!(&quot;x has {:?}&quot;, type_id(&amp;x));
    println!(&quot;y has {:?}&quot;, type_id(&amp;y));</code></pre>
<pre><code class="language-text">x has TypeId { t: 14816064564273904734 }
y has TypeId { t: 7700407161019666586 }
</code></pre>
<p>The output is less helpful for humans, but the guarantee of uniqueness means that the result can be used in code.
However, it's usually best not to do so directly, but to use the
<a name="a013"></a><a href="https://doc.rust-lang.org/std/any/trait.Any.html"><code>std::any::Any</code></a> trait<sup><a name="to-footnote-1"><a href="reflection.html#footnote-1">1</a></a></sup> instead.</p>
<p>This trait has a single method <a href="https://doc.rust-lang.org/std/any/trait.Any.html#tymethod.type_id"><code>type_id()</code></a>, which
returns the <code>TypeId</code> value for the type that implements the trait. You can't implement this trait yourself though,
because <code>Any</code> already comes with a <a name="a014"></a>blanket implementation for every type <code>T</code>:</p>
<pre><code class="language-rust ignore">impl&lt;T: 'static + ?Sized&gt; Any for T {
    fn type_id(&amp;self) -&gt; TypeId {
        TypeId::of::&lt;T&gt;()
    }
}</code></pre>
<p>Recall from <a href="references.html">Item 9</a> that a <a name="a015"></a>trait object is a <a name="a016"></a>fat pointer that holds a pointer to the underlying item,
together with a pointer to the trait implementation's <a name="a017"></a>vtable.  For <code>Any</code>, the vtable has a single entry, for a
method that returns the item's type.</p>
<pre><code class="language-rust ignore">    let x_any: Box&lt;dyn Any&gt; = Box::new(42u64);
    let y_any: Box&lt;dyn Any&gt; = Box::new(Square::new(3, 4, 3));</code></pre>
<img alt="Any trait objects, each with pointers to concrete items and vtables" src="images/anytraitobj.svg" width=756>
<p>Modulo a couple of indirections, a <code>dyn Any</code> trait object is effectively a combination of a raw pointer and a type
identifier.  This means that <code>Any</code> can offer some additional <a name="a018"></a>generic methods:</p>
<ul>
<li><a name="a019"></a><a href="https://doc.rust-lang.org/std/any/trait.Any.html#method.is"><code>is&lt;T&gt;</code></a> to indicate whether the trait
object's type is equal to some specific other type <code>T</code>.</li>
<li><a name="a020"></a><a href="https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_ref"><code>downcast_ref&lt;T&gt;</code></a> which
returns a reference to the concrete type <code>T</code>, provided that the type matches.</li>
<li><a name="a021"></a><a href="https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_mut"><code>downcast_mut&lt;T&gt;</code></a> for the
mutable variant of <code>downcast_ref</code>.</li>
</ul>
<p>Observe that the <code>Any</code> trait is only approximating reflection functionality: the programmer chooses (at compile-time) to
explicitly build something (<code>&amp;dyn Any</code>) that keeps track of an item's compile-time type as well as its location. The
ability to (say) downcast back to the original type is only possible if the overhead of building an <code>Any</code> trait object
has happened.</p>
<p>There are comparatively few scenarios where Rust has different compile-time and run-time types associated with an
item.  Chief among these is <em><a name="a022"></a>trait objects</em>: an item of a concrete type <code>Square</code> can be coerced into a trait object
<code>dyn Shape</code> for a trait that the type implements.  This coercion builds a fat pointer (object+vtable) from a simple
pointer (object/item).</p>
<p>Recall also from <a href="generics.html">Item 12</a> that Rust's trait objects are not really <a name="a023"></a>object-oriented.  It's not the case that a
<code>Square</code> <strong>is-a</strong> <code>Shape</code>, it's just that a <code>Square</code> implements <code>Shape</code>'s interface.  The same is true for <a name="a024"></a>trait
bounds: a trait bound <code>Shape: Drawable</code> does <em>not</em> mean <a name="a025"></a><strong>is-a</strong>, it just means
<strong><a name="a026"></a>also-implements</strong>; the vtable for <code>Shape</code> includes the entries for the methods of <code>Drawable</code>.</p>
<p>For some simple trait bounds:</p>
<pre><code class="language-rust ignore">trait Drawable: Debug {
    fn bounds(&amp;self) -&gt; Bounds;
}

trait Shape: Drawable {
    fn render_in(&amp;self, bounds: Bounds);
    fn render(&amp;self) {
        self.render_in(overlap(SCREEN_BOUNDS, self.bounds()));
    }
}</code></pre>
<p>the equivalent trait objects:</p>
<pre><code class="language-rust ignore">    let square = Square::new(1, 2, 2);
    let draw: &amp;dyn Drawable = &amp;square;
    let shape: &amp;dyn Shape = &amp;square;</code></pre>
<p>have a layout whose arrows make the problem clear: given a <code>dyn Shape</code> object, there's no way to build a <code>dyn Drawable</code>
trait object, because there's no way to get back to the <a name="a027"></a>vtable for <code>impl Drawable for Square</code> â€“ even though the
relevant parts of its contents (the address of the <code>Square::bounds</code> method) <em>is</em> theoretically recoverable.</p>
<p><img alt="Trait objects for trait bounds, with distinct vtables for Shape and Square" src="images/traitbounds.svg"
width=714></p>
<p>Comparing with the previous diagram, it's also clear that an explicitly constructed <code>&amp;dyn Any</code> trait object doesn't help.
<code>Any</code> allows recovery of the original concrete type of the underlying item, but there is no run-time way to
see what traits it implement, nor to get access to the relevant vtable that might allow creation of a trait object.</p>
<p>So what's available instead?</p>
<p>The primary tool to reach for is trait definitions, and this is in line with advice for other languages â€“
<a name="a028"></a><em>Effective Java</em> Item 65 recommends &quot;Prefer interfaces to reflection&quot;.  If code needs to rely on certain behaviour being
available for an item, encode that behaviour as a <a name="a029"></a>trait (<a href="use-types-2.html">Item 2</a>). Even if the desired behaviour can't be expressed
as a set of method signatures, use marker traits to indicate compliance with the desired behaviour â€“ it's safer
and more efficient than (say) introspecting the name of a class to check for a particular prefix.</p>
<p>Code that expects trait objects can also be used with objects whose backing code was not available at program link time,
because it has been dynamically loaded at run-time (via <a name="a030"></a><code>dlopen(3)</code> or equivalent) â€“ which means that
<a name="a031"></a>monomorphization of a <a name="a032"></a>generic (<a href="generics.html">Item 12</a>) isn't possible.</p>
<p>Relatedly, reflection is sometimes also used in other languages to allow multiple incompatible versions of the same
dependency library to be loaded into the program at once, bypassing linkage constraints that <a name="a033"></a>There Can Be Only
One. This is not needed in Rust, where <a name="a034"></a>Cargo already copes with multiple versions of the same library (<a href="dep-graph.html">Item 25</a>).</p>
<p>Finally, <a name="a035"></a>macros â€“ especially <a name="a036"></a> <code>derive</code> macros â€“ can be used to auto-generate
ancillary code that understands an item's type at compile-time, as a more efficient and more type-safe equivalent to
code that parses an item's contents at run-time.</p>
<p><hr/>
<p><a name="footnote-1"><a href="reflection.html#to-footnote-1">1</a></a>: The C++ equivalent of
<code>Any</code> is <a href="https://en.cppreference.com/w/cpp/utility/any"><code>std::any</code></a>, and <a href="https://abseil.io/tips/194">advice is to avoid it
too</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-20-avoid-the-temptation-to-over-optimize"><a class="header" href="#item-20-avoid-the-temptation-to-over-optimize">Item 20: Avoid the temptation to over-optimize</a></h1>
<blockquote>
<p>&quot;Just because Rust <em>allows</em> you to write super cool non-allocating zero-copy algorithms safely, doesnâ€™t mean <em>every</em>
algorithm you write should be super cool, zero-copy and non-allocating.&quot; â€“
<a href="https://users.rust-lang.org/t/feeling-rust-is-so-difficult/29962/15">trentj</a></p>
</blockquote>
<!--

??? donâ€™t overoptimize

cf. Josh Triplettâ€™s tweet about just spraying Arcs everywhere
https://twitter.com/josh_triplett/status/1316634757170515968
from https://users.rust-lang.org/t/feeling-rust-is-so-difficult/29962/15


??? particularly the point about comparisons with other languages... Rust makes a .clone() explicit, other languages
don't. ... remember as an early C++ program when you add a printf or a breakpoint on a copy constructor to discover just
how often they're called  ... alternative is to share references and you know where that goes

progression of accepting arguments to fn .. &Vec<u8> ... compiler/clippy warns that this is too specific ... &[u8]
... nice goldilocks point ... accepts normal ref, but also smart pointers that implement the Deref trait ([Item 9](references.md))
which the compiler automatically uses ... AsRef<[u8]> ... the most general, but requires generics ... makes the implementation
need use of as_ref()

cf. use of borrow vs ToOwned as in [Item 9](references.md) ?

follow standard library as example

grep std lib for `AsRef<[u8]>` vs `&[u8]`

AsRef needed for generics not normal function use?

contrast with [Item 33](no-std.md) ... by making things more complicated can work in `no_std` better, without too much impact on
users in the `std` world.

premature optimization ... measure first

Rust has explicit clone ... similar code in C++ does operator= or copy-constructs under the covers... so Rust is no less -->
<!--efficient, you can just see it ... cross-comparison code

-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h1>
<blockquote>
<p>&quot;When the Gods wish to punish us, they answer our prayers.&quot; â€“ <a name="a001"></a>Oscar Wilde</p>
</blockquote>
<p>For decades, the idea of code reuse was merely a dream.  The idea that code could be written once, packaged into a
library and re-used across many different applications was an ideal, only realized for a few standard libraries and for
corporate in-house tools.</p>
<p>The growth of the Internet, and the rise of open-source software finally changed that. The first openly accessible
repository that held a wide collection of useful libraries, tools and helpers, all packaged up for easy re-use, was
<a name="a002"></a><a href="https://en.wikipedia.org/wiki/CPAN">CPAN</a>: the Comprehensive Perl Archive Network, online since 1995.  By the
present day, almost every modern language<sup><a name="to-footnote-1"><a href="deps.html#footnote-1">1</a></a></sup> has a comprehensive collection of open-source libraries available, housed in a package
repository that makes the process of adding a new dependency easy and quick.</p>
<p>However, new problems come along with that ease, convenience and speed.  It's <em>usually</em> still easier to re-use existing
code than to write it yourself, but there are potential pitfalls and risks that come along with dependencies on someone
else's code.  This part of the book will help you be aware of these.</p>
<p>The focus is specifically on Rust, and with it use of the <a name="a003"></a><a href="https://doc.rust-lang.org/cargo"><code>cargo</code></a> tool,
but many of the concerns, topics and issues covered apply equally well to other languages.</p>
<p><hr/>
<p><a name="footnote-1"><a href="deps.html#to-footnote-1">1</a></a>: With the notable exception of C and C++, where package management
remains somewhat fragmented.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-21-understand-what-semantic-versioning-promises"><a class="header" href="#item-21-understand-what-semantic-versioning-promises">Item 21: Understand what semantic versioning promises</a></h1>
<blockquote>
<p>&quot;If we acknowledge that SemVer is a lossy estimate and represents only a subset of the possible scope of changes, we
can begin to see it as a blunt instrument.&quot; â€“ <a name="a001"></a>Titus Winters, &quot;<a href="https://abseil.io/resources/swe-book/html/ch21.html#the_limitations_of_semver">Software Engineering at
Google</a>&quot;</p>
</blockquote>
<p><a name="a002"></a>Cargo, Rust's package manager, allows automatic selection of dependencies (<a href="dep-graph.html">Item 25</a>) for Rust code according to
<em><a name="a003"></a>semantic versioning</em> (semver).  A <a name="a004"></a><code>Cargo.toml</code> stanza like</p>
<pre><code class="language-toml">[dependencies]
serde = &quot;1.0.*&quot;
</code></pre>
<p>indicates to <code>cargo</code> what ranges of semver versions are acceptable for this dependency (see the <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">official
docs</a> for more detail on specifying precise
ranges of acceptable versions).</p>
<p>When choosing dependency versions, Cargo will then generally pick the most recent version that's within the combination
of all of these semver ranges.  However, if the <a name="a005"></a><a href="https://doc.rust-lang.org/cargo/reference/unstable.html#minimal-versions"><code>-Z minimal-versions</code>
flag</a> is passed to Cargo, it will instead pick
the <em>oldest</em> version of each dependency that satisfies the semver ranges; <strong>consider including a <code>-Z minimal-versions</code>
build</strong> in your CI system (<a href="ci.html">Item 32</a>) to confirm that the lower bounds of the semver ranges are accurate.</p>
<p>Because semantic versioning is at the heart of <code>cargo</code>'s dependency resolution process, this Item explores more
details about what that means.</p>
<p>The essentials of semantic versioning are given by its <a href="https://semver.org/#summary">summary</a></p>
<blockquote>
<p>Given a version number MAJOR.MINOR.PATCH, increment the:</p>
<ul>
<li>MAJOR version when you make incompatible API changes,</li>
<li>MINOR version when you add functionality in a backwards compatible manner, and</li>
<li>PATCH version when you make backwards compatible bug fixes.</li>
</ul>
</blockquote>
<p>An important detail lurks in the <a href="https://semver.org/#spec-item-3">details</a>:</p>
<blockquote>
<ol start="3">
<li>Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications
MUST be released as a new version.</li>
</ol>
</blockquote>
<p>Putting this in different words:</p>
<ul>
<li>Changing <em>anything</em> requires a new PATCH version.</li>
<li><em>Adding</em> things to the API in a way that means existing users of the crate still compile and work requires a MINOR
version upgrade.</li>
<li><em>Removing</em> or <em>changing</em> things in the API requires a MAJOR version upgrade.</li>
</ul>
<p>There is one more important <a href="https://semver.org/#spec-item-3">codicil</a> to the semver rules:</p>
<blockquote>
<ol start="4">
<li>Major version zero (0.y.z) is for initial development. Anything MAY change at any time. The public API SHOULD NOT
be considered stable.</li>
</ol>
</blockquote>
<p>Cargo adapts these rules slightly, &quot;left-shifting&quot; the rules so that changes in the left-most non-zero component
indicate incompatible changes.  This means that 0.2.3 to 0.3.0 can include an incompatible API change, as can 0.0.4 to
0.0.5.</p>
<h2 id="semver-for-crate-authors"><a class="header" href="#semver-for-crate-authors">Semver for Crate Authors</a></h2>
<blockquote>
<p>&quot;In theory, theory is the same as practice. In practice, it's not.&quot;</p>
</blockquote>
<p>As a crate author, the first of these rules is easy to comply with, in theory: if you touch anything, you need a new
release. Using <a name="a006"></a>Git <a href="https://git-scm.com/docs/git-tag"><em>tags</em></a> to match releases can help with this
â€“ by default, a tag is fixed to a particular commit and can only be moved with a manual <code>--force</code> option. Crates
published to <a name="a007"></a><a href="https://crates.io"><code>crates.io</code></a> also get automatic policing of this, as the registry will reject a
second attempt to publish the same crate version. The main danger for non-compliance is when you notice a mistake <em>just
after</em> a release has gone out, and you have to resist the temptation to just nip in a fix.</p>
<p>However, if your crate is widely depended on, then in practice you may need to be aware of <a name="a008"></a><a href="https://www.hyrumslaw.com/">Hyrum's
Law</a>: regardless of how minor a change you make to the code, someone out there is likely
to depend on the old behaviour.</p>
<p>The difficult part for crate authors is the later rules, which require an accurate determination of whether a change is
back compatible or not.  Some changes are obviously incompatible â€“ removing public entrypoints or types, changing
method signatures â€“ and some changes are obviously backwards compatible (e.g. adding a new method to a <code>struct</code>,
or adding a new constant), but there's a lot of gray area left in between.</p>
<p>To help with this, the Cargo book goes into <a href="https://doc.rust-lang.org/cargo/reference/semver.html#change-categories">considerable
detail</a> as to what is and is not
<a name="a009"></a>back-compatible. Most of these details are unsurprising, but there are a few areas worth
highlighting.</p>
<ul>
<li>Adding new items is <em>usually</em> safe, but may cause clashes if code using the crate already makes use of something that
happens to have the same name as the new item.
<ul>
<li>This is a particular danger if the user does a <a name="a010"></a><a href="https://doc.rust-lang.org/cargo/reference/semver.html#minor-adding-new-public-items">wildcard import from the
crate</a>, because all of the
crate's items are then automatically in the user's main namespace. <a href="wildcard.html">Item 23</a> advises against doing this.</li>
<li>Even without a wildcard import, a <a href="https://doc.rust-lang.org/cargo/reference/semver.html#possibly-breaking-adding-a-defaulted-trait-item">new trait
method</a> (with
a <a name="a011"></a>default implementation, <a href="default-impl.html">Item 13</a>) or a <a href="https://doc.rust-lang.org/cargo/reference/semver.html#possibly-breaking-change-adding-any-inherent-items">new inherent
method</a>
has a chance of clashing with an existing name.</li>
</ul>
</li>
<li>Rust's insistence on covering all possibilities means that changing the set of available possibilities can be a
breaking change.
<ul>
<li>Performing a <a name="a012"></a><code>match</code> on an <a name="a013"></a><code>enum</code> must cover all possibilities, so if a <a href="https://doc.rust-lang.org/cargo/reference/semver.html#major-adding-new-enum-variants-without-non_exhaustive">crate adds a new <code>enum</code>
variant</a>,
that's a breaking change (unless the enum is marked as
<a name="a014"></a><a href="https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a>).</li>
<li>Explicitly creating an instance of a <a name="a015"></a><code>struct</code> requires an initial value for all fields, so <a href="https://doc.rust-lang.org/cargo/reference/semver.html#major-adding-a-public-field-when-no-private-field-exists">adding a field to a
structure that can be publically
instantiated</a>
is a breaking change.  Structures that have private fields are OK, because crate users can't explicitly construct
them anyway; a <code>struct</code> can also be marked as <code>non_exhaustive</code> to prevent external users performing explicit
construction.</li>
</ul>
</li>
<li>Changing a trait so it is <a name="a016"></a><a href="https://doc.rust-lang.org/cargo/reference/semver.html#trait-object-safety">no longer <em>object
safe</em></a> (<a href="use-types-2.html">Item 2</a>) is a breaking change; any
users that build trait objects for the trait will stop being able to compile their code.</li>
<li>Adding a new <a name="a017"></a>blanket implementation for a trait is a breaking change; any users that already implement the trait
will now have two conflicting implementations.</li>
<li>Changing the <em><a name="a018"></a>license</em> of an open-source crate is an incompatible change: users of your crate who have strict
restrictions on what licenses are acceptable may be broken by the change. <strong>Consider the license to be part of your
API</strong>.</li>
<li>Changing the <a name="a019"></a>default features (<a href="features.html">Item 26</a>) of a crate is potentially a breaking change. Removing a default
<a name="a020"></a>feature is almost certain to break things (unless the feature was already a no-op); adding a default feature may
break things depending on what it enables.  <strong>Consider the default feature set to be part of your API</strong>.</li>
<li>Changing library code so that it uses a new feature of Rust <em>might</em> be an incompatible change, because users of your
crate who have not yet upgraded their compiler to a version that includes the feature will be broken by the change.
However, most Rust crates treat a MSRV increase as a <a href="https://github.com/rust-lang/api-guidelines/discussions/231"><em>non</em>-breaking
change</a>, so <strong>consider whether the <a name="a021"></a>minimum supported
Rust version (MSRV) forms part of your API</strong>.</li>
</ul>
<p>An obvious corollary of the rules is this: the fewer public items a crate has, the fewer things there are that can
induce an incompatible change (<a href="visibility.html">Item 22</a>).</p>
<p>However, there's no escaping the fact that comparing all public API items for compatibility from one release to the next
is a time-consuming process that is only likely to yield an <em>approximate</em> (major/minor/patch) assessment of the level of
change, at best. Given that this comparison is a somewhat mechanical process, hopefully tooling (<a href="use-tools.html">Item 31</a>) will arrive to
make the process easier<sup><a name="to-footnote-1"><a href="semver.html#footnote-1">1</a></a></sup>.</p>
<p>If you do need to make an incompatible MAJOR version change, it's nice to make life easier for your users by ensuring
that the same overall functionality is available after the change, even if the API has radically changed.  If possible,
the most helpful sequence for your crate users is to:</p>
<ul>
<li>Release a MINOR version update that includes the new version of the API, and which marks the older variant as
<a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a>, including an
indication of how to migrate.</li>
<li>Subsequently release a MAJOR version update that removes the deprecated parts of the API.</li>
</ul>
<p>A more subtle point is: <strong>make breaking changes breaking</strong>. If your crate is changing its behaviour in a
way that's actually incompatible for existing users, but which <em>could</em> re-use the same API: don't.  Force a change in
types (and a MAJOR version bump) to ensure that users can't inadvertantly use the new version incorrectly.</p>
<p>For the less tangible parts of your API â€“ such as the <a name="a023"></a><a href="https://github.com/rust-lang/rust/issues/65262">MSRV</a>
or the license â€“ consider setting up a <a name="a024"></a>continuous integration check (<a href="ci.html">Item 32</a>) that detects changes, using tooling
(e.g. <a name="a025"></a><code>cargo-deny</code>, see <a href="use-tools.html">Item 31</a>) as needed.</p>
<p>Finally, don't be afraid of version 1.0.0 because it's a commitment that your API is now fixed. Lots of crates fall into
the trap of staying at version 0.x forever, but that reduces the already-limited expressivity of semver from three
categories (major/minor/patch) to two (effective-major/effective-minor).</p>
<h2 id="semver-for-crate-users"><a class="header" href="#semver-for-crate-users">Semver for Crate Users</a></h2>
<p>As a user of a crate, the <em>theoretical</em> expectations for a new version of a dependency are:</p>
<ul>
<li>A new PATCH version of a dependency crate Should Just Workâ„¢.</li>
<li>A new MINOR version of a dependency crate Should Just Workâ„¢, but the new parts of the API might be worth
exploring to see if there are cleaner/better ways of using the crate now.  However, if you do use the new parts you
won't be able to revert the dependency back to the old version.</li>
<li>All bets are off for a new MAJOR version of a dependency; chances are that your code will no longer compile and you'll
need to re-write parts of your code to comply with the new API.  Even if your code does still compile, you should
<strong>check that your use of the API is still valid after a MAJOR version change</strong>, because the constraints and
preconditions of the library may have changed.</li>
</ul>
<p>In practice, even the first two types of change <em>may</em> cause unexpected behaviour changes, even in code that still
compiles fine, due to <a name="a026"></a>Hyrum's Law.</p>
<p>As a consequence of these expectations, your dependency specifications will commonly take a form like <code>&quot;1.4.*&quot;</code> or
<code>&quot;0.7.*&quot;</code>; <strong>avoid specifying a completely <a name="a027"></a>wildcard dependency</strong> like <code>&quot;*&quot;</code> or <code>&quot;0.*&quot;</code>. A completely wildcard
dependency says that <em>any</em> version of the dependency, with <em>any</em> API, can be used by your crate â€“ which is
unlikely to be what you really want.</p>
<p>However, in the longer term it's not safe to just ignore major version changes in dependencies.  Once a library has had
a major version change, the chances are that no further <a name="a028"></a>bug fixes â€“ and more importantly, security updates
â€“ will be made to the previous major version.  A version specification like <code>&quot;1.4.*&quot;</code> will then fall further and
further behind, with any security problems left unaddressed.</p>
<p>As a result, you either need to accept the risks of being stuck on an old version, or you need to <strong>eventually follow
major version upgrades to your dependencies</strong>.  Tools such as <code>cargo update</code> or
<a name="a029"></a><a href="https://dependabot.com/">Dependabot</a> (<a href="use-tools.html">Item 31</a>), can let you know when updates are available; you can then
schedule the upgrade for a time that's convenient for you.</p>
<h2 id="discussion"><a class="header" href="#discussion">Discussion</a></h2>
<p>Semantic versioning has a cost: every change to a crate has to be assessed against its criteria, to decide the
appropriate type of version bump.  Semantic versioning is also a blunt tool: at best, it reflects a crate owner's guess
as to which of three categories the current release falls into.  Not everyone gets it right, not everything is
clear-cut about exactly what &quot;right&quot; means, and even if you get it right, there's always a chance you may fall foul of
Hyrum's Law.</p>
<p>However, semver is the only game in town for anyone who doesn't have the luxury of working in a <a href="https://dl.acm.org/doi/pdf/10.1145/2854146">highly-tested monorepo
that contains all the code in the world</a>.  As such, understanding its
concepts and limitations is necessary for managing dependencies.</p>
<p><hr/>
<p><a name="footnote-1"><a href="semver.html#to-footnote-1">1</a></a>: <a name="a022"></a><a href="https://github.com/rust-lang/rust-semverver"><code>rust-semverver</code></a> is a tool
that attempts to do something along these lines.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-22-minimize-visibility"><a class="header" href="#item-22-minimize-visibility">Item 22: Minimize visibility</a></h1>
<p>Rust's basic unit of visibility is the <a name="a001"></a>module; by default, a module's items (types, methods, constants) are
<em>private</em> and only accessible to code in the same module and its submodules.</p>
<p>Code that needs to be more widely available is marked with the <a name="a002"></a><code>pub</code> keyword, making it public to some other
scope.  A bare <code>pub</code> is the most common version, which makes the item visible to anything that's able to see the module
it's in.  That last detail is important; if a <code>somecrate::somemodule</code> module isn't visible to other code in the first
place, anything that's <code>pub</code> inside it is still not visible.</p>
<p>The more-specific variants of <code>pub</code> are as follows, in descending order of usefulness:</p>
<ul>
<li><a name="a003"></a><code>pub(crate)</code> is accessible anywhere within the owning crate. Another way of achieving the same effect is to have a
<code>pub</code> item in a non-<code>pub</code> module of the crate, but <code>pub(crate)</code> allows the item to live near the code it is relevant
for.</li>
<li><a name="a004"></a><code>pub(super)</code> is accessible to the parent module of the current module, which is occasionally useful for selectively
increasing visibility in a crate that has a deep module structure.</li>
<li><code>pub(in &lt;path&gt;)</code> is accessible to code in <code>&lt;path&gt;</code>, which has to be a description of some ancestor module of the
current module. This is even more occasionally useful for selectively increasing visibility in a crate that has an
even deeper module structure.</li>
<li><code>pub(self)</code> is equivalent to <code>pub(in self)</code> which is equivalent to not being <code>pub</code>.  Uses for this are very obscure,
such as reducing the number of special cases needed in code generation <a name="a005"></a>macros.</li>
</ul>
<p>The Rust compiler will warn you if you have a code item that is private to the module, but which is not used within that
module (and its submodules):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Private function that's been written but which is not yet used.
    fn not_used_yet(x: i32) -&gt; i32 {
        x + 3
    }
<span class="boring">}</span></code></pre></pre>
<p>Although the warning mentions code that is &quot;never used&quot;, it's often really a warning that code <em>can't</em> be used from
outside the module.</p>
<pre><code class="language-text">warning: function is never used: `not_used_yet`
  --&gt; visibility/src/main.rs:50:8
   |
50 |     fn not_used_yet(x: i32) -&gt; i32 {
   |        ^^^^^^^^^^^^
   |
</code></pre>
<p>Separately from the question of <em>how</em> to increase visibility, is the question of <em>when</em> to do so. The answer: <em>as little
as possible</em>, at least for code that's intended to be re-used as a self-contained crate (i.e. not an internal or
experimental project that will never be re-used).</p>
<p>Once a crate item is public, it can't be made private again without breaking any code that uses the crate, thus
necessitating a <a name="a006"></a>major version bump (<a href="semver.html">Item 21</a>).  The converse is not true: moving a private item
to be public generally only needs a minor version bump, and leaves crate users unaffected.  (Read through the <a href="https://doc.rust-lang.org/cargo/reference/semver.html#api-compatibility">API
compatibility guidelines</a> and notice how many
are only relevant if there are <a name="a007"></a><code>pub</code> items in play).</p>
<p>This advice is by no means unique to this Item, nor unique to Rust:</p>
<ul>
<li>The Rust <a href="https://rust-lang.github.io/api-guidelines/future-proofing.html">API guidelines</a> include advice that
<ul>
<li><a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#structs-have-private-fields-c-struct-private">Structs should have private
fields</a></li>
</ul>
</li>
<li><a href="https://www.oreilly.com/library/view/effective-java/9780134686097/"><a name="a008"></a><em>Effective Java</em></a> (3rd edition) has:
<ul>
<li>Item 15: Minimize the accessibility of classes and members</li>
<li>Item 16: In public classes, use accessor methods, not public fields</li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Special:BookSources?isbn=978-0-201-92488-6"><a name="a009"></a><em>Effective C++</em></a> (2nd edition) has:
<ul>
<li>Item 18: Strive for class interfaces that are complete and <em>minimal</em> (my italics)</li>
<li>Item 20: Avoid data members in the public interface</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-23-avoid-wildcard-imports"><a class="header" href="#item-23-avoid-wildcard-imports">Item 23: Avoid wildcard imports</a></h1>
<p>Rust's <a name="a001"></a><code>use</code> statement pulls in a named item from another crate or <a name="a002"></a>module, and makes that name available for
use in the local module's code without qualification.  A <em><a name="a003"></a>wildcard import</em> (or <em>glob import</em>) of the form <code>use somecrate::module::*</code> says that <strong>every</strong> public symbol from that module should be added to the local namespace.</p>
<p>As described in <a href="semver.html">Item 21</a>, an external crate may add new items to its API as part of a minor version upgrade; this is
considered a <a name="a004"></a>backwards compatible change.</p>
<p>The combination of these two observations raises the worry that a non-breaking change to a dependency might break your
code: what happens if the dependency adds a new symbol that clashes with a name you're already using?</p>
<p>At the simplest level, this turns out not to be a problem: the names in a wildcard import are treated as being lower
priority, so any matching names that are in your code take precedence:</p>
<pre><code class="language-rust ignore">use bytes::*;

// Local `Bytes` type does not clash with `bytes::Bytes`.
struct Bytes(Vec&lt;u8&gt;);</code></pre>
<p>Unfortunately, there are still cases where clashes can occur; for example, if the dependency adds a new trait and
implements it for some type <code>T</code>, then if any method names from the new trait clash with existing method names in your
own code for <code>T</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait BytesLeft {
    // Method name clashes with wildcard-imported `bytes::Buf::remaining`...
    fn remaining(&amp;self) -&gt; usize;
}

impl BytesLeft for &amp;[u8] {
    // ... and implementation for `&amp;[u8]` clashes with `bytes::Buf` impl.
    fn remaining(&amp;self) -&gt; usize {
        self.len()
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-rust ignore does_not_compile">        let arr = [1u8, 2u8, 3u8];
        let v = &amp;arr[1..];
        assert_eq!(v.remaining(), 3);</code></pre>
<p>then a compile-time error is the result:</p>
<pre><code class="language-text">error[E0034]: multiple applicable items in scope
  --&gt; wildcard/src/main.rs:32:22
   |
32 |         assert_eq!(v.remaining(), 3);
   |                      ^^^^^^^^^ multiple `remaining` found
   |
note: candidate #1 is defined in an impl of the trait `BytesLeft` for the type `&amp;[u8]`
  --&gt; wildcard/src/main.rs:17:5
   |
17 |     fn remaining(&amp;self) -&gt; usize {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: candidate #2 is defined in an impl of the trait `bytes::Buf` for the type `&amp;[u8]`
help: disambiguate the associated function for candidate #1
   |
32 |         assert_eq!(BytesLeft::remaining(&amp;v), 3);
   |                    ~~~~~~~~~~~~~~~~~~~~~~~~
help: disambiguate the associated function for candidate #2
   |
32 |         assert_eq!(bytes::Buf::remaining(&amp;v), 3);
   |                    ~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>As a result, you should <strong>avoid wildcard imports from crates that you don't control</strong>.  There are a couple of common
exceptions to this advice, though.</p>
<p>Firstly, if you control the source of the wildcard import, then the concerns given above disappear. For example, it's
common for a <code>test</code> module to do <code>import super::*;</code>. It's also possible for crates that use modules primarily as a way
of dividing up code to have:</p>
<pre><code class="language-rust ignore">mod thing;
pub use thing::*;</code></pre>
<p>Secondly, some crates have a convention that common items for the crate are <a name="a005"></a>re-exported from a <strong><a name="a006"></a>prelude</strong>
module, which is explicitly intended to be wildcard imported:</p>
<pre><code class="language-rust ignored">use thing::prelude::*;</code></pre>
<p>Although in theory the same concerns apply in this case, in practice such a prelude module is likely to be carefully
curated, and higher convenience may outweigh a small risk of future problems.</p>
<p>Finally, if you don't follow the advice of this Item, <strong>consider pinning dependencies that you wildcard import to a
precise version</strong>, so that minor version upgrades of the dependency aren't automatically allowed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-24-re-export-dependencies-whose-types-appear-in-your-api"><a class="header" href="#item-24-re-export-dependencies-whose-types-appear-in-your-api">Item 24: Re-export dependencies whose types appear in your API</a></h1>
<p>The title of this Item is a little convoluted, but working through an example will make things clearer.</p>
<p><a href="dep-graph.html">Item 25</a> describes how <a name="a001"></a><code>cargo</code> supports different versions of the same library crate being linked into a
single binary, in a transparent manner.  Consider a binary that uses the <a name="a002"></a><a href="https://docs.rs/rand"><code>rand</code></a> crate;
more specifically, one which uses some 0.8 version of the crate:</p>
<pre><code class="language-toml"># Top-level binary crate
[dependencies]
dep-lib = &quot;0.1.0&quot;
rand = &quot;0.8.*&quot;
</code></pre>
<pre><code class="language-rust ignore">    let mut rng = rand::thread_rng(); // rand 0.8
    let max: usize = rng.gen_range(5..10);
    let choice = dep_lib::pick_number(max);</code></pre>
<p>The final line of code also uses a notional <code>dep-lib</code> crate, and this crate internally uses<sup><a name="to-footnote-1"><a href="re-export.html#footnote-1">1</a></a></sup> a 0.7 version of the <code>rand</code> crate:</p>
<pre><code class="language-toml"># dep-lib library crate
[dependencies]
rand = &quot;0.7.3&quot;
</code></pre>
<pre><code class="language-rust ignore">use rand::Rng;

/// Pick a number between 0 and n (exclusive).
pub fn pick_number(n: usize) -&gt; usize {
    rand::thread_rng().gen_range(0, n)
}</code></pre>
<p>An eagle-eyed reader might notice a difference between the two code examples:</p>
<ul>
<li>In version 0.7.x of <code>rand</code> (as used by the <code>dep-lib</code> library crate), the
<a href="https://docs.rs/rand/0.7.3/rand/trait.Rng.html#method.gen_range"><code>rand::gen_range()</code></a> method takes two non-<code>self</code>
parameters, <code>low</code> and <code>high</code>.</li>
<li>In version 0.8.x of <code>rand</code> (as used by the binary crate), the
<a href="https://docs.rs/rand/0.8.3/rand/trait.Rng.html#method.gen_range"><code>rand::gen_range()</code></a> method takes a single
non-<code>self</code> parameter <code>range</code>.</li>
</ul>
<p>This is a <a name="a004"></a>non-back-compatible change and so <code>rand</code> has increased its leftmost version component
accordingly, as required by <a name="a005"></a>semantic versioning (<a href="semver.html">Item 21</a>).  Nevertheless, the binary that combines the two
incompatible versions works just fine; <code>cargo</code> sorts everything out<sup><a name="to-footnote-2"><a href="re-export.html#footnote-2">2</a></a></sup>.</p>
<p>However, things get a lot more awkward if the library crate's API exposes a type from its dependency, making that
dependency a <a href="https://rust-lang.github.io/api-guidelines/necessities.html#public-dependencies-of-a-stable-crate-are-stable-c-stable"><em>public
dependency</em></a>.
In the example,
this involves an <code>Rng</code> item â€“ but specifically a version-0.7 <code>Rng</code> item:</p>
<pre><code class="language-rust ignore">pub fn pick_number_with&lt;R: Rng&gt;(rng: &amp;mut R, n: usize) -&gt; usize {
    rng.gen_range(0, n) // Method from the 0.7.x version of Rng
}</code></pre>
<p>As an aside, <strong>think carefully before using another crate's types in your API</strong>: it intimately ties your crate to that
of the dependency.  For example, a major version bump for the dependency (<a href="semver.html">Item 21</a>) will automatically require a major
version bump for your crate too.</p>
<p>In this case, <code>rand</code> is a semi-standard crate that is high quality and widely used, and which only pulls in a small
number of dependencies of its own (<a href="dep-graph.html">Item 25</a>), so including its types in the crate API is probably fine on balance.</p>
<p>Returning to the example, an attempt to use this entrypoint from the top-level binary fails:</p>
<pre><code class="language-rust ignore does_not_compile">        let mut rng = rand::thread_rng();
        let max: usize = rng.gen_range(5..10);
        let choice = dep_lib::pick_number_with(&amp;mut rng, max);</code></pre>
<p>Unusually for Rust, the compiler error message isn't <a href="https://github.com/rust-lang/rust/issues/22750">very helpful</a>:</p>
<pre><code class="language-text">error[E0277]: the trait bound `ThreadRng: rand_core::RngCore` is not satisfied
  --&gt; re-export/src/main.rs:17:48
   |
17 |         let choice = dep_lib::pick_number_with(&amp;mut rng, max);
   |                      ------------------------- ^^^^^^^^ the trait `rand_core::RngCore` is not implemented for `ThreadRng`
   |                      |
   |                      required by a bound introduced by this call
   |
   = note: required because of the requirements on the impl of `rand::Rng` for `ThreadRng`
note: required by a bound in `pick_number_with`
  --&gt; /Users/dmd/src/effective-rust/examples/dep-lib/src/lib.rs:17:28
   |
17 | pub fn pick_number_with&lt;R: Rng&gt;(rng: &amp;mut R, n: usize) -&gt; usize {
   |                            ^^^ required by this bound in `pick_number_with`
</code></pre>
<p>Investigating the types involved leads to confusion because the relevant traits do <em>appear</em> to be implemented â€“
but the caller actually implements a <code>RngCore_v0_8_3</code> and the library is expecting an implementation of <code>RngCore_v0_7_3</code>.</p>
<p>Once you've finally deciphered the error message and realized that the version clash<sup><a name="to-footnote-3"><a href="re-export.html#footnote-3">3</a></a></sup> is the underlying cause, how can you fix it?  The key
observation is to realize that the while the binary can't <em>directly</em> use two different versions of the same crate, it
can do so <em>indirectly</em> (as in the original example above).</p>
<p>From the perspective of the binary author, the problem can be worked around by adding an intermediate wrapper crate that
hides the naked use of <code>rand</code> v0.7 types.  A wrapper crate is distinct from the binary crate, and so is allowed to
depend on <code>rand</code> v0.7 separately from the binary crate's dependency on <code>rand</code> v0.8.</p>
<p>This is awkward, and a much better approach is available to the author of the library crate. It can make life easier for
its users by explicitly
<a name="a006"></a><a href="https://doc.rust-lang.org/reference/items/use-declarations.html#use-visibility">re-exporting</a> either:</p>
<ul>
<li>the types involved in the API</li>
<li>the entire dependency crate.</li>
</ul>
<p>For the example, the latter approach work best: as well as making the version 0.7 <code>Rng</code> and <code>RngCore</code> types available,
it also makes available the methods (like <code>thread_rng</code>) that construct instances of the type:</p>
<pre><code class="language-rust ignore">// Re-export the version of `rand` used in this crate's API.
pub use rand;</code></pre>
<p>The calling code now has a different way to directly refer to version 0.7 of <code>rand</code>, as <code>dep_lib::rand</code>:</p>
<pre><code class="language-rust ignore">        let mut prev_rng = dep_lib::rand::thread_rng(); // v0.7 Rng instance
        let choice = dep_lib::pick_number_with(&amp;mut prev_rng, max);</code></pre>
<p>With this example in mind, the advice of the title should now be a little less obscure: <strong>re-export dependencies whose
types appear in your API</strong>.</p>
<p><hr/>
<p><a name="footnote-1"><a href="re-export.html#to-footnote-1">1</a></a>: This example (and
indeed Item) is inspired by the approach used in the <a name="a003"></a><a href="https://docs.rs/signature/1.3.0/signature/index.html#reexports">RustCrypto
crates</a>.</p>
<p><a name="footnote-2"><a href="re-export.html#to-footnote-2">2</a></a>: This is possible because the Rust
toolchain handles linking, and does not have the constraint that C++ inherits from C of needing to support
separate compilation.</p>
<p><a name="footnote-3"><a href="re-export.html#to-footnote-3">3</a></a>: This kind of error can
even appear when the dependency graph includes two alternatives for a crate with the <em>same version</em>, when something in
the build graph uses the
<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-path-dependencies"><code>path</code></a> field to
specify a local directory instead of a <code>crates.io</code> location.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-25-manage-your-dependency-graph"><a class="header" href="#item-25-manage-your-dependency-graph">Item 25: Manage your dependency graph</a></h1>
<p>Like most modern programming languages, Rust makes it easy to pull in external libraries, in the form of <em>crates</em>.  By
default, <a name="a001"></a>Cargo will:</p>
<ul>
<li>download any crates named in the <code>[dependencies]</code> section of your <a name="a002"></a><code>Cargo.toml</code> file from
<a name="a003"></a><a href="https://crates.io"><code>crates.io</code></a>,</li>
<li>finding versions that match the preferences configured in <code>Cargo.toml</code>.</li>
</ul>
<p>There are a few subtleties lurking underneath this simple statement.  The first thing to notice is that crate names form
a single flat namespace (and this global namespace also overlaps with the names of <em><a name="a004"></a>features</em> in a crate, see <a href="features.html">Item 26</a>). Names are generally allocated on a first-come, first-served basis, so you may find that your preferred name for a
public crate is already taken.  (However, name-squatting â€“ reserving a crate name by pre-registering an empty
crate â€“ is frowned upon, unless you really are going to release in the near future.)</p>
<p>As a minor wrinkle, there's also a slight difference between what's allowed as a crate name in this namespace, and
what's allowed as an identifier in code: a crate can be named <code>some-crate</code> but it will appear in code as <code>some_crate</code>
(with an underscore).  To put it another way: if you see <code>some_crate</code> in code, the corresponding crate name may be
either <code>some-crate</code> or <code>some_crate</code>.</p>
<p>The second aspect to be aware of is Cargo's <a href="https://doc.rust-lang.org/cargo/reference/resolver.html">version selection
algorithm</a>. Each <code>Cargo.toml</code> dependency line specifies an
acceptable range of versions, according to semver (<a href="semver.html">Item 21</a>) rules, and Cargo takes this into account when the same
crate appears in multiple places in the dependency graph.  If the acceptable ranges overlap and are
<a name="a005"></a>semver-compatible, then Cargo will pick the most recent version of the crate within the
overlap.</p>
<p>However, if there is no semver-compatible overlap, then Cargo will build multiple copies of the dependency at
different versions.  This can lead to confusion if the dependency is exposed in some way rather than just being used
internally (<a href="re-export.html">Item 24</a>) â€“ the compiler will treat the two versions as being distinct crates, but its error
messages won't necessarily make that clear.</p>
<p>Allowing multiple versions of a crate can also go wrong if the crate includes C/<a name="a006"></a>C++ code accessed via Rust's
<a name="a007"></a>FFI mechanisms (<a href="ffi.html">Item 34</a>) . The Rust toolchain can internally disambiguate distinct versions of Rust code, but any
included C/C++ code is subject to the <a name="a008"></a><a href="https://en.wikipedia.org/wiki/One_Definition_Rule"><em>one definition
rule</em></a>: there can only be a single version of any function, constant
or global variable.  This is most commonly encountered with the <a name="a009"></a><a href="https://crates.io/crates/ring"><code>ring</code></a>
cryptographic library, because it includes parts of the <a name="a010"></a><a href="https://boringssl.googlesource.com/boringssl/">BoringSSL
library</a> (which is written in C and assembler).</p>
<p>The third subtlety of Cargo's resolution process to be aware of is <em><a name="a011"></a>feature unification</em>: the features that get
activated for a dependent crate are the <em>union</em> of the features selected by different places in the dependency graph;
see <a href="features.html">Item 26</a> for more details.</p>
<p>Once Cargo has picked acceptable versions for all dependencies, its choices are recorded in the <a name="a012"></a><code>Cargo.lock</code> file.
Subsequent builds will then re-use the choices encoded in <code>Cargo.lock</code>, so that the build is stable and no new downloads
are needed.</p>
<p>This leaves you with a choice: should you commit your <code>Cargo.lock</code> files into version control or not?</p>
<p>The <a href="https://doc.rust-lang.org/cargo/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries">advice from the Cargo
developers</a>
is that:</p>
<ul>
<li>Things that produce a final product, namely applications and binaries, should commit <code>Cargo.lock</code> to ensure a
deterministic build.</li>
<li>Library crates should <em>not</em> commit a <code>Cargo.lock</code> file, because it's irrelevant to any downstream consumers of the
library â€“ they will have their own <code>Cargo.lock</code> file; <strong>be aware that the <code>Cargo.lock</code> file for a library crate
is ignored by library users</strong>.</li>
</ul>
<p>Even for a library crate, it can be helpful to have a checked-in <code>Cargo.lock</code> file to ensure that regular builds and
<a name="a013"></a>continuous integration (<a href="ci.html">Item 32</a>) don't have a moving target.  Although the promises of <a name="a014"></a>semantic versioning
(<a href="semver.html">Item 21</a>) should prevent failures in theory, mistakes happen in practice and it's frustrating to have builds that fail
because someone somewhere recently changed a dependency of a dependency.</p>
<p>However, <strong>if you version control <code>Cargo.lock</code>, set up a process to handle upgrades</strong> (such as GitHub's
<a name="a015"></a><a href="https://github.com/dependabot">Dependabot</a>). If you don't, your dependencies will stay pinned to versions that
get older, outdated and potentially insecure.</p>
<p>Pinning versions with a checked-in <code>Cargo.lock</code> file doesn't avoid the pain of handling dependency upgrades, but it does
mean that you can handle them at a time of your own choosing, rather than immediately when the upstream crate
changes. There's also some fraction of dependency upgrade problems that go away on their own: a crate that's released
with a problem often gets a second, fixed, version released in a short space of time, and a batched upgrade process
might only see the latter version.</p>
<h2 id="version-specification"><a class="header" href="#version-specification">Version Specification</a></h2>
<p>The version specification clause for a dependency defines a range of allowed versions, according to the
<a href="https://doc.rust-lang.org/cargo/reference/resolver.html#semver-compatibility">rules explained in the Cargo book</a>.</p>
<ul>
<li><strong>Avoid too-specific a version dependency</strong>: pinning to a specific version (<code>&quot;=1.2.3&quot;</code>) is <em>usually</em> a bad idea: you
don't see newer versions (potentially including security fixes), and you dramatically narrow the potential overlap
range with other crates in the graph that rely on the same dependency (recall that Cargo only allows a single version
of a crate to be used within a semver-compatible range).</li>
<li><strong>Avoid too-general a version dependency</strong>: it's <em>possible</em> to specify a version dependency (<code>&quot;*&quot;</code>) that allows
non-semver compatible versions to be included, but it's a bad idea: do you really mean that the crate can completely
change every aspect of its API and your code will still work?  Thought not.</li>
</ul>
<p>The most common Goldilocks specification is to allow semver-compatible versions (<code>&quot;1.*&quot;</code>) of a crate, possibly with a
specific minimum version that includes a feature or fix that you require (<code>&quot;^1.4.23&quot;</code>)</p>
<h2 id="solving-problems-with-tooling"><a class="header" href="#solving-problems-with-tooling">Solving Problems with Tooling</a></h2>
<p><a href="use-tools.html">Item 31</a> recommends that you take advantage of the range of tools that are available within the Rust ecosystem; this
section describes some dependency graph problems where tools can help.</p>
<p>The compiler will tell you pretty quickly if you use a dependency in your code, but don't include that dependency in
<code>Cargo.toml</code>.  But what about the other way around?  If there's a dependency in <code>Cargo.toml</code> that you <em>don't</em> use in
your code â€“ or more likely, <em>no longer</em> use in your code â€“ then Cargo will go on with its business.  The
<a name="a016"></a><a href="https://crates.io/crates/cargo-udeps"><code>cargo-udeps</code></a> tool is designed to solve exactly this problem: it warns you
when your <code>Cargo.toml</code> includes an unused dependency (&quot;udep&quot;).</p>
<p>A more versatile tool is <a name="a017"></a><a href="https://crates.io/crates/cargo-deny"><code>cargo-deny</code></a>, which analyzes your dependency graph
to detect a variety of potential problems across the full set of transitive dependencies:</p>
<ul>
<li>Dependencies that have known security problems in the included version.</li>
<li>Dependencies that are covered by an unacceptable <a name="a018"></a>license.</li>
<li>Dependencies that are just unacceptable.</li>
<li>Dependencies that are included in multiple different versions across the dependency tree.</li>
</ul>
<p>Each of these features can be configured and can have exceptions specified; the latter inevitably becomes necessary for
large projects, particularly for the multiple-version warning.</p>
<p>These tools can be run as a one-off, but it's better to ensure they're executed regularly and reliably by including them
in your <a name="a019"></a>continuous integration system (<a href="ci.html">Item 32</a>).  This helps to catch newly-introduced problems â€“ including
problems that may have been introduced outside of your code, in an upstream dependency (for example, a newly reported
vulnerability).</p>
<p>If one of these tools does report a problem, it can be difficult to figure out exactly where in the dependency graph the
problem arises.  The <a name="a020"></a><a href="https://doc.rust-lang.org/cargo/commands/cargo-tree.html"><code>cargo tree</code></a> command
that's included with <code>cargo</code> helps here; it shows the dependency graph as a tree structure.</p>
<pre><code>dep-graph v0.1.0
â”œâ”€â”€ dep-lib v0.1.0
â”‚   â””â”€â”€ rand v0.7.3
â”‚       â”œâ”€â”€ getrandom v0.1.16
â”‚       â”‚   â”œâ”€â”€ cfg-if v1.0.0
â”‚       â”‚   â””â”€â”€ libc v0.2.94
â”‚       â”œâ”€â”€ libc v0.2.94
â”‚       â”œâ”€â”€ rand_chacha v0.2.2
â”‚       â”‚   â”œâ”€â”€ ppv-lite86 v0.2.10
â”‚       â”‚   â””â”€â”€ rand_core v0.5.1
â”‚       â”‚       â””â”€â”€ getrandom v0.1.16 (*)
â”‚       â””â”€â”€ rand_core v0.5.1 (*)
â””â”€â”€ rand v0.8.3
    â”œâ”€â”€ libc v0.2.94
    â”œâ”€â”€ rand_chacha v0.3.0
    â”‚   â”œâ”€â”€ ppv-lite86 v0.2.10
    â”‚   â””â”€â”€ rand_core v0.6.2
    â”‚       â””â”€â”€ getrandom v0.2.3
    â”‚           â”œâ”€â”€ cfg-if v1.0.0
    â”‚           â””â”€â”€ libc v0.2.94
    â””â”€â”€ rand_core v0.6.2 (*)
</code></pre>
<p><code>cargo tree</code> includes a variety of options that can help to solve specific problems, including:</p>
<ul>
<li><code>--invert</code> shows what depends <em>on</em> a specific package, helping you to focus on a particular problematic dependency.</li>
<li><code>--edges features</code> shows what crate features are activated by a dependency link, which helps you figure out what's
going on with feature unification (<a href="features.html">Item 26</a>).</li>
</ul>
<h2 id="what-to-depend-on"><a class="header" href="#what-to-depend-on">What To Depend On</a></h2>
<p>The previous sections have covered the more mechanical aspect of working with dependencies, but there's a more
philosophical (and therefore harder to answer) question: when should you take on a dependency?</p>
<p>Most of the time, there's not much of a decision involved: if you need the functionality of a crate, you need that
function and the only alternative would be to write it yourself<sup><a name="to-footnote-1"><a href="dep-graph.html#footnote-1">1</a></a></sup>.</p>
<p>But every new dependency has a cost: partly in terms of longer builds and bigger binaries, but mostly in terms of the
developer effort involved in fixing problems with dependencies when they arise.</p>
<p>The bigger your dependendency graph, the more likely you are to be exposed to these kinds of problems.  The Rust crate
ecosystem is just as vulnerable to accidental dependency problems as other package ecosystems, where history has shown
that <a href="https://arstechnica.com/information-technology/2016/03/rage-quit-coder-unpublished-17-lines-of-javascript-and-broke-the-internet/">one developer yanking a
package</a>,
or a team <a href="https://www.theregister.com/2021/03/25/ruby_rails_code/">fixing the licensing for their package</a>, can have
widespread knock-on effects.</p>
<p>More worrying still are <a name="a021"></a>supply chain attacks, where a malicious actor deliberately tries to subvert commonly-used
dependencies, whether by <a href="https://en.wikipedia.org/wiki/Typosquatting">typo-squatting</a> or by more sophisticated
attacks<sup><a name="to-footnote-2"><a href="dep-graph.html#footnote-2">2</a></a></sup>.</p>
<p>This kind of attack doesn't just affect your compiled code â€ be aware that a dependency can run arbitrary code at
<em>build</em> time, via <a name="a023"></a><a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code></a> scripts.  That means
that a compromised dependency could end up running a cryptocurrency miner as part of your continuous integration system!</p>
<p>So for dependencies that are more &quot;cosmetic&quot;, it's sometimes worth considering whether adding the dependency is
worth the cost.</p>
<p>The answer is usually &quot;yes&quot;, though â€“ in the end, the amount of time spent dealing with
dependency problems ends up being much less than the time it would take to write equivalent functionality from
scratch.</p>
<p><hr/>
<p><a name="footnote-1"><a href="dep-graph.html#to-footnote-1">1</a></a>: If you are targetting a <code>no_std</code>
environment, this choice may be made for you: many crates are not compatible with <code>no_std</code>, particularly if <code>alloc</code> is
also unavailable (<a href="no-std.html">Item 33</a>).</p>
<p><a name="footnote-2"><a href="dep-graph.html#to-footnote-2">2</a></a>: <a name="a022"></a>Go's <a href="https://go.googlesource.com/proposal/+/master/design/25530-sumdb.md">module transparency</a>
takes a step towards addressing this, by ensuring that all clients see the same code for a given version of a
package.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-26-be-wary-of-feature-creep"><a class="header" href="#item-26-be-wary-of-feature-creep">Item 26: Be wary of <code>feature</code> creep</a></h1>
<p>Rust includes support for <a name="a001"></a><a href="https://doc.rust-lang.org/reference/conditional-compilation.html">conditional
compilation</a>, which is controlled by
<a name="a002"></a><a href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a> (and
<a name="a003"></a><a href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a>) attributes.
These attributes govern the thing â€“ function, line, block etc. â€“ that they are attached to (in contrast to
C/<a name="a004"></a>C++'s line-based preprocessor), based on configuration options that are either plain names (e.g. <code>test</code>) or
key-value pairs (e.g. <code>panic = &quot;abort&quot;</code>).</p>
<p>The toolchain populates a variety of config values that describe the target environment, including the OS (<code>target_os</code>),
CPU architecture (<code>target_arch</code>), pointer width (<code>target_pointer_width</code>), and endianness (<code>target_endian</code>); this allows
for code portability, where features that are specific to some particular target are only compiled in when building for
that target.</p>
<p>The <a name="a005"></a><a href="https://doc.rust-lang.org/cargo/index.html">Cargo</a> package manager builds on this base <code>cfg</code> mechanism to
provide the concept of <a name="a006"></a><a href="https://doc.rust-lang.org/cargo/reference/features.html"><strong>features</strong></a>: specific
named aspects of the functionality of a crate that can be enabled when building the crate.  Cargo ensures that the the
<code>feature</code> option is populated with the configured values for each crate that it compiles, and the values are
crate-specific.  This is Cargo-specific functionality; to the Rust compiler, <code>feature</code> is just another configuration
option.</p>
<p>At the time of writing, the most reliable way to determine what features are available for a crate is to examine the
crate's <a name="a007"></a><a href="https://doc.rust-lang.org/cargo/reference/manifest.html"><code>Cargo.toml</code></a> manifest file.  For example, the
following chunk of a manifest file includes four features:</p>
<pre><code class="language-toml">[features]
default = [&quot;featureA&quot;]
featureA = []
featureB = []
featureAB = [&quot;featureA&quot;, &quot;featureB&quot;]
schema = []

[dependencies]
rand = { version = &quot;^0.8&quot;, optional = true }
hex = &quot;^0.4&quot;
</code></pre>
<p>However, the four features are <em>not</em> just the four lines in the <code>[features]</code> stanza; there are a couple of subtleties to
watch out for.</p>
<p>Firstly, the <a name="a008"></a><code>default</code> line in the <code>[features]</code> stanza is a special feature name, used to
indicate which of the features should be enabled by default.  These features can still be disabled by passing the
<code>--no-default-features</code> flag to the build command, and a consumer of the crate can encode this in their
<a name="a009"></a><code>Cargo.toml</code> file like so:</p>
<pre><code class="language-toml">[dependencies]
somecrate = { version = &quot;^0.3&quot;, default-features = false }
</code></pre>
<p>The second subtlety of feature definitions is hidden in the <code>[dependencies]</code> section of the original <code>Cargo.toml</code>
example: the <code>rand</code> crate is a dependency that is marked as <code>optional = true</code>, and that effectively makes <code>&quot;rand&quot;</code> into
the name of a feature.  If the crate is compiled with <code>--features rand</code>, then that dependency is activated (and the
crate will presumably include code that uses <code>rand</code> and which is protected by <code>#[cfg(feature = &quot;rand&quot;)]</code>).</p>
<p>This also means that <em>crate names and feature names share a namespace</em>, even though one is global (governed by
<code>crates.io</code>) and one is local to the crate in question.  Consequently, <strong>choose feature names carefully</strong> to avoid
clashes with the names of any crates that might be relevant as potential dependencies.</p>
<p>So you can <strong>determine a crate's features by examining <code>[features]</code> <em>and</em> <code>optional</code> <code>[dependencies]</code></strong> in the crate's
<a name="a010"></a><code>Cargo.toml</code> file.  To turn on a feature of a dependency, add the <code>features</code> option to the relevant line in the
<code>[dependencies]</code> stanza of your own manifest file:</p>
<pre><code class="language-toml">[dependencies]
somecrate = { version = &quot;^0.3&quot;, features = [&quot;featureA&quot;, &quot;rand&quot; ] }
</code></pre>
<p>This line ensures that <code>somecrate</code> will be built with both the <code>featureA</code> and the <code>rand</code> feature enabled.  However, that
might not be the only features that are enabled, due to a phenomenon known as <a name="a011"></a><a href="https://doc.rust-lang.org/cargo/reference/features.html#feature-unification"><em>feature
unification</em></a>. This means that a crate will
get built with the <em>union</em> of all of the features that are requested by anything in the build graph. In other words,
if some other dependency in the build graph also relies on <code>somecrate</code>, but with just <code>featureB</code> enabled, then the crate
will be built with all of <code>featureA</code>, <code>featureB</code> and <code>rand</code> enabled, in order to satisfy everyone<sup><a name="to-footnote-1"><a href="features.html#footnote-1">1</a></a></sup>.  The same
consideration applies to default features: if your crate sets <code>default-features = false</code> for a dependency, but some
other place in the build graph leaves the default features enabled, then enabled they will be.</p>
<p>Feature unification means that <strong>features should be additive</strong>; it's a bad idea to have mutually incompatible features
because there's nothing to prevent the incompatible features being simultaneously enabled by different users.</p>
<p>A specific consequence of this applies to public traits, intended to be used outside the crate they're defined in.
Consider a trait that includes a feature gate on one of its methods:</p>
<pre><code class="language-rust ignore not_desired_behaviour">/// Trait for items that support CBOR serialization.
pub trait AsCbor: Sized {
    /// Convert the item into CBOR-serialized data.
    fn serialize(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;;

    /// Create an instance of the item from CBOR-serialized data.
    fn deserialize(data: &amp;[u8]) -&gt; Result&lt;Self, Error&gt;;

    /// Return the schema corresponding to this item.
    #[cfg(feature = &quot;schema&quot;)]
    fn cddl(&amp;self) -&gt; String;
}</code></pre>
<p>This leaves external trait implementors in a quandary: should they implement the <code>cddl()</code> method or not?</p>
<p>For code that doesn't use the <code>schema</code> feature, the answer seems to obviously be &quot;No&quot; â€“ the code won't compile if
you do. But if something else in the dependency graph <em>does</em> use the <code>schema</code> feature, an implementation of this method
suddenly becomes required.  The external code that tries to implement the trait doesn't know â€“ and can't tell
â€“ whether to implement the feature-gated method or not.</p>
<p>So the net is that you should <strong>avoid feature-gating methods on public traits</strong>.  A trait method with a <a name="a012"></a>default
implementation (<a href="default-impl.html">Item 13</a>) might be a partial exception to this â€“ but only if it never makes sense for external
code to override the default.</p>
<p>Feature unification also means that if your crate has <em>N</em> independent<sup><a name="to-footnote-2"><a href="features.html#footnote-2">2</a></a></sup>
features, then all of the 2<sup>N</sup> possible build combinations can occur in practice.  To avoid unpleasant
surprises, it's a good idea to ensure that your continuous integration system (<a href="ci.html">Item 32</a>) covers all of these
2<sup>N</sup> combinations, in all of the available test variants (<a href="testing.html">Item 30</a>).</p>
<p>Summing up the aspects of features to be wary of:</p>
<ul>
<li>Features should be additive.</li>
<li>Feature names should be carefully chosen not to clash with potential dependency names.</li>
<li>Having lots of independent features potentially leads to a combinatorial explosion of different build configurations.</li>
</ul>
<p>However, the use of optional features is very helpful in controlling exposure to an expanded dependency graph (<a href="dep-graph.html">Item 25</a>).  This is particularly useful in low-level crates that are capable of being used in a <a name="a013"></a><code>no_std</code> environment
(<a href="no-std.html">Item 33</a>) â€“ it's common to have a <code>std</code> or <code>alloc</code> feature that turns on functionality that relies on those
libraries.</p>
<p><hr/>
<p><a name="footnote-1"><a href="features.html#to-footnote-1">1</a></a>: The <code>cargo tree --edges features</code> command can help with determining which features are enabled for which crates, and why.</p>
<p><a name="footnote-2"><a href="features.html#to-footnote-2">2</a></a>: Features can force other features
to be enabled; in the original example the <code>featureAB</code> feature forces both <code>featureA</code> and <code>featureB</code> to be enabled.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tooling"><a class="header" href="#tooling">Tooling</a></h1>
<p><a name="a001"></a>Titus Winters (Google's C++ library lead) describes <a name="a002"></a>software engineering as programming
integrated over time, or sometimes as programming integrated over time and people.  Over longer timescales, and a wider
team, there's more to a codebase than just the code held within it.</p>
<p>Modern languages, including Rust, are aware of this and come with an ecosystem of tooling that goes way beyond just
converting the program into executable binary code (the compiler).</p>
<p>This section explores the Rust tooling ecosystem, with a general recommendation to make use of all of this
infrastructure.  Obviously, doing so needs to be proportionate â€“ setting up CI, documentation builds, and six
types of test would be overkill for a throwaway program that only gets run twice.  But for most of the things described
in this section, there's lots of &quot;bang for the buck&quot;: a little bit of investment into tooling integration will yield
worthwhile benefits.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-27-document-public-interfaces"><a class="header" href="#item-27-document-public-interfaces">Item 27: Document public interfaces</a></h1>
<p>If your crate is going to be used by other programmers, then it's a good idea to add documentation for its contents,
particularly its public API.  If your crate is more than just ephemeral, throw-away code, then that &quot;other programmer&quot;
includes the you-of-the-future, when you have forgotten the details of your current code.</p>
<p>This is not advice that's specific to Rust, nor is it new advice â€“ for example, <a name="a001"></a><a href="https://www.oreilly.com/library/view/effective-java-2nd/9780137150021/"><em>Effective
Java</em></a> 2nd edition (from 2008) has Item 44:
&quot;Write doc comments for all exposed API elements&quot;.</p>
<p>The particulars of Rust's documentation comment format â€“ Markdown-based, delimited with <code>///</code> or <code>//!</code>  â€“
are covered in the <a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">Rust
book</a>, but
there are some specific details worth highlighting.</p>
<pre><code class="language-rust ignore">/// Calculate the [`BoundingBox`] that exactly encompasses a pair
/// of [`BoundingBox`] objects.
pub fn union(a: &amp;BoundingBox, b: &amp;BoundingBox) -&gt; BoundingBox {</code></pre>
<ul>
<li><strong>Use a code font for code</strong>: For anything that would be typed into source code as-is, surround it with back-quotes
to ensure that the resulting documentation is in a fixed-width font, making the distinction between <code>code</code> and text
clear.</li>
<li><strong>Add copious cross-references</strong>: Add a <a name="a002"></a>Markdown link for anything that might provide context for someone
reading the documentation. In particular, <strong>cross-reference identifiers</strong> with the convenient <code>[`SomeThing`]</code> syntax
â€“ if <code>SomeThing</code> is in scope, then the resulting documentation will hyperlink to the right place.</li>
<li><strong>Consider including example code</strong>: If it's not trivially obvious how to use an entrypoint, adding an <code># Examples</code>
section with <a name="a003"></a>sample code can be helpful.</li>
<li><strong>Document panics and <code>unsafe</code> constraints</strong>: If there are inputs that cause a function to panic, document (in a <code># Panics</code> section) the preconditions that are required to avoid the <a name="a004"></a><code>panic!</code>.  Similarly, document (in a <code># Safety</code> section) any requirements for <a name="a005"></a><code>unsafe</code> code.</li>
</ul>
<p>The documentation for Rust's <a href="https://doc.rust-lang.org/stable/std/index.html">standard library</a> provides an excellent
example to emulate for all of these details.</p>
<h2 id="tooling-1"><a class="header" href="#tooling-1">Tooling</a></h2>
<p>The Markdown format that's used for documentation comments results in elegant output, but this does also mean that there
is an explicit conversion step (<a name="a006"></a><code>cargo doc</code>).  This in turn raises the possibility that something goes wrong along
the way.</p>
<p>The simplest advice for this is just to <strong>read the rendered documentation</strong> after writing it, by running <code>cargo doc --open</code>.</p>
<p>You could also check that all the generated hyperlinks are valid, but that's a job more suited to a machine â€“ via
the <code>broken_intra_doc_links</code> crate attribute<sup><a name="to-footnote-1"><a href="documentation.html#footnote-1">1</a></a></sup>:</p>
<pre><code class="language-rust ignore not_desired_behaviour">#![deny(broken_intra_doc_links)]

/// The bounding box for a [`Polygone`].
#[derive(Clone, Debug)]
pub struct BoundingBox {</code></pre>
<p>With this attribute enabled, <code>cargo doc</code> will detect invalid links:</p>
<pre><code class="language-text">error: unresolved link to `Polygone`
 --&gt; docs/src/main.rs:4:30
  |
4 | /// The bounding box for a [`Polygone`].
  |                              ^^^^^^^^ no item named `Polygone` in scope
  |
note: the lint level is defined here
 --&gt; docs/src/main.rs:2:9
  |
2 | #![deny(broken_intra_doc_links)]
  |         ^^^^^^^^^^^^^^^^^^^^^^
  = help: to escape `[` and `]` characters, add '\' before them like `\[` or `\]`
error: could not document `docs`
</code></pre>
<p>You can also <em>require</em> documentation, by enabling the <code>#![warn(missing_docs)]</code> attribute for the crate.  When this is
enabled, the compiler will emit a warning for every undocumented public item.  However, there's a risk that enabling
this option will lead to poor quality documentation comments that are rushed out just to get the compiler to shut up
â€“ more on this below.</p>
<p>As ever, any tooling that detects potential problems should form a part of your <a name="a007"></a>continuous integration system
(<a href="ci.html">Item 32</a>), to catch any regressions that creep in.</p>
<h2 id="additional-documentation-locations"><a class="header" href="#additional-documentation-locations">Additional Documentation Locations</a></h2>
<p>The output from <code>cargo doc</code> is the primary place where your crate is documented, but it's not the only place â€“
other parts of a Cargo project can help users figure out how to use your code.</p>
<p>The <code>examples/</code> subdirectory of a Cargo project can hold the code for standalone binaries that make use of your crate.
These programs are built and run very similarly to integration tests (<a href="testing.html">Item 30</a>), but are specifically intended to hold
example code that illustrates the correct use of your crate's interface.</p>
<p>On a related note, bear in mind that the the integration tests under the <code>tests/</code> subdirectory can also serve as
examples for the confused user, even though their primary purpose is to test the crate's external interface.</p>
<p>For a published crate, any top-level <code>README.md</code> file<sup><a name="to-footnote-2"><a href="documentation.html#footnote-2">2</a></a></sup> for the project is presented
as the main page content on the <a name="a008"></a><code>crates.io</code> listing for the crate (for example, see the <a name="a009"></a><a href="https://crates.io/crates/rand"><code>rand</code> crate
page</a>).  However, this content is <em>not</em> easily visible on the documentation pages, and so
serves a somewhat different purpose â€“ it's aimed at people who are choosing what crate to use, rather than
figuring out how to use a crate they've already included (although there's obviously considerable overlap between the
two).</p>
<h2 id="what-not-to-document"><a class="header" href="#what-not-to-document">What <em>Not</em> to Document</a></h2>
<p>When a project <em>requires</em> that documentation be included for all public items (as mentioned in the first section), it's
very easy to fall into the trap of having documentation that's a pointless waste of valuable pixels.  Having the
compiler warn about missing doc comments is only a proxy for what you really want â€“ useful documentation â€“
and is likely to incentivize programmers to do the minimum needed to silence the warning.</p>
<p>Good doc comments are a boon that help users understand the code they're using; bad doc comments impose a maintenance
burden and increase the chance of user confusion when they get out of sync with the code. So how to distinguish between
the two?</p>
<p>The primary advice is to <strong>avoid repeating in text something that's clear from the code</strong>.  <a href="use-types.html">Item 1</a> exhorted you to
encode as much semantics as possible into Rust's type system; once you've done that, allow the type system to document
those semantics.  Assume that the reader is familiar with Rust â€“ possibly because they've read a helpful
collection of Items describing effective use of the language â€“ and don't repeat things that are clear from the
signatures and types involved.</p>
<p>Returning to the previous example, an overly-verbose documentation comment might be:</p>
<pre><code class="language-rust ignore not_desired_behaviour">    /// Return a new [`BoundingBox`] object that exactly encompasses a pair
    /// of [`BoundingBox`] objects.
    ///
    /// Parameters:
    ///  - `a`: an immutable reference to a `BoundingBox`
    ///  - `b`: an immutable reference to a `BoundingBox`
    /// Returns: new `BoundingBox` object.
    pub fn union(a: &amp;BoundingBox, b: &amp;BoundingBox) -&gt; BoundingBox {</code></pre>
<p>This comment repeats many details that are clear from the function signature, to no benefit.</p>
<p>Worse, consider what's likely to happen if the code gets refactored to store the result in one of the original arguments
(which would be a <a name="a010"></a>breaking change, see <a href="semver.html">Item 21</a>). No compiler or tool complains that the
comment isn't updated to match, so it's easy to end up with an out-of-sync comment:</p>
<pre><code class="language-rust ignore not_desired_behaviour">    /// Return a new [`BoundingBox`] object that exactly encompasses a pair
    /// of [`BoundingBox`] objects.
    ///
    /// Parameters:
    ///  - `a`: an immutable reference to a `BoundingBox`
    ///  - `b`: an immutable reference to a `BoundingBox`
    /// Returns: new `BoundingBox` object.
    pub fn union(a: &amp;mut BoundingBox, b: &amp;BoundingBox) {</code></pre>
<p>In contrast, the original comment survives the refactoring unscathed, because its text describes behaviour not syntactic
details:</p>
<pre><code class="language-rust ignore">    /// Calculate the [`BoundingBox`] that exactly encompasses a pair
    /// of [`BoundingBox`] objects.
    pub fn union(a: &amp;mut BoundingBox, b: &amp;BoundingBox) {</code></pre>
<p>The mirror image of the advice above also helps improve documentation: <strong>include in text anything that's <em>not</em> clear
from the code</strong>.  This includes preconditions, invariants, panics, error conditions and anything else that might
surprise a user; if your code can't comply with the <a name="a011"></a><a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">principle of least
astonishment</a>, make sure that the surprises are
documented so you can at least say &quot;I told you so&quot;.</p>
<p>Another common failure mode is when doc comments describe how some other code uses a method, rather than what the method
does.</p>
<pre><code class="language-rust ignore">    /// Return the intersection of two [`BoundingBox`] objects, returning `None`
    /// if there is no intersection. The collision detection code in `hits.rs`
    /// uses this to do an initial check whether two objects might overlap, before
    /// perfoming the more expensive pixel-by-pixel check in `objects_overlap`.
    pub fn intersection(
        a: &amp;BoundingBox,
        b: &amp;BoundingBox,
    ) -&gt; Option&lt;BoundingBox&gt; {</code></pre>
<p>Comments like this are almost guaranteed to get out of sync: when the using code (here <code>hits.rs</code>) changes, the comment that
describes the behaviour is nowhere nearby.</p>
<p>Rewording the comment to focus more on the <em>why</em> makes it more robust to future changes:</p>
<pre><code class="language-rust ignore">    /// Return the intersection of two [`BoundingBox`] objects, returning `None`
    /// if there is no intersection.  Note that intersection of bounding boxes
    /// is necessary but not sufficient for object collision -- pixel-by-pixel
    /// checks are still required on overlap.
    pub fn intersection(
        a: &amp;BoundingBox,
        b: &amp;BoundingBox,
    ) -&gt; Option&lt;BoundingBox&gt; {</code></pre>
<p>When writing software, it's good advice to &quot;program in the future tense&quot;<sup><a name="to-footnote-3"><a href="documentation.html#footnote-3">3</a></a></sup>: structure the code to accommodate future changes.  The same is true for
documentation (albeit not literally): focusing on the semantics, the <em>why</em>s and the <em>why not</em>s, gives text that is more
likely to remain helpful in the long run.</p>
<p><hr/>
<p><a name="footnote-1"><a href="documentation.html#to-footnote-1">1</a></a>: Historically, this option used to be called
<code>intra_doc_link_resolution_failure</code>.</p>
<p><a name="footnote-2"><a href="documentation.html#to-footnote-2">2</a></a>: The default behaviour of automatically including
<code>README.md</code> can be overridden with the <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-readme-field"><code>readme</code> field in
<code>Cargo.toml</code></a>.</p>
<p><a name="footnote-3"><a href="documentation.html#to-footnote-3">3</a></a>: <a name="a012"></a>Scott Meyers
<a name="a013"></a><em>More Effective C++</em> Item 32.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-28-use-macros-judiciously"><a class="header" href="#item-28-use-macros-judiciously">Item 28: Use macros judiciously</a></h1>
<blockquote>
<p>&quot;In some cases it's easy to decide to write a macro instead of a function, because only a macro can do what's needed&quot;
â€“ <a name="a001"></a>Paul Graham, <a name="a002"></a><a href="http://www.paulgraham.com/onlisp.html">&quot;On Lisp&quot;</a></p>
</blockquote>
<p>Rust's <a name="a003"></a>macro systems allow you perform <em><a name="a004"></a>metaprogramming</em>: to write code that emits code into your project.
This is most valuable when there are chunks of &quot;boilerplate&quot; code that are deterministic and repetitive, and which would
otherwise need to be kept in sync manually.</p>
<p>The macros that programmers coming to Rust are most likely to have previously encountered are those provided by
<a name="a005"></a>C/<a name="a006"></a>C++'s <a name="a007"></a>preprocessor.  However, the Rust approach is a completely different beast
â€“ where the C preprocessor performs textual substitution on the tokens of the input text, Rust macros instead
operate on the <em>abstract syntax tree</em> (<a name="a008"></a>AST) of the program.</p>
<p>This means that Rust macros can be aware of code structure and can consequently avoid entire classes of macro-related
footguns. In particular, Rust macros are <a name="a009"></a><a href="https://en.wikipedia.org/wiki/Hygienic_macro"><em>hygienic</em></a>
â€“ they cannot accidentally refer to (&quot;capture&quot;) local variables in the surrounding code.</p>
<p>One way to think about macros is see it as a different level of abstraction in the code.  A simple form of abstraction
is a function: it abstracts away the differences between different values of the same <em>type</em>, with implementation code
that can use any of the features and methods of that type, regardless of the current value being operated on.  A
<a name="a010"></a>generic is a different level of abstraction : it abstracts away the difference between different <em>types</em> that
satisfy a <a name="a011"></a>trait bound, with implementation code that can use any of the methods provided by the trait bounds,
regardless of the current type being operated on.</p>
<p>A macro abstracts away the difference between different chunks of the <a name="a012"></a>AST that play the same role (type,
identifier, expression, etc.); the implementation can then include any code that makes use of those chunks in the same
AST role.</p>
<h2 id="macro-basics"><a class="header" href="#macro-basics">Macro Basics</a></h2>
<p>Although this Item isn't the place to reproduce the <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">documentation for
macros</a>, a few reminders of details to watch out for are in order.</p>
<p>First, be aware that the scoping rules for using a macro are different than for other Rust items.  If a <a name="a013"></a>declarative macro is defined in a source code file, only the code <em>after</em> the macro definition can make use
of it:</p>
<pre><code class="language-rust ignore does_not_compile">fn before() {
    println!(&quot;double {} is {}&quot;, 2, double!(2));
}

macro_rules! double {
    { $e:expr } =&gt; { $e * $e }
}

fn after() {
    println!(&quot;double {} is {}&quot;, 2, double!(2));
}</code></pre>
<pre><code class="language-text">error: cannot find macro `double` in this scope
 --&gt; macros/src/main.rs:4:36
  |
4 |     println!(&quot;double {} is {}&quot;, 2, double!(2));
  |                                    ^^^^^^
  |
  = help: have you added the `#[macro_use]` on the module/import?
</code></pre>
<p>The <a name="a014"></a><code>#[macro_export]</code> attribute makes a macro more widely visible, but this also has an oddity: a
macro appears at the top level of a crate, even if it defined in a module:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod defn {
    #[macro_export]
    macro_rules! treble {
        { $e:expr } =&gt; { $e * $e * $e }
    }
}

mod user {
    pub fn use_macro() {
        // Note: *not* `crate::defn::treble!`
        let cubed = crate::treble!(3);
        println!(&quot;treble {} is {}&quot;, 3, cubed);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a name="a015"></a>Procedural macros (which are macros that get access to the program's syntax tree at compile
time), also have a limitation around code location, in that they must be defined in a separate crate from where they are
used.</p>
<p>Even though Rust's macros are safer than C preprocessor macros, there are still a couple of minor gotchas to be aware
of in their use.</p>
<p>The first is to realize that even if a macro invocation <em>looks</em> like a function invocation, it's not.  In particular,
the normal intuition about whether parameters are moved or <code>&amp;</code>referred to doesn't apply:</p>
<pre><code class="language-rust ignore">    let mut x = Item { contents: 42 }; // type is not `Copy`
    inc!(x); // Item is *not* moved, despite the (x) syntax, and *can* be modified
    println!(&quot;x is {:?}&quot;, x);</code></pre>
<p>The <a name="a016"></a>exclamation mark serves as a warning: the expanded code for the macro may do arbitrary things to/with its
arguments.</p>
<p>The expanded code can also include control flow operations that aren't visible in the calling code, whether they be
loops, conditionals, <a name="a017"></a><code>return</code> statements, or use of the <a name="a018"></a><code>?</code> operator.  Obviously, this is likely to violate
the <a name="a019"></a><a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">principle of least astonishment</a>, so <strong>prefer
macros whose behaviour aligns with normal Rust</strong> where possible.</p>
<p>For example, a macro that silently includes a <code>return</code> in its body:</p>
<pre><code class="language-rust ignore">/// Check that an HTTP status is successful; exit function if not.
macro_rules! check_successful {
    { $e:expr } =&gt; {
        if $e.group() != Group::Successful {
            return Err(MyError(&quot;HTTP operation failed&quot;));
        }
    }
}</code></pre>
<p>makes the control flow of the calling code somewhat obscure:</p>
<pre><code class="language-rust ignore">    let rc = perform_http_operation();
    check_successful!(rc); // may silently exit the function

    // ...</code></pre>
<p>An alternative version of the macro that generates code which emits a
<code>Result</code>:</p>
<pre><code class="language-rust ignore">/// Convert an HTTP status into a `Result&lt;(), MyError&gt;` indicating success.
macro_rules! check_success {
    { $e:expr } =&gt; {
        match $e.group() {
            Group::Successful =&gt; Ok(()),
            _ =&gt; Err(MyError(&quot;HTTP operation failed&quot;)),
        }
    }
}</code></pre>
<p>gives calling code that's easier to follow:</p>
<pre><code class="language-rust ignore">    let rc = perform_http_operation();
    check_success!(rc)?; // error flow is visible via `?`

    // ...</code></pre>
<p>The second thing to watch out for with <a name="a020"></a>declarative macros is a problem shared with the
<a name="a021"></a>C preprocessor: if the argument to a macro is an expression with side effects, watch out for
repeated use of the argument in the macro:</p>
<pre><code class="language-rust ignore not_desired_behaviour">    let mut x = 1;
    let y = double!({
        x += 1;
        x
    });
    println!(&quot;x = {}, y = {}&quot;, x, y);
    // output: x = 3, y = 6</code></pre>
<p>Assuming that this behaviour isn't intended, the solution is simply to evaluate the expression once, and assign the
result to a local variable:</p>
<pre><code class="language-rust ignore">macro_rules! double_once {
    { $e:expr } =&gt; { { let x = $e; x*x } }
}
// output now: x = 2, y = 4</code></pre>
<h2 id="when-to-use-macros"><a class="header" href="#when-to-use-macros">When to use Macros</a></h2>
<p>The primary reason to use macros is to avoid repetitive code.  In this respect, writing a macro is just an extension of
the same kind of generalization process that normally forms part of programming:</p>
<ul>
<li>If you repeat exactly the same code for multiple instances a specific type, encapsulate that code into a common
function and call the function from all of the repeated places.</li>
<li>If you repeat exactly the same code for multiple different types, encapsulate that code into a <a name="a022"></a>generic
and trait bound, and use the generic from all of the repeated places.</li>
<li>If you repeat the same structure of code in multiple different places, encapsulate that code into a <a name="a023"></a>macro, and
use the macro from all of the repeated places.</li>
</ul>
<p>For example, avoiding repetition for code that works on different <a name="a024"></a><code>enum</code> variants can only be done by a macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Multi {
    Byte(u8),
    Int(i32),
    Str(String),
}

#[macro_export]
macro_rules! values_of_type {
    { $values:expr, $variant:ident } =&gt; {
        {
            let mut result = Vec::new();  // explicit use of Vec allows type deduction
            for val in $values {
                if let Multi::$variant(v) = val {
                    result.push(v.clone());
                }
            }
            result
        }
    }
}

fn use_multi() {
    let values = vec![
        Multi::Byte(1),
        Multi::Int(1000),
        Multi::Str(&quot;a string&quot;.to_string()),
        Multi::Byte(2),
    ];
    let ints = values_of_type!(&amp;values, Int);
    assert_eq!(ints, vec![1000]);
    let bytes = values_of_type!(&amp;values, Byte);
    assert_eq!(bytes, vec![1u8, 2u8]);
}
<span class="boring">}</span></code></pre></pre>
<p>Macros also allow for grouping all of the key information about a collection of data values together:</p>
<pre><code class="language-rust ignore">http_codes! {
    Continue =&gt; (100, Informational, &quot;Continue&quot;),
    SwitchingProtocols =&gt; (101, Informational, &quot;Switching Protocols&quot;),
    // ...
    Ok =&gt; (200, Successful, &quot;Ok&quot;),
    Created =&gt; (201, Successful, &quot;Created&quot;),
    // ...
}</code></pre>
<p>Only the information that changes between different values is encoded, in a compact form that acts as a kind of
<a name="a025"></a>domain-specific language (DSL) holding the source-of-truth for the data.  The macro definition then takes care of
generating all of the code that derives from these values:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! http_codes {
    { $( $name:ident =&gt; ($val:literal, $group:ident, $text:literal), )+ } =&gt; {
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[repr(i32)]
        enum Status {
            $( $name = $val, )+
        }
        impl Status {
            fn group(&amp;self) -&gt; Group {
                match self {
                    $( Self::$name =&gt; Group::$group, )+
                }
            }
            fn text(&amp;self) -&gt; &amp;'static str {
                match self {
                    $( Self::$name =&gt; $text, )+
                }
            }
        }
        impl TryFrom&lt;i32&gt; for Status {
            type Error = ();
            fn try_from(v: i32) -&gt; Result&lt;Self, Self::Error&gt; {
                match v {
                    $( $val =&gt; Ok(Self::$name), )+
                    _ =&gt; Err(())
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If an extra value needs to be added later, rather than having to manually adjust four different places, all that's
needed is a single additional line:</p>
<pre><code class="language-rust ignore">    ImATeapot =&gt; (418, ClientError, &quot;I'm a teapot&quot;),</code></pre>
<p>Because macros are expanded in-place in the invoking code, they can also be used to automatically emit additional
diagnostic information â€“ in particular, by using the
<a name="a026"></a><a href="https://doc.rust-lang.org/core/macro.file.html"><code>file!()</code></a> and
<a name="a027"></a><a href="https://doc.rust-lang.org/core/macro.line.html"><code>line!()</code></a> macros from the standard library that emit source code
information:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! diags {
    { $e:expr } =&gt; {
        {
            let result = $e;
            if let Err(err) = &amp;result {
                log::error!(&quot;{}:{}: operation '{}' failed: {:?}&quot;,
                            file!(),
                            line!(),
                            stringify!($e),
                            err);
            }
            result
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>When failures occur, the log file then automatically includes details of what failed and where:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x: Result&lt;u8, _&gt; = diags!(512.try_into());
    let y = diags!(std::str::from_utf8(b&quot;\xc3\x28&quot;)); // invalid UTF-8
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-text">[2023-04-16T08:54:14Z ERROR macros] macros/src/main.rs:239: operation '512.try_into()' failed: TryFromIntError(())
[2023-04-16T08:54:14Z ERROR macros] macros/src/main.rs:240: operation 'std::str::from_utf8(b&quot;\xc3\x28&quot;)' failed: Utf8Error { valid_up_to: 0, error_len: Some(1) }
</code></pre>
<h2 id="disadvantages-of-macros"><a class="header" href="#disadvantages-of-macros">Disadvantages of Macros</a></h2>
<p>The primary disadvantage of using a macro is the impact that it has on code readability and maintainability.  The
previous section explained that macros allow you to create a <a name="a028"></a>domain-specific language to concisely express key
features of your code and data. However, this means that anyone reading or maintaining the code now has to understand
this DSL â€“ and its implementation in macro definitions â€“ in addition to understanding Rust.</p>
<p>This potential impenetrability of macro-based code extends beyond other engineers: various of the tools that analyze and
interact with Rust code may treat the code as opaque, because it no longer necessarily follows the syntactical
conventions of Rust code.  Even the compiler itself is less helpful: its error messages don't always follow the chain
of macro use and definition.</p>
<p>Another possible downside for macro use is the possibility of code bloat â€“ a single line of macro invocation can result
in hundreds of lines of generated code, which will be invisible to a cursory survey of the code.  This is rarely a
problem when the code is first written, because at that point the code is needed and saves the humans involved from
having to write it themselves; however, if the code subsequently stops being necessary, it's not so obvious that there
are large amounts of code that could be deleted.</p>
<h2 id="advice-1"><a class="header" href="#advice-1">Advice</a></h2>
<p>Although the previous section listed some downsides of macros, they are still fundamentally the right tool for the job
when there are different chunks of code that need to be kept consistent, but which cannot be coalesced any other way:
<strong>use a macro whenever it's the only way to ensure that disparate code stays in sync</strong>.</p>
<p>Macros are also the tool to reach for when there's boilerplate code to be squashed: <strong>use a macro for repeated
boilerplate code</strong> that can't be coalesced into a function or a generic.</p>
<p>To reduce the impact on readability, try to avoid syntax in your macros that clashes with Rust's normal syntax rules;
either make the macro invocation look like normal code, or make it look sufficiently <em>different</em> that no-one could
confuse the two.  In particular:</p>
<ul>
<li><strong>Avoid macro expansions that insert references</strong> where possible â€“ a macro invocation like <code>my_macro!(&amp;list)</code>
aligns better with normal Rust code than <code>my_macro!(list)</code> would.</li>
<li><strong>Prefer to avoid non-local control flow operations in macros</strong>, so that anyone reading the code is able to follow the
flow without needing to know the details of the macro.</li>
</ul>
<p>This preference for Rust-like readability sometimes affects the choice between declarative macros and procedural macros.
If you need to emit code for each field of a structure, or each variant of an enum, <strong>prefer a <a name="a029"></a>derive macro to a procedural macro that emits a type</strong> (despite the example shown in an earlier section); it's
more idiomatic and makes the code easier to read.</p>
<p>However, if you're adding a derive macro with functionality that's not specific to your project, check whether an
external crate already provides what you need (cf. <a href="dep-graph.html">Item 25</a>).  For example, the problem of converting integer values
into the appropriate variant of a C-like <a name="a030"></a><code>enum</code> is well-covered: all of
<a href="https://docs.rs/enumn/latest/enumn/derive.N.html"><code>enumn::N</code></a>,
<a href="https://docs.rs/num_enum/latest/num_enum/derive.TryFromPrimitive.html"><code>num_enum::ITryFromPrimitive</code></a>,
<a href="https://docs.rs/num-derive/latest/num_derive/derive.FromPrimitive.html"><code>num_derive::FromPrimitive</code></a>, and
<a href="https://docs.rs/strum/latest/strum/derive.FromRepr.html"><code>strum::FromRepr</code></a> cover some aspect of this problem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-29-listen-to-clippy"><a class="header" href="#item-29-listen-to-clippy">Item 29: Listen to Clippy</a></h1>
<blockquote>
<p>&quot;It looks like you're writing a letter. Would you like help?&quot; â€“ <a href="https://en.wikipedia.org/wiki/Office_Assistant">Microsoft Clippit</a></p>
</blockquote>
<p><a href="use-tools.html">Item 31</a> describes the ecosystem of helpful tools available in the Rust toolbox, but one tool is sufficiently helpful and
important to get promoted to an Item of its very own: <a name="a001"></a><a href="https://github.com/rust-lang/rust-clippy#clippy">Clippy</a>.</p>
<p>Clippy is an additional component for <a name="a002"></a>Cargo that emits warnings about your Rust usage (<code>cargo clippy ...</code>), across a
variety of categories:</p>
<ul>
<li><strong>Correctness</strong>: warn about common programming errors.</li>
<li><strong>Idiom</strong>: warn about code constructs that aren't quite in standard Rust style.</li>
<li><strong>Concision</strong>: point out variations on the code that are more compact.</li>
<li><strong>Performance</strong>: suggest alternatives that avoid unnecessary processing or allocation.</li>
<li><strong>Readability</strong>: describe alterations to the code that would make it easier for humans to read and understand.</li>
</ul>
<p>For example, the following code builds fine:</p>
<pre><code class="language-rust ignore not_desired_behaviour">    pub fn circle_area(radius: f64) -&gt; f64 {
        let pi = 3.14;
        pi * radius * radius
    }</code></pre>
<p>but Clippy points out that the local approximation to <a name="a003"></a>Ï€ is unnecessary and inaccurate:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found
 --&gt; clippy/src/main.rs:5:18
  |
5 |         let pi = 3.14;
  |                  ^^^^
  |
  = note: `#[deny(clippy::approx_constant)]` on by default
  = help: consider using the constant directly
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>The linked webpage explains the problem, and points the way to a suitable modification of the code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn circle_area(radius: f64) -&gt; f64 {
        std::f64::consts::PI * radius * radius
    }
<span class="boring">}</span></code></pre></pre>
<p>As shown above, each Clippy warning comes with a link to a webpage describing the error, which explains <em>why</em> the code
is considered bad.  This is vital, because it allows you to decide whether those reasons apply to your code, or whether
there is some particular reason why the lint check isn't relevant.  In some cases, the text also describes known
problems with the lint, which might explain an otherwise confusing false positive.</p>
<p>If you decide that a lint warning isn't relevant for your code, you can disable it either for that particular item
<a name="a004"></a>(<code>#[allow(clippy::some-lint)]</code>) or for the entire crate (<code>#![allow(clippy::some-lint)]</code>).  However, it's
usually better to take the cost of a minor refactoring of the code than to waste time and energy arguing about whether
the warning is a genuine false positive.</p>
<p>Whether you choose to fix or disable the warnings, you should <strong>make your code Clippy warning free</strong>.</p>
<p>That way, when new warnings appear â€“ whether because the code has been changed, or because Clippy has been
upgraded to include new checks â€“ they will be obvious. Clippy should also be enabled in your continuous
integration system (<a href="ci.html">Item 32</a>).</p>
<p>Clippy's warnings are particularly helpful when you're learning Rust, because they reveal gotchas you might not have
noticed, and help you become familiar with Rust idiom.</p>
<p>Many of the Items in this book also have corresponding Clippy warnings, when it's possible to mechanically check the
relevant concern:</p>
<ul>
<li><a href="use-types.html">Item 1</a> suggests using more expressive types than plain <code>bool</code>s, and Clippy will also point out the use of multiple
<a name="a005"></a><code>bool</code>s in <a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#fn_params_excessive_bools">function
parameters</a> and
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#struct_excessive_bools">structures</a>.</li>
<li><a href="transform.html">Item 3</a> covers manipulations of <a name="a006"></a><code>Option</code> and <a name="a007"></a><code>Result</code> types, and Clippy points out a few possible
redundancies, such as:
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#ok_expect">unnecessarily converting <code>Result</code> to
<code>Option</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#unwrap_or_else_default">opportunities to use
<code>unwrap_or_default</code></a>.</li>
</ul>
</li>
<li><a href="transform.html">Item 3</a> also suggest that errors should be returned to the caller where possible; Clippy <a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#unwrap_in_result">points out some missing
opportunities to do that</a>.</li>
<li><a href="std-traits.html">Item 5</a> described Rust's standard traits, and included some implementation requirements that Clippy checks:
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#derive_ord_xor_partial_ord"><code>Ord</code> must agree with
<code>PartialOrd</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#partialeq_ne_impl"><code>PartialEq::ne</code> should not need a non-default
implementation</a> (cf. <a href="default-impl.html">Item 13</a>)</li>
<li><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#derive_hash_xor_eq"><code>Hash</code> and <code>Eq</code> must be
consistent</a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#expl_impl_clone_on_copy"><code>Clone</code> for <code>Copy</code> types should
match</a>.</li>
</ul>
</li>
<li><a href="casts.html">Item 6</a> suggests implementing <a name="a008"></a><code>From</code> rather than <a name="a009"></a><code>Into</code>, which <a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#from_over_into">Clippy also
suggests</a>.</li>
<li><a href="casts.html">Item 6</a> also described <a name="a010"></a><a href="casts.html#casts">casts</a>, and Clippy can warn on:
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#cast_lossless"><code>as</code> casts that could be <code>from</code> instead</a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#cast_possible_truncation"><code>as</code> casts that might truncate</a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#cast_possible_wrap"><code>as</code> casts that might wrap</a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#cast_precision_loss"><code>as</code> casts that lose precision</a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#cast_sign_loss"><code>as</code> casts that might convert signed negative numbers to large positive
numbers</a></li>
<li><a name="a011"></a><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#as_conversions"><em>any</em> use of <code>as</code></a>
(disabled by default).</li>
</ul>
</li>
<li><a href="references.html">Item 9</a> describes <a name="a012"></a><a href="references.html#fat-pointer-types">fat pointer types</a>, and various Clippy
lints point out scenarios where there are unnecessary extra pointer indirection:
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#box_collection">holding a heap-allocated collection in a
<code>Box</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#vec_box">holding a heap-allocation collection of <code>Box</code>
items</a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#borrowed_box">taking a reference to a <code>Box</code></a>.</li>
</ul>
</li>
<li><a href="iterators.html">Item 10</a> describes the panoply of different ways to manipulate <a name="a013"></a><code>Iterator</code> instances; Clippy
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#explicit_counter_loop">includes</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#explicit_iter_loop">a</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#explicit_into_iter_loop">truly</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#filter_map_identity">astonishing</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#from_iter_instead_of_collect">number</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#into_iter_on_ref">of</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#iter_count">lints</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#iter_next_loop">that</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#iter_not_returning_iterator">point</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#manual_filter_map">out</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#manual_find_map">combinations</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#map_clone">of</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#needless_range_loop">iterator</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#search_is_some">methods</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#skip_while_next">that</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#suspicious_map">could</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#unnecessary_filter_map">be</a>
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#unnecessary_fold">simplified</a>.</li>
<li><a href="panic.html">Item 18</a> suggests limiting the use of
<a name="a014"></a><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#panic"><code>panic!</code></a> or related methods like
<a name="a015"></a><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#expect_used"><code>expect</code></a>, which Clippy also
detects.</li>
<li><a href="semver.html">Item 21</a> observes that importing a <a name="a016"></a>wildcard version of a crate isn't sensible; Clippy
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#wildcard_dependencies">agrees</a>.</li>
<li><a href="wildcard.html">Item 23</a> suggests avoiding <a name="a017"></a>wildcard imports, as does
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#wildcard_imports">Clippy</a>.</li>
<li><a href="re-export.html">Item 24</a> and <a href="dep-graph.html">Item 25</a> touch on the fact that multiple versions of the same crate can appear in your dependency graph;
Clippy can be configured to <a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#multiple_crate_versions">complain when this
happens</a>.</li>
<li><a href="features.html">Item 26</a> explains the additive nature of Cargo <a name="a018"></a>features, and Clippy includes a warning about <a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#negative_feature_names">&quot;negative&quot; feature
names</a> (e.g. <code>&quot;no-std&quot;</code>) that
are likely to indicate a feature that falls foul of this.</li>
<li><a href="features.html">Item 26</a> also explains that a crate's optional dependencies form part of its feature set, and Clippy warns if there
are <a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#redundant_feature_names">explicit feature names
(e.g. <code>&quot;use-crate-x&quot;</code>)</a> that
could just make use of this instead.</li>
<li><a href="documentation.html">Item 27</a> describes conventions for documentation comments, and Clippy will also point out:
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#missing_panics_doc">missing descriptions of <code>panic!</code>s</a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#missing_safety_doc">missing descriptions</a> of
<a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html#undocumented_unsafe_blocks"><code>unsafe</code> concerns</a>.</li>
</ul>
</li>
</ul>
<p>As the size of this list should make clear, it can be a valuable learning experience to <strong>read the <a href="https://rust-lang.github.io/rust-clippy/rust-1.60.0/index.html">list of Clippy
lint warnings</a></strong> â€“ including the
pedantic or high-false-positive checks that are disabled by default.  Even though you're unlikely to want to enable
these warnings for your code, understanding the reasons why they were written in the first place will improve your
understanding of Rust and its idiom.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-30-write-more-than-unit-tests"><a class="header" href="#item-30-write-more-than-unit-tests">Item 30: Write more than unit tests</a></h1>
<blockquote>
<p>&quot;All companies have test environments.</p>
<p>The lucky ones have production environments separate from the test environment.&quot; â€“
<a name="a001"></a><a href="https://twitter.com/FearlessSon/status/1405742580952834051">@FearlessSon</a></p>
</blockquote>
<p>Like most other modern languages, Rust includes features that make it easy to <a name="a002"></a><a href="https://doc.rust-lang.org/book/ch11-00-testing.html">write
tests</a> that live alongside your code,
and which give confidence that the code is working correctly.</p>
<p>This isn't the place to expound on the importance of tests; suffice it to say that if code isn't tested, it probably
doesn't work the way you think it does.  So this Item assumes that you're already signed up to <strong>write tests for your
code</strong>.</p>
<p>Unit tests and integration tests, described in the next two sections, are the key forms of test. However, the Rust
toolchain and extensions to it allow for various other types of test; this Item describes their distinct logistics and
rationales.</p>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h2>
<p>The most common form of test for Rust code is a <a name="a003"></a>unit test, which might look something like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_nat_subtract() {
        assert_eq!(nat_subtract(4, 3).unwrap(), 1);
        assert_eq!(nat_subtract(4, 5), None);
    }

    #[should_panic]
    #[test]
    fn test_something_that_panics() {
        nat_subtract_unchecked(4, 5);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Some aspects of this example will appear in every unit test:</p>
<ul>
<li>a collection of unit test functions, which areâ€¦</li>
<li>marked with the <code>#[test]</code> attribute, and included withinâ€¦</li>
<li>a <code>#[cfg(test)]</code> attribute, so the code only gets built in test configurations.</li>
</ul>
<p>Other aspects of this example illustrate things that are optional, and may only be relevant for particular tests:</p>
<ul>
<li>The test code here is held in a separate <a name="a004"></a>module, conventionally called <code>tests</code> or <code>test</code>.  This module may be
inline (as here), or held in a separate <code>tests.rs</code> file.</li>
<li>The test module may have a wildcard <code>use super::*</code> to pull in everything from the parent module under test.  This
makes it more convenient to add tests (and is an exception to the general advice of <a href="wildcard.html">Item 23</a> to avoid wildcard
imports).</li>
<li>A unit test has the ability to use anything from the parent module, whether it is <a name="a005"></a><code>pub</code> or not.  This allows for
&quot;whitebox&quot; testing of the code, where the unit tests exercise internal features that aren't visible to normal users.</li>
<li>The test code makes use of <code>unwrap()</code> for its expected results; the advice of <a href="panic.html">Item 18</a> isn't really relevant for
test-only code, where <code>panic!</code> is used to signal a failing test.  Similarly, the test code also checks expected
results with <code>assert_eq!</code>, which will panic on failure.</li>
<li>The code under test includes a function that panics on some kinds of invalid input, and the tests exercise that in a
test that's marked with the <code>#[should_panic]</code> attribute. This might be an internal function that normally expects the
rest of the code to respect its invariants and preconditions, or it might be a public function that has some reason
to ignore the advice of <a href="panic.html">Item 18</a>. (Such a function should have a &quot;Panics&quot; section in its doc comment, as described in
<a href="documentation.html">Item 27</a>.)</li>
</ul>
<p><a href="documentation.html">Item 27</a> suggests <em>not</em> documenting things that are already expressed by the type system; similarly, there's no need to
test things that are guaranteed by the type system. If your <code>enum</code> types start start holding values that aren't in the
list of allowed variants, you've got bigger problems than a failing unit test!</p>
<p>However, if your code relies on specific functionality from your dependencies, it can be helpful to include basic tests
of that functionality.  The aim here is not to repeat testing that's already done by the dependency itself, but instead
to have an early warning system that indicates whether it's safe to include a new version of that dependency in practice
â€“ separately from whether the <a name="a006"></a>semantic version number (<a href="semver.html">Item 21</a>) indicates that the new
version is safe in theory.</p>
<h2 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h2>
<p>The other common form of test included with a Rust project is <a name="a007"></a><em>integration tests</em>, held under
<code>tests/</code>.  Each file in that directory is run as a separate test program that executes all of the functions marked with
<code>#[test]</code>.</p>
<p>Integration tests do <em>not</em> have access to crate internals, and so act as black-box tests that can only exercise the
public API of the crate.</p>
<h2 id="doc-tests"><a class="header" href="#doc-tests">Doc Tests</a></h2>
<p><a href="documentation.html">Item 27</a> described the inclusion of short code samples in documentation comments, to illustrate the use of a particular
public API item.  Each such chunk of code is enclosed in an implicit <code>fn main() { ... }</code> and run as part of <code>cargo test</code>, effectively making it an additional test case for your code, known as a <a name="a008"></a><strong>doc test</strong>.  Individual
tests can also be executed selectively by running <code>cargo test --doc &lt;item-name&gt;</code>.</p>
<p>Assuming that you regularly run tests as part of your <a name="a009"></a>continuous integration environment (<a href="ci.html">Item 32</a>), this ensures
that your code samples don't drift too far from the current reality of your API.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p><a href="documentation.html">Item 27</a> also described the ability to provide example programs that exercise your public API. Each Rust file under
<code>examples/</code> (or each subdirectory under <code>examples/</code> that includes a <code>main.rs</code>) can be run as a standalone binary
with <code>cargo run --example &lt;name&gt;</code> or <code>cargo test --example &lt;name&gt;</code>.</p>
<p>These programs only have access to the public API of your crate, and are intended to illustrate the use of your API as a
whole.  Examples are not specifically designated as test code (no <code>#[test]</code>, no <code>#[cfg(test)]</code>), and they're a poor
place to put code that exercises obscure nooks and crannies of your crate â€“ particularly as examples are <strong>not</strong>
run by <code>cargo test</code> by default.</p>
<p>Nevertheless, it's a good idea to ensure that your <a name="a010"></a>continuous integration system (<a href="ci.html">Item 32</a>) builds and runs all
the associated examples for a crate (with <code>cargo test --examples</code>), because it can act as a good early warning system
for regressions that are likely to affect lots of users.  As noted above, if your examples demonstrate mainline use of
your API, then a failure in the examples implies that something significant is wrong.</p>
<ul>
<li>If it's a genuine <a name="a011"></a>bug, then it's likely to affect lots of users â€“ the
very nature of example code means that users are likely to have copied, pasted and adapted the example.</li>
<li>If it's an intended change to the API, then the examples need to be updated to match.  A change to the API also
implies a <a name="a012"></a>backwards incompatibility, so if the crate is published then the semantic version
number needs a corresponding update to indicate this (<a href="semver.html">Item 21</a>).</li>
</ul>
<p>The likelihood of users copying and pasting example code means that it should have a different style than test code. In
line with <a href="panic.html">Item 18</a>, you should set a good example for your users by avoiding <code>unwrap()</code> calls for
<a name="a013"></a><code>Result</code>s. Instead, make each example's <a name="a014"></a><code>main()</code> function return something like <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>, and then use the <a name="a015"></a>question mark operator throughout (<a href="transform.html">Item 3</a>).</p>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<p><a href="optimize.html">Item 20</a> attempts to persuade you that fully optimizing the performance of your code isn't always necessary.
Nevertheless, there are definitely still times when performance is critical, and if that's the case then it's a good
idea to measure and track that performance. Having <em><a name="a016"></a>benchmarks</em> that are run regularly (e.g. as part of continuous
integration, <a href="ci.html">Item 32</a>) allows you to detect when changes to the code or the toolchains adversely affect that
performance.</p>
<p>The <a name="a017"></a><a href="https://doc.rust-lang.org/cargo/commands/cargo-bench.html"><code>cargo bench</code></a> command<sup><a name="to-footnote-1"><a href="testing.html#footnote-1">1</a></a></sup> runs special test cases
that repeatedly perform an operation, and emits average timing information for the operation.</p>
<p>However, there's a danger that compiler optimizations may give misleading results, particularly if you restrict the
operation that's being performed to a small subset of the real code.  Consider a simple arithmetic function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn factorial(n: u128) -&gt; u128 {
        match n {
            0 =&gt; 1,
            n =&gt; n * factorial(n - 1),
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>A naÃ¯ve benchmark for this code:</p>
<pre><code class="language-rust ignore">    #[bench]
    fn bench_factorial(b: &amp;mut Bencher) {
        b.iter(|| {
            let result = factorial(15);
            assert_eq!(result, 1_307_674_368_000);
        });
    }</code></pre>
<p>gives incredibly positive results:</p>
<pre><code class="language-text">test naive::bench_factorial       ... bench:           0 ns/iter (+/- 0)
</code></pre>
<p>With fixed inputs and a small amount of code under test, the compiler is able to optimize away the iteration and
directly emit the result, leading to an unrealistically optimistic result.</p>
<p>The (experimental) <a name="a018"></a><a href="https://doc.rust-lang.org/std/hint/fn.black_box.html"><code>std::hint::black_box</code></a>
function can help with this; it's an identity function <a href="https://rust-lang.github.io/rfcs/2360-bench-black-box.html">whose implementation the compiler is &quot;encouraged, <em>but not
required</em>&quot;</a> (their italics) to pessimize.</p>
<p>Moving the code under test to use this hint:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(bench_black_box)] // nightly-only

<span class="boring">fn main() {
</span>pub fn factorial(n: u128) -&gt; u128 {
    match n {
        0 =&gt; 1,
        n =&gt; n * std::hint::black_box(factorial(n - 1)),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>gives more realistic results:</p>
<pre><code class="language-text">test bench_factorial              ... bench:          42 ns/iter (+/- 6)
</code></pre>
<p>The <a name="a019"></a><a href="https://rust.godbolt.org/">Godbolt compiler explorer</a> can also help by showing the actual machine code
emitted by the compiler, which may make it obvious when the compiler has performed optimizations that would be
unrealistic for code running a real scenario.</p>
<p>Finally, if you are including benchmarks for your Rust code, the <a name="a020"></a><a href="https://crates.io/crates/criterion">Criterion</a>
crate may provide an alternative to the standard
<a href="https://doc.rust-lang.org/test/bench/struct.Bencher.html"><code>test::Bencher</code></a> functionality which is:</p>
<ul>
<li>more convenient (it runs with stable Rust)</li>
<li>more fully-featured (it has support for statistics and graphs).</li>
</ul>
<h2 id="fuzz-testing"><a class="header" href="#fuzz-testing">Fuzz Testing</a></h2>
<p>Fuzz testing is the process of exposing code to randomized inputs in the hope of finding <a name="a021"></a>bugs, particularly
crashes that result from those inputs. Although this can be a useful technique in general, it becomes much more
important when your code is exposed to inputs that may be controlled by someone who is deliberately trying to attack the
code â€“ so you should <strong>run <a name="a022"></a>fuzz tests if your code is exposed to potential attackers</strong>.</p>
<p>Historically, the majority of defects in C/<a name="a023"></a>C++ code that have been exposed by fuzzers have been memory safety problems,
typically found by combining fuzz testing with runtime instrumentation (e.g.
<a name="a024"></a><a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer</a> or
<a name="a025"></a><a href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a>) of memory access patterns.</p>
<p>Rust is immune to some (but not all) of these memory safety problems, particularly when there is no <a name="a026"></a><code>unsafe</code> code
involved (<a href="unsafe.html">Item 16</a>).  However, Rust does not prevent bugs in general, and a code path that triggers a <a name="a027"></a><code>panic!</code>
(cf. <a href="panic.html">Item 18</a>) can still result in a denial-of-service (DoS) attack on the codebase as a whole.</p>
<p>The most effective forms of fuzz testing are <em>coverage-guided</em>: the test infrastructure monitors which parts of the code
are executed, and favours random mutations of the inputs that explore new code paths.  <a name="a028"></a><a href="https://lcamtuf.coredump.cx/afl/">&quot;American fuzzy lop&quot;
(AFL)</a> was the original heavyweight champion of this technique, but in more recent
years equivalent functionality has been included into the LLVM toolchain as
<a name="a029"></a><a href="https://llvm.org/docs/LibFuzzer.html"><code>libFuzzer</code></a>.</p>
<p>The Rust compiler is built on LLVM, and so the <a name="a030"></a><a href="https://github.com/rust-fuzz/cargo-fuzz"><code>cargo-fuzz</code></a> sub-command
exposes <code>libFuzzer</code> functionality for Rust (albeit only for a limited number of platforms).</p>
<p>To set up a fuzz test, first identify an entrypoint of your code that takes (or can be adapted to take) arbitrary bytes
of data as input:</p>
<pre><pre class="playground"><code class="language-rust panics"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Determine if the input starts with &quot;FUZZ&quot;.
fn is_fuzz(data: &amp;[u8]) -&gt; bool {
    if data.len() &gt;= 3 /* oops */
        &amp;&amp; data[0] == b'F'
        &amp;&amp; data[1] == b'U'
        &amp;&amp; data[2] == b'Z'
        &amp;&amp; data[3] == b'Z'
    {
        true
    } else {
        false
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Next, write a small driver that connects this entrypoint to the fuzzing infrastructure:</p>
<pre><code class="language-rust ignore">fuzz_target!(|data: &amp;[u8]| {
    let _ = is_fuzz(data);
});</code></pre>
<p>Running <code>cargo +nightly fuzz run target1</code> continuously executes the fuzz target with random data, only stopping if a
crash is found.  In this case, a failure is found almost immediately:</p>
<pre><code class="language-text">INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 1139733386
INFO: Loaded 1 modules   (1596 inline 8-bit counters): 1596 [0x10cba9c60, 0x10cbaa29c), 
INFO: Loaded 1 PC tables (1596 PCs): 1596 [0x10cbaa2a0,0x10cbb0660), 
INFO:        7 files found in /Users/dmd/src/effective-rust/examples/testing/fuzz/corpus/target1
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
INFO: seed corpus: files: 7 min: 1b max: 8b total: 34b rss: 38Mb
#8	INITED cov: 22 ft: 22 corp: 6/26b exec/s: 0 rss: 38Mb
thread '&lt;unnamed&gt;' panicked at 'index out of bounds: the len is 3 but the index is 3', fuzz_targets/target1.rs:11:12
stack backtrace:
   0: rust_begin_unwind
             at /rustc/f77bfb7336f21bfe6a5fb5f7358d4406e2597289/library/std/src/panicking.rs:579:5
   1: core::panicking::panic_fmt
             at /rustc/f77bfb7336f21bfe6a5fb5f7358d4406e2597289/library/core/src/panicking.rs:64:14
   2: core::panicking::panic_bounds_check
             at /rustc/f77bfb7336f21bfe6a5fb5f7358d4406e2597289/library/core/src/panicking.rs:159:5
   3: _rust_fuzzer_test_input
   4: ___rust_try
   5: _LLVMFuzzerTestOneInput
   6: __ZN6fuzzer6Fuzzer15ExecuteCallbackEPKhm
   7: __ZN6fuzzer6Fuzzer6RunOneEPKhmbPNS_9InputInfoEbPb
   8: __ZN6fuzzer6Fuzzer16MutateAndTestOneEv
   9: __ZN6fuzzer6Fuzzer4LoopERNSt3__16vectorINS_9SizedFileENS_16fuzzer_allocatorIS3_EEEE
  10: __ZN6fuzzer12FuzzerDriverEPiPPPcPFiPKhmE
  11: _main
</code></pre>
<p>and the input that triggered the failure is emitted.</p>
<p>Normally, fuzz testing does not find failures so quickly, and so it does <em>not</em> make sense to run fuzz tests as part of
your <a name="a031"></a>continuous integration.  The open-ended nature of the testing, and the consequent compute costs, mean that you need
to consider how and when to run fuzz tests â€“ perhaps only for new releases or major changes, or perhaps for a
limited period of time<sup><a name="to-footnote-2"><a href="testing.html#footnote-2">2</a></a></sup>.</p>
<p>You can also make subsequent runs of the fuzzing infrastructure more efficient, by storing and re-using a <em><a name="a033"></a>corpus</em> of
previous inputs which the fuzzer found to explore new code paths; this helps subsequent runs of the fuzzer explore new
ground, rather than re-testing code paths previously visited.</p>
<h2 id="testing-advice"><a class="header" href="#testing-advice">Testing Advice</a></h2>
<p>An Item about testing wouldn't be complete without repeating some common advice (which is mostly not Rust-specific):</p>
<ul>
<li>As this Item has endlessly repeated, <strong>run all your tests in continuous integration on every change</strong> (with the
exception of fuzz tests).</li>
<li>When you're fixing a bug, <strong>write a test that exhibits the bug before fixing the <a name="a034"></a>bug</strong>.  That way you can be sure that
the bug is fixed, and that it won't be accidentally re-introduced in future.</li>
<li>If your crate has features (<a href="features.html">Item 26</a>), <strong>run tests over every possible combination of available features</strong>.</li>
<li>More generally, if your crate includes any config-specific code (e.g. <code>#[cfg(target_os = &quot;windows&quot;)]</code>), <strong>run tests
for every platform</strong> that has distinct code.</li>
</ul>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>This Item has covered a lot of different types of test, so a summary is in order:</p>
<ul>
<li>Write unit tests for comprehensive testing that includes testing of internal-only code; run with <code>cargo test</code>.</li>
<li>Write integration tests to exercise your public API; run with <code>cargo test</code>.</li>
<li>Write doc tests that exemplify how to use individual items in your public API; run with <code>cargo test</code>.</li>
<li>Write example programs that show how to use your public API as a whole; run with <code>cargo test --examples</code> or <code>cargo run --example &lt;name&gt;</code>.</li>
<li>Write benchmarks if your code has significant performance requirements; run with <code>cargo bench</code>.</li>
<li>Write fuzz tests if your code is exposed to untrusted inputs; run (continuously) with <code>cargo fuzz</code>.</li>
</ul>
<p>That's a lot of different types of test, so it's up to you how much each of them is relevant and worthwhile for your
project.</p>
<p>If you have a lot of test code and you are publishing your crate to <a name="a035"></a><a href="https://crates.io"><code>crates.io</code></a>,
then you might need to consider which of the tests make sense to include in the published crate.  By default, <code>cargo</code>
will include unit tests, integration tests, benchmarks and examples (but not fuzz tests), which may be more than end
users need.  If that's the case, you can either
<a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-exclude-and-include-fields"><code>exclude</code></a> some of the files,
or (for black-box tests) move the tests out of the crate and into a separate test crate.</p>
<p><hr/>
<p><a name="footnote-1"><a href="testing.html#to-footnote-1">1</a></a>: Support for benchmarks is not stable, so the command may need to be <code>cargo +nightly bench</code>.</p>
<p><a name="footnote-2"><a href="testing.html#to-footnote-2">2</a></a>: If your code is a widely-used open-source crate, the <a name="a032"></a><a href="https://google.github.io/oss-fuzz/getting-started/accepting-new-projects/">Google OSS-Fuzz
program</a> may be willing to run fuzzing on
your behalf.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-31-take-advantage-of-the-tooling-ecosystem"><a class="header" href="#item-31-take-advantage-of-the-tooling-ecosystem">Item 31: Take advantage of the tooling ecosystem</a></h1>
<p>The Rust ecosystem has a rich collection of additional tools above and beyond the essential task of converting Rust into
machine code, many of which help with the wider task of maintaining a codebase, and improving the quality of that
codebase.</p>
<p>The <a href="https://doc.rust-lang.org/cargo/commands/index.html">tools that are present</a> in the official Cargo toolchain cover
various essential tasks beyond the basics of <code>cargo build</code>, <code>cargo test</code> and <code>cargo run</code>.  For example:</p>
<ul>
<li><a name="a001"></a><code>cargo fmt</code><a name="a002"></a><a name="a003"></a> reformats Rust code according to standard conventions.</li>
<li><a name="a004"></a><code>cargo check</code> performs compilation checks without generating machine code, which can be useful to get a quick
syntax check.</li>
<li><a name="a005"></a><code>cargo clippy</code> performs lint checks, detecting inefficient or unidiomatic code (<a href="clippy.html">Item 29</a>).</li>
<li><a name="a006"></a><code>cargo doc</code> generates documentation (<a href="documentation.html">Item 27</a>).</li>
<li><a name="a007"></a><code>cargo bench</code> runs benchmarking tests (<a href="testing.html">Item 30</a>).</li>
<li><a name="a008"></a><code>cargo update</code> upgrades dependencies to the latest versions compliant with <a name="a009"></a>semantic versioning (<a href="semver.html">Item 21</a>).</li>
<li><a name="a010"></a><code>cargo tree</code> displays the dependency graph (<a href="dep-graph.html">Item 25</a>).</li>
<li><a name="a011"></a><code>cargo metadata</code> emits metadata about the packages present in the workspace, and their dependencies.</li>
</ul>
<p>The last of these is particularly useful, albeit indirectly: because there's a tool that emits information about crates
in a well-defined format, it's much easier for people to produce other tools that make use of that information
(typically via the <a name="a012"></a><a href="https://docs.rs/cargo_metadata/latest/cargo_metadata/"><code>cargo_metadata</code></a> crate, which provides
a set of Rust types to hold the metadata information).</p>
<p><a href="dep-graph.html">Item 25</a> described some of the tools that are enabled by this metadata availability, such as <a name="a013"></a><code>cargo-udeps</code> (which
allows detection of unused dependencies), or <a name="a014"></a><code>cargo-deny</code> (which allows checks for many things, including
duplicate dependencies, allowed licenses and security advisories).</p>
<p>The extensibility of the Rust toolchain is not just limited to package metadata; the compiler's <a name="a015"></a>abstract syntax
tree can also be built upon, <a href="https://crates.io/crates/syn/reverse_dependencies">often via</a> the
<a name="a016"></a><a href="https://docs.rs/syn"><code>syn</code></a> crate.  This information is what makes procedural macros (<a href="macros.html">Item 28</a>) so potent, but
also powers a variety of other tools, for example:</p>
<ul>
<li><a name="a017"></a><a href="https://github.com/dtolnay/cargo-expand"><code>cargo-expand</code></a> shows the complete source code produced by macro
expansion, which can be essential for debugging tricky macro definitions.</li>
<li><a name="a018"></a><a href="https://docs.rs/cargo-tarpaulin"><code>cargo-tarpaulin</code></a> supports the generation and tracking of code coverage
information.</li>
</ul>
<p>Any list of specific tools will always be subjective, out-of-date, and incomplete; the more general point is to
<strong>explore the available tools</strong>.</p>
<p>For example, a <a href="https://docs.rs/releases/search?query=cargo-">search for <code>cargo-&lt;something&gt;</code> tools</a> gives dozens of
results; some will be inappropriate, some will be abandoned, but some might just do exactly what you want.</p>
<p>There are also various efforts to <a name="a019"></a><a name="a020"></a><a href="https://alastairreid.github.io/automatic-rust-verification-tools-2021">apply formal verification to Rust
code</a>, which may be helpful if your code needs
higher levels of assurance about its correctness.</p>
<p>Finally, a reminder: if a tool is useful on more than a one-off basis, you should <strong>integrate the tool into your
continuous integration system</strong> (as per <a href="ci.html">Item 32</a>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-32-set-up-a-continuous-integration-ci-system"><a class="header" href="#item-32-set-up-a-continuous-integration-ci-system">Item 32: Set up a continuous integration (CI) system</a></h1>
<p>A <em><a name="a001"></a>continuous integration</em> (CI) system is a mechanism for automatically running tools over your codebase, which is
triggered whenever there's a change to the codebase â€“ or a proposed change to the codebase.</p>
<p>The recommendation to <strong>set up a continuous integration system</strong> is not at all Rust-specific, so this Item is a melange of
general advice mixed with Rust-specific tool suggestions.</p>
<h2 id="ci-steps"><a class="header" href="#ci-steps">CI Steps</a></h2>
<p>Starting with the specific, what kinds of steps should be included in your CI system?  The obvious initial candidates
are to:</p>
<ul>
<li>Build the code.</li>
<li>Run the tests for the code.</li>
</ul>
<p>In each case, a CI step should run cleanly, quickly, deterministically and with a zero false positive rate; more on this
in the next section.</p>
<p>Throughout this book, various Items have suggested tools and techniques that can help improve your codebase; wherever
possible, encode these as CI steps:</p>
<ul>
<li><a href="testing.html">Item 30</a> described the various different styles of test; <strong>run all test types in CI</strong>.
<ul>
<li>Some test types are automatically included in <code>cargo test</code>: <a name="a002"></a>unit tests, <a name="a003"></a>integration tests and <a name="a004"></a>doc tests.</li>
<li>Other test types (e.g. example programs) may need to be explicitly triggered.</li>
</ul>
</li>
<li><a href="clippy.html">Item 29</a> waxed lyrical about the advantages of running <a name="a005"></a>Clippy over your code; <strong>run Clippy in CI</strong>.</li>
<li><a href="documentation.html">Item 27</a> suggested documenting your public API; use the <a name="a006"></a><code>cargo doc</code> tool to check that the documentation
generates correctly and that any hyperlinks in it resolve correctly.</li>
<li><a href="semver.html">Item 21</a> included a discussion around declaring a <a name="a007"></a>minimum supported Rust version (MSRV) for your code. If you
have this, <strong>check your MSRV in CI</strong> by including a step that tests with that specific Rust version.</li>
<li><a href="semver.html">Item 21</a> also described the <a name="a008"></a><code>-Z minimal-versions</code> flag for Cargo's dependency resolution;
<strong>include a CI step that checks semver lower bounds are accurate</strong>.</li>
<li><a href="features.html">Item 26</a> described the use of <em><a name="a009"></a>features</em> to conditionally include different chunks of code. If your crate has
features, <strong>build every valid combination of features in CI</strong> (and realize that this may involve 2<sup>N</sup>
different variants â€“ hence the advice to avoid feature creep).</li>
<li><a href="dep-graph.html">Item 25</a> mentioned tools such as <a name="a010"></a><code>cargo-udeps</code> and <a name="a011"></a><code>cargo-deny</code> that can help manage your dependency
graph; running these as a CI step prevents regressions.</li>
<li><a href="use-tools.html">Item 31</a> discussed the Rust tool ecosystem; consider which of these tools are worth regularly running over your
codebase.  For example, running <a name="a012"></a><code>rustfmt</code> / <code>cargo fmt</code> in CI will detect code that doesn't comply with your
project's style guidelines.</li>
<li><a href="no-std.html">Item 33</a> suggests that you consider making library code <a name="a013"></a><code>no_std</code> compatible where possible. You can only be
confident that your code genuinely is <code>no_std</code> compatible if you <strong>test <code>no_std</code> compatibility in CI</strong>; one option is
to make use of the Rust compiler's cross-compilation abilities, and build for an explicitly <code>no_std</code> target
(e.g. <code>thumbv6m-none-eabi</code>).</li>
</ul>
<p>You can also include CI steps that measure particular aspects of your code:</p>
<ul>
<li>Generate code coverage statistics (e.g. with <a name="a014"></a><a href="https://docs.rs/cargo-tarpaulin"><code>cargo-tarpaulin</code></a>), to show what
proportion of your codebase is exercised by your tests.</li>
<li>Run benchmarks (e.g. with <a name="a015"></a><code>cargo-bench</code>, <a href="testing.html">Item 30</a>), to measure the performance of your code on key scenarios.</li>
</ul>
<p>These suggestions are a bit more complicated to set up, because the output of the CI step is more useful when it's
compared to previous results â€“ in an ideal world, the CI system will detect when a code change is not fully
tested, or has an adverse affect on performance, and this typically involves integration with some external tracking
system.</p>
<p>Some other suggestions for CI steps that may or may not be relevant for your codebase include:</p>
<ul>
<li>If your project is a library, recall (from <a href="dep-graph.html">Item 25</a>) that any checked-in <a name="a016"></a><code>Cargo.lock</code> file will be ignored by
the users of your library. In theory, the semantic version constraints (<a href="semver.html">Item 21</a>) in <code>Cargo.toml</code> should mean that
everything works correctly anyway; in practice, consider including:
<ul>
<li>A CI step that builds without any local <code>Cargo.lock</code>, to detect whether the current versions of dependencies still
work correctly.</li>
<li>A CI step that uses the <a href="https://doc.rust-lang.org/cargo/reference/unstable.html?highlight=minimal-versions#minimal-versions"><code>-Z minimal-versions</code>
option</a> to
detect whether the minimum matching versions of dependencies work correctly.</li>
</ul>
</li>
<li>If your project includes any kind of machine-generated resources that are version-controlled (for example, code
generated from <a name="a017"></a>protocol buffer messages by <a name="a018"></a><a href="https://docs.rs/prost"><code>prost</code></a>), then include a CI step that
re-generates the resources and checks that there are no differences compared to the checked-in version.</li>
<li>If your codebase includes platform-specific (e.g. <code>#[cfg(target_arch = &quot;arm&quot;)]</code>) code, run CI steps that confirm that
the code builds and works on that platform.</li>
<li>If your project manipulates secret values such as access tokens or cryptographic keys, consider including a CI step
that searches the codebase for secrets that have been inadvertantly checked in.  This is particularly important if
your project is public (in which case it may be worth moving the check from CI to a <a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">version control presubmit
check</a>).</li>
</ul>
<p>Continuous integration checks don't always need to be integrated with Cargo and the Rust toolchains; sometimes a simple
shell script can give more bang for the buck, particularly when a codebase has a local convention that's not universally
followed.  For example, a codebase might include a convention that any panic-inducing method invocation (<a href="panic.html">Item 18</a>) has a
special marker comment or that every <code>TODO:</code> comment has an owner (a person or a tracking ID); a shell script is ideal
for checking this.</p>
<p>Finally, consider examining the CI systems of public Rust projects to get ideas for additional CI steps that might be
useful for your project.  For example, Rust itself has an <a href="https://github.com/rust-lang/rust/blob/master/.github/workflows/ci.yml">extensive CI
system</a> that includes dozens of steps; most of
these steps are overkill for a smaller project, but some may be useful.</p>
<h2 id="ci-principles"><a class="header" href="#ci-principles">CI Principles</a></h2>
<p>Moving from the specific to the general, there are some general principles that should guide the details of your
continuous integration system.</p>
<p>The most fundamental principle is: <strong>don't waste the time of humans</strong>.  If a CI system unnecessarily wastes people's
time, they will start looking for ways to avoid it.</p>
<p>The most annoying waste of engineer's time is tests that are <a name="a019"></a><em>flaky</em>: sometimes they pass, sometimes
they fail, even when the setup and codebase is identical. Whenever possible, be ruthless with flaky tests: hunt them
down and put in the time up-front to investigate and fix the cause of the flakiness â€“ it will pay for itself in
the long run.</p>
<p>Another common waste of engineering time is a continuous integration system that takes a long time to run, and which
only runs <em>after</em> a request for a code review has been triggered.  In this sitation, there's the potential to waste two
people's time: both the author and also the code reviewer, who may spend time spotting and pointing out issues with the
code that the CI bots could have flagged.</p>
<p>To help with this, try to make it easy to run the CI checks manually, independent from the automated system. This allows
engineers to get into the habit of triggering them regularly, so that code reviewers never even see problems that the CI
would have flagged.</p>
<p>This may also require splitting the checks up (&quot;Testing, Fast and Slow&quot;) if there are time-consuming tests that rarely
find problems, but which are there as a back-stop to prevent obscure scenarios breaking.</p>
<p>However, it's important that the CI system be integrated with whatever code review system is used for your project, so
that a code review can clearly see a green set of checks and be confident that their code review can focus on the
important meaning of the code, not on trivial details.</p>
<p>This need for a green build also means that there can be no exceptions to whatever checks your CI system has put in
place.  This is worthwhile even if you have to work around an occasional false positive from a tool; once your CI system
has an accepted failure (&quot;oh, everyone knows that test never passes&quot;) then it's vastly harder to spot new regressions.</p>
<p><a href="testing.html">Item 30</a> included the common advice of adding a test to reproduce a bug, before fixing the <a name="a020"></a>bug. The same principle
applies to your CI system, applied to problems with your processes and codebase as a whole, rather than specific lines
of code.  If you discover a process-like problem, then think about how the continuous integration could have caught the
problem, and add that extra step before fixing the problem (and seeing the build turn green).</p>
<h2 id="public-ci-systems"><a class="header" href="#public-ci-systems">Public CI Systems</a></h2>
<p>If your codebase is open-source and visible to the public, there are a few extra things to think about with your
continuous integration system.</p>
<p>First is the good news: there are lots of free, reliable options for building a continuous integration system for
open-source code.  At the time of writing, <a name="a021"></a><a href="https://docs.github.com/en/actions">GitHub Actions</a> are probably the
best choice, but it's far from the only choice, and more systems appear all the time.</p>
<p>Secondly, for open-source code it's worth bearing in mind that your CI system can act as a guide for how to set up any
prerequisites needed for the codebase.  This isn't a concern for pure Rust crates, but if your codebase requires
additional dependencies â€“ databases, alternative toolchains for FFI code, configuration, etc. â€“ then your
CI scripts will be an existence proof of how to get all of that working on a fresh system. Encoding these setup steps in
re-usable scripts allows both the humans and the bots to get a working system in a straightforward way.</p>
<p>Finally, there's bad news for publicly visible crates: the possibility of abuse and attacks. This can range from
attempts to perform cryptocurrency mining in your CI system, to <a href="https://web.archive.org/web/20220315064116/https://about.codecov.io/security-update/">theft of codebase access
tokens</a>, <a name="a022"></a>supply chain
attacks and worse. To mitigate these risks, consider:</p>
<ul>
<li>Restricting access so that continuous integration scripts only run automatically for known collaborators, and have to
be triggered manually for new contributors.</li>
<li>Pinning the versions of any external scripts to particular versions, or (better yet) specific known hashes.</li>
<li>Closely monitoring any integration steps that need more than just read access to the codebase.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="beyond-standard-rust"><a class="header" href="#beyond-standard-rust">Beyond Standard Rust</a></h1>
<p>The Rust toolchain includes support for a much wider variety of environments than just pure Rust application code
running in userspace.</p>
<ul>
<li>It supports <em><a name="a001"></a>cross-compilation</em>, where the system running the toolchain (the <em>host</em>) is not the same as
the system that the compiled code will run on (the <em>target</em>), which makes it easy to target embedded systems.</li>
<li>It supports linking with code compiled from languages other than Rust, via built-in <a name="a002"></a>foreign function interface
(FFI) capabilities.</li>
<li>It supports configurations without the full standard library <code>std</code>, allowing systems that do not have a full operating
system (e.g. no filesystem, no networking) to be targetted.</li>
<li>It even supports configurations that do not support heap allocation, but which only have a stack.</li>
</ul>
<p>These non-standard Rust environments are less safe â€“ they are often even <code>unsafe</code> â€“ but give more options
for getting the job done.</p>
<p>This part of the book discusses just a few of the basics for working in these environments. Beyond these basics, you'll
need to consult more environment-specific documentation (such as the
<a name="a003"></a><a href="https://doc.rust-lang.org/nomicon/"><em>Rustonomicon</em></a>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-33-consider-making-library-code-no_std-compatible"><a class="header" href="#item-33-consider-making-library-code-no_std-compatible">Item 33: Consider making library code <code>no_std</code> compatible</a></h1>
<p>Rust comes with a standard library called <a name="a001"></a><code>std</code>, which includes code for a wide variety of common tasks, from standard
data structures to networking, from multi-threading support to file I/O.  For convenience, many of the items from <code>std</code>
are automatically imported into your program, via the
<a name="a002"></a><a href="https://doc.rust-lang.org/std/prelude/index.html"><em>prelude</em></a>: a set of common <a name="a003"></a><code>use</code> statements.</p>
<p>Rust also supports building code for environments where it's not possible to provide this full standard library, such as
bootloaders, firmware, or embedded platforms in general.  Crates indicate that they should be built in this way by
including the <a name="a004"></a><code>#![no_std]</code> crate-level attribute at the top of <code>src/lib.rs</code>.</p>
<p>This Item explores what's lost when building for <code>no_std</code>, and what library functions you can still rely on â€“
which turns out to be quite a lot.</p>
<p>However, this Item is specifically about <code>no_std</code> support in <em>library</em> code.  The difficulties of making a <code>no_std</code>
<em>binary</em> are beyond this text, so the focus here is how to make sure that library code is available for those poor souls
who work in such a minimal environment.</p>
<h2 id="core"><a class="header" href="#core"><code>core</code></a></h2>
<p>Even when building for the most restricted of platforms, many of the fundamental types from the standard library are
still available.  For example, <a name="a005"></a><a href="https://doc.rust-lang.org/core/option/enum.Option.html"><code>Option</code></a> and
<a name="a006"></a><a href="https://doc.rust-lang.org/core/result/enum.Result.html"><code>Result</code></a> are still available, albeit under a different
name, as are various flavours of <a name="a007"></a><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a>.</p>
<p>The different names for these fundamental types starts with <code>core::</code>, indicating that they come from the <a name="a008"></a><code>core</code>
library, a standard library that's available even in the most <code>no_std</code> of environments. These <code>core::</code> types behave
exactly the same as the equivalent <code>std::</code> types, because they're actually the same types â€“ in each case, the
<code>std::</code> version is just a <a name="a009"></a>re-export of the underlying <code>core::</code> type.</p>
<p>This means that there's an easy way to tell if a <code>std::</code> item is available in <code>no_std</code> environment: visit the
<a href="https://doc.rust-lang.org"><code>doc.rust-lang.org</code></a> page for the <code>std</code> item you're interested in, and follow the &quot;source&quot;
link (at the top-right).  If that takes you to a <code>src/core/...</code> location, then the item is available under <code>no_std</code> via
<code>core::</code>.</p>
<p>The types from <code>core</code> are available for all Rust programs automatically; however, they typically need to be
explicitly <code>use</code>d in a <code>no_std</code> environment, because the <code>std</code> <a name="a010"></a>prelude is absent.</p>
<p>In practice, relying purely on <code>core</code> is too limiting for many environments, even <code>no_std</code> ones.  This is because a
core<sup><a name="to-footnote-1"><a href="no-std.html#footnote-1">1</a></a></sup> constraint of <code>core</code> is that it performs <strong>no heap allocation</strong>.</p>
<p>Although Rust excels at putting items on the stack, and safely tracking the corresponding lifetimes (<a href="lifetimes.html">Item 14</a>), this
restriction still means that that standard data structures â€“ vectors, maps, sets â€“ can't be provided,
because they need to allocate <a name="a011"></a>heap space for their contents.  In turn, this also drastically reduces the number of
available crates that work in this environment.</p>
<h2 id="alloc"><a class="header" href="#alloc"><code>alloc</code></a></h2>
<p>However, if a <code>no_std</code> environment <em>does</em> support heap allocation, then many of the standard data structures from <code>std</code> can
still be supported.  These data structures, along with other allocation-using functionality, is grouped into Rust's
<a name="a012"></a><a href="https://doc.rust-lang.org/stable/alloc/"><code>alloc</code></a> library.</p>
<p>As with <code>core</code>, these <code>alloc</code> variants are actually the same types under the covers; for example, following the <a href="https://doc.rust-lang.org/stable/src/alloc/vec/mod.rs.html">source
link</a> from the documentation for
<a name="a013"></a><a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>std::vec::Vec</code></a> leads to a <code>src/alloc/...</code> location.</p>
<p>A <code>no_std</code> Rust crate needs to explicitly opt-in to the use of <code>alloc</code>, by adding an <a name="a014"></a><code>extern crate alloc;</code> declaration<sup><a name="to-footnote-2"><a href="no-std.html#footnote-2">2</a></a></sup> to <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">//! My `no_std` compatible crate.
#![no_std]

// Requires `alloc`.
extern crate alloc;</code></pre>
<p>Functionality that's enabled by turning on <code>alloc</code> includes many familiar friends, now addressed by their true names:</p>
<ul>
<li><a name="a015"></a><a href="https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html"><code>alloc::boxed::Box&lt;T&gt;</code></a></li>
<li><a name="a016"></a><a href="https://doc.rust-lang.org/stable/alloc/rc/struct.Rc.html"><code>alloc::rc::Rc&lt;T&gt;</code></a></li>
<li><a name="a017"></a><a href="https://doc.rust-lang.org/alloc/sync/struct.Arc.html"><code>alloc::sync::Arc&lt;T&gt;</code></a></li>
<li><a name="a018"></a><a href="https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html"><code>alloc::vec::Vec&lt;T&gt;</code></a></li>
<li><a name="a019"></a><a href="https://doc.rust-lang.org/stable/alloc/string/struct.String.html"><code>alloc::string::String</code></a></li>
<li><a name="a020"></a><a href="https://doc.rust-lang.org/stable/alloc/macro.format.html"><code>format!</code></a></li>
<li><a name="a021"></a><a href="https://doc.rust-lang.org/stable/alloc/collections/btree_map/struct.BTreeMap.html"><code>alloc::collections::BTreeMap&lt;K, V&gt;</code></a></li>
<li><a name="a022"></a><a href="https://doc.rust-lang.org/stable/alloc/collections/btree_set/struct.BTreeSet.html"><code>alloc::collections::BTreeSet&lt;T&gt;</code></a></li>
</ul>
<p>With these things available, it becomes possible for many library crates to be <code>no_std</code> compatible â€“ e.g. for libraries
that don't involve I/O or networking.</p>
<p>There's a notable absence from the data structures that <code>alloc</code> makes available, though â€“ the
collections
<a name="a023"></a><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> and
<a name="a024"></a><a href="https://doc.rust-lang.org/std/collections/hash_set/struct.HashSet.html"><code>HashSet</code></a> are specific to <code>std</code>, not <code>alloc</code>.
That's because these hash-based containers rely on random seeds to protect against hash collision attacks, but safe random
number generation requires assistance from the operating system â€“ which <code>alloc</code> can't assume exists.</p>
<p>Another notable absence is synchronization functionality like
<a name="a025"></a><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>std::sync::Mutex</code></a>, which is required for
multi-threaded code (<a href="deadlock.html">Item 17</a>).  These types are specific to <a name="a026"></a><code>std</code> because they rely on OS-specific synchronization
primitives, which aren't available without an OS.  If you need to write code that is both <code>no_std</code> and multi-threaded,
third-party crates such as <a name="a027"></a><a href="https://docs.rs/spin/"><code>spin</code></a> are probably your only option.</p>
<h2 id="writing-code-for-no_std"><a class="header" href="#writing-code-for-no_std">Writing Code for <code>no_std</code></a></h2>
<p>The previous sections made it clear that for <em>some</em> library crates, making the code <code>no_std</code> compatible just involves:</p>
<ul>
<li>Replacing <code>std::</code> types with identical <code>core::</code> or <code>alloc::</code> crates (which requires <a name="a028"></a><code>use</code> of the full type name,
due to the absence of the <code>std</code> <a name="a029"></a>prelude).</li>
<li>Shifting from <code>HashMap</code> / <code>HashSet</code> to <code>BTreeMap</code> / <code>BTreeSet</code>.</li>
</ul>
<p>However, this only makes sense if all of the crates that you depend on (<a href="dep-graph.html">Item 25</a>) are also <code>no_std</code> compatible â€“
there's no point in becoming <code>no_std</code> compatible if any user of your crate is forced to link in <code>std</code> anyway.</p>
<p>There's also a catch here: the Rust compiler will not tell you if your <code>no_std</code> crate depends on a <code>std</code>-using
dependency. This means that it's easy for the work of making a crate <code>no_std</code>-compatible to be undone â€“ all it
takes is an added or updated dependency that pulls in <code>std</code>.</p>
<p>To protect against this, <strong>add a CI check for a <code>no_std</code> build</strong>, so that your <a name="a030"></a>CI system (<a href="ci.html">Item 32</a>) will warn you if
this happens.  The Rust toolchain supports cross-compilation out of the box, so this can be as simple as performing a
<a href="https://www.reddit.com/r/rust/comments/ef8nd9/how_to_avoid_accidentally_breaking_no_std/fbyz6ix/">cross-compile</a> for a
target system (e.g. <code>--target thumbv6m-none-eabi</code>) that does not support <code>std</code> â€“ any code that inadvertently
requires <code>std</code> will then fail to compile for this target.</p>
<p>So: if your dependencies support it, and the simple transformations above are all that's needed, then <strong>consider making
library code <code>no_std</code> compatible</strong>.  When it is possible, it's not much additional work and it allows for the widest
re-use of the library.</p>
<p>If those transformations <em>don't</em> cover all of the code in your crate, but the parts that aren't covered are only a small
or well-contained fraction of the code, then consider adding a <a name="a031"></a>feature (<a href="features.html">Item 26</a>) to your crate that turns on just
those parts.</p>
<p>Such a feature is conventionally named either <code>std</code>, if it enables use of <code>std</code>-specific functionality:</p>
<pre><code class="language-rust ignore">#![cfg_attr(not(feature = &quot;std&quot;), no_std)]</code></pre>
<p>or <code>alloc</code>, if it turns on use of <code>alloc</code>-derived function:</p>
<pre><code class="language-rust ignore">#[cfg(feature = &quot;alloc&quot;)]
extern crate alloc;</code></pre>
<p>As ever with feature-gated code (<a href="features.html">Item 26</a>), make sure that your CI system builds all the relevant combinations â€“
including a build with the <code>std</code> feature disabled on an explicitly <code>no_std</code> platform.</p>
<h2 id="fallible-allocation"><a class="header" href="#fallible-allocation">Fallible Allocation</a></h2>
<p>The earlier sections of this Item considered two different <code>no_std</code> environments: a fully embedded environment with no
heap allocation whatsoever (<code>core</code>), or a more generous environment where heap allocation is allowed (<code>core</code> +
<code>alloc</code>).  However, there are some important environments that fall between these two camps.</p>
<p>In particular, Rust's standard <a name="a032"></a><code>alloc</code> library includes a pervasive assumption that <a name="a033"></a>heap allocations cannot fail, and that's not always a valid assumption.</p>
<p>Even a simple use of <code>alloc::vec::Vec</code> could potentially allocate on every line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut v = Vec::new();
    v.push(1); // might allocate
    v.push(2); // might allocate
    v.push(3); // might allocate
    v.push(4); // might allocate
<span class="boring">}</span></code></pre></pre>
<p>None of these operations returns a <code>Result</code>, so what happens if those allocations fail?</p>
<p>The answer to this question depends on the toolchain, target and
<a href="https://doc.rust-lang.org/stable/std/alloc/fn.set_alloc_error_hook.html">configuration</a>, but is likely to involve
<a name="a034"></a><code>panic!</code> and program termination.  There is certainly no answer that allows an allocation failure on line 3 to be
handled in a way that allows the program to move on to line 4.</p>
<p>This assumption of <em><a name="a035"></a>infallible allocation</em> gives good ergonomics for code that runs in a &quot;normal&quot; userspace, where
there's effectively infinite memory (or at least where running out of memory indicates that the computer as a whole is
likely to have bigger problems elsewhere).</p>
<p>However, infallible allocation is utterly unsuitable for code that needs to run in environments where memory is
limited and programs are required to cope.  This is a (rare) area where there's better support in older, less
memory-safe, languages:</p>
<ul>
<li>C is sufficiently low-level that allocations are manual and so the return value from <code>malloc</code> can be checked for <code>NULL</code>.</li>
<li><a name="a036"></a>C++ can use its <a name="a037"></a>exception mechanism<sup><a name="to-footnote-3"><a href="no-std.html#footnote-3">3</a></a></sup>  to catch allocation failures in the form
of <a href="https://en.cppreference.com/w/cpp/memory/new/bad_alloc"><code>std::bad_alloc</code></a> exceptions.</li>
</ul>
<p>At the time of writing, Rust's inability to cope with failed allocation has been flagged in some high-profile contexts
(such as the <a href="https://lkml.org/lkml/2021/4/14/1099">Linux kernel</a>, Android, and the <a href="https://github.com/hyperium/hyper/issues/2265#issuecomment-693194229">Curl
tool</a>), and so work is on-going to fix the
omission.</p>
<p>The first step is the <a name="a039"></a><a href="https://github.com/rust-lang/rfcs/pull/2116">&quot;fallible collection allocation&quot;
changes</a>, which added <a name="a040"></a>fallible alternatives to many of the collection
APIs that involve allocation.  This generally adds a <code>try_&lt;operation&gt;</code> variant that results a <code>Result&lt;_, AllocError&gt;</code>
(although the <code>try_...</code> variant is currently only available with the nightly toolchain). For example:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.try_new"><code>Box::try_new</code></a> is available as an alternative to
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.new"><code>Box::new</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.try_reserve"><code>Vec::try_reserve</code></a> is available as an
alternative to
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.reserve"><code>Vec::reserve</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html#method.try_insert"><code>BTreeMap::try_insert</code></a>
is available as an alternative to
<a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html#method.insert"><code>BTreeMap::insert</code></a></li>
</ul>
<p>These fallible APIs only go so far; for example, there is (as yet) no fallible equivalent to
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.push"><code>Vec::push</code></a>, so code that assembles a vector may need
to do careful calculations to ensure that allocation errors can't happen:</p>
<pre><code class="language-rust ignore">    let mut v = Vec::new();

    // Perform a careful calculation to figure out how much space is needed,
    // here simplified to...
    let required_size = 4;

    v.try_reserve(required_size).map_err(|_e| {
        MyError::new(format!(&quot;Failed to allocate {} items!&quot;, required_size))
    })?;

    // We now know that it's safe to do:
    v.push(1);
    v.push(2);
    v.push(3);
    v.push(4);</code></pre>
<p>Fallible allocation is an area where work on Rust is on-going.  The entrypoints described above will hopefully be
stabilized and expanded, and there has also been a <a href="https://github.com/rust-lang/rfcs/pull/3140">proposal</a> to make
<em>infallible</em> allocation operations controlled by a default-on <a name="a041"></a>feature â€“ by explicitly disabling the feature, a
programmer can then be sure that no use of infallible allocation has inadvertently crept into their program.</p>
<p><hr/>
<p><a name="footnote-1"><a href="no-std.html#to-footnote-1">1</a></a>: Pun intended.</p>
<p><a name="footnote-2"><a href="no-std.html#to-footnote-2">2</a></a>: Prior to Rust 2018, <code>extern crate</code> declarations were used to pull in dependencies.  This
is now entirely handled by <code>Cargo.toml</code>, but the <code>extern crate</code> mechanism is still used to pull in those parts of the
Rust standard library that are optional in <code>no_std</code> environments.</p>
<p><a name="footnote-3"><a href="no-std.html#to-footnote-3">3</a></a>: It's also possible to add the <a name="a038"></a><a href="https://en.cppreference.com/w/cpp/memory/new/nothrow"><code>std::nothrow</code></a> overload to calls to <code>new</code> and check for
<code>nullptr</code> return values; however, there are still container methods like
<a href="https://en.cppreference.com/w/cpp/container/vector/push_back"><code>vector&lt;T&gt;::push_back</code></a> that allocate under the covers,
and which can therefore only signal allocation failure via an exception.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-34-control-what-crosses-ffi-boundaries"><a class="header" href="#item-34-control-what-crosses-ffi-boundaries">Item 34: Control what crosses FFI boundaries</a></h1>
<p>Even though Rust comes with with a comprehensive <a href="https://doc.rust-lang.org/std/index.html">standard library</a> and a
burgeoning <a href="https://crates/io">crate ecosystem</a>, there is still a lot more non-Rust code available
than there is Rust code.</p>
<p>As with other recent languages, Rust helps with this problem by offering a <em><a name="a001"></a>foreign function interface</em> (FFI)
mechanism, which allows interoperation with code and data structures written in different languages â€“ despite the
name, FFI is not restricted to just functions.  This opens up the use of existing libraries in different languages, not
just those that have succumbed to the Rust community's efforts to &quot;rewrite it in Rust&quot; (<a name="a002"></a>RIIR).</p>
<p>The default target for Rust's interoperability is the <a name="a003"></a>C programming language; this is the same interop target that
other languages aim at.  This is partly driven by the ubiquity of C libraries, but is also driven by simplicity: C acts
as a &quot;least common denominator&quot; of interoperability, because it doesn't need toolchain support of any of the more
advanced features that would be necessary for compatibility with other languages (e.g. garbage collection for Java or
Go, exceptions and templates for C++, function overrides for Java and C++, â€¦).</p>
<p>However, that's not to say that interoperability with plain C is simple.  By including code written in a different
language, all of the guarantees and protections that Rust offers are up for grabs, particularly those involving memory
safety.</p>
<p>As a result, FFI code in Rust is automatically <code>unsafe</code>, and the advice of <a href="unsafe.html">Item 16</a> has to be bypassed. This Item
explores some replacement advice, and <a href="bindgen.html">Item 35</a> will explore some tooling that helps to avoid some (but not all) of the
footguns involved in working with FFI.  (The <a href="https://doc.rust-lang.org/nomicon/ffi.html">FFI chapter</a> of the
<a name="a004"></a><a href="https://doc.rust-lang.org/nomicon/"><em>Rustonomicon</em></a> also contains helpful advice and information.)</p>
<h2 id="invoking-c-functions-from-rust"><a class="header" href="#invoking-c-functions-from-rust">Invoking C Functions from Rust</a></h2>
<p>The simplest FFI interaction is for Rust code to invoke a C function, taking &quot;immediate&quot; arguments that don't involve
pointers, references or memory addresses:</p>
<pre><code class="language-c">/* C function definition. */
int add(int x, int y) {
  return x + y;
}
</code></pre>
<p>To use this function in Rust, there needs to be an equivalent declaration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::os::raw::c_int;
extern &quot;C&quot; {
    pub fn add(x: c_int, y: c_int) -&gt; c_int;
}
<span class="boring">}</span></code></pre></pre>
<p>The declaration is marked as <a name="a005"></a><code>extern &quot;C&quot;</code> to indicate that an external C library will provide the actual code for
the function.   The <code>extern &quot;C&quot;</code> marker also automatically marks the function as
<a name="a006"></a><a href="https://doc.rust-lang.org/reference/abi.html?highlight=no_mangle#the-no_mangle-attribute"><code>#[no_mangle]</code></a>,
which is explored more below.</p>
<p>(Note that if the FFI functionality you want to use is just the standard C library, then you don't need to create these
declarations â€“ the <a href="https://docs.rs/libc"><code>libc</code></a> crate already provides them.)</p>
<p>The build system will typically also need an indication of how/where to find the library holding the C code, either via
the <a href="https://doc.rust-lang.org/reference/items/external-blocks.html#the-link-attribute"><code>link</code></a> attribute or the
<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html#the-links-manifest-key"><code>links</code></a> manifest key.</p>
<p>But even this simplest of examples comes with some gotchas.  First, use of FFI functions is automatically <code>unsafe</code>:</p>
<pre><code class="language-text">error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
   --&gt; ffi/src/main.rs:156:13
    |
156 |     let x = add(1, 1);
    |             ^^^^^^^^^ call to unsafe function
    |
    = note: consult the function's documentation for information on how to avoid undefined behavior
</code></pre>
<p>The next thing to watch out for is the use of C's <code>int</code> type, represented as
<a name="a007"></a><a href="https://doc.rust-lang.org/std/os/raw/type.c_int.html"><code>std::os::raw::c_int</code></a>. How big is an <code>int</code>?  It's
<em>probably</em> true that</p>
<ul>
<li>the size of an <code>int</code> for the toolchain that compiled the C library, and</li>
<li>the size of a <code>std::os::raw::c_int</code> for the Rust toolchain</li>
</ul>
<p>are the same.  But why take the chance?  <strong>Prefer sized types at FFI boundaries</strong>, where possible â€“ which for C
means making use of the types defined in <code>&lt;stdint.h&gt;</code>.  However, if you're dealing with an existing codebase that
already uses <code>int</code> / <code>long</code> / <code>size_t</code> this may be a luxury you don't have.</p>
<p>The final practical concern is that the C code and the equivalent Rust declaration need to exactly match.  Worse still,
if there's a mismatch, the build tools will not emit a warning â€“ they will just silently emit incorrect code.</p>
<p><a href="bindgen.html">Item 35</a> discusses the use of the <a name="a008"></a><code>bindgen</code> tool to prevent this problem, but it's worth understanding the basics
of what's going on under the covers to understand <em>why</em> the build tools can't detect the problem.</p>
<p>Compiled languages generally support <em><a name="a009"></a>separate compilation</em>, where different parts of the program are converted
into machine code as separate chunks (object files), which can then be combined into a complete program by the
<em><a name="a010"></a>linker</em>.  This means that if only one small part of the program's source code changes, only the corresponding
object file needs to be regenerated; the link step then rebuilds the program, combining both the changed object and all
the other unmodified objects.</p>
<p>The <a href="https://lurklurk.org/linkers/linkers.html">link step is (roughly speaking) a &quot;join the dots&quot; operation</a>: some
object files provide definitions of functions and variables, other object files have placeholder markers indicating that
they expect to use a definition from some other object, but it wasn't available at compile time.  The linker combines
the two: it ensures that any placeholder in the compiled code is replaced with a reference to the corresponding concrete
definition.</p>
<p>The linker performs this correlation between the placeholders and the definitions by simply checking for a matching
name, meaning that there is a single global namespace for all of these correlations.</p>
<p>Historically, this was fine for linking C language programs, where a single name could not be re-used in any way, but
the introduction of <a name="a011"></a>C++ caused a problem.  C++ allows overridden definitions with the same name:</p>
<pre><code class="language-c++">// C++ code
namespace ns1 {
int32_t add(int32_t a, int32_t b) { return a+b; }
int64_t add(int64_t a, int64_t b) { return a+b; }
}
namespace ns2 {
int32_t add(int32_t a, int32_t b) { return a+b; }
}
</code></pre>
<p>The solution for this is <em><a name="a012"></a>name mangling</em>: the <a href="https://lurklurk.org/linkers/linkers.html#namemangling">compiler encodes the signature and type
information</a> for the overridden functions into the name that's
emitted in the object file, and the linker continues to perform its simple-minded 1:1 correlation between placeholders
and definitions.</p>
<p>On UNIX-like systems, the <a name="a013"></a><code>nm</code> tool can help show what the linker works with, and the
<a name="a014"></a><code>c++filt</code> tool helps translate this back into what would be visible in C++ code:</p>
<pre><code>% nm ffi-cpp-lib.o | grep add  # what the linker sees
0000000000000000 T __ZN3ns13addEii
0000000000000020 T __ZN3ns13addExx
0000000000000040 T __ZN3ns23addEii
% nm ffi-cpp-lib.o | grep add | c++filt  # what the programmer sees
0000000000000000 T ns1::add(int, int)
0000000000000020 T ns1::add(long long, long long)
0000000000000040 T ns2::add(int, int)
</code></pre>
<p>Because the mangled name includes type information, the linker can and will complain about any mismatch in the type
information between placeholder and definition. This gives some measure of type safety: if the definition changes but
the place using it is not updated, the toolchain will complain.</p>
<p>Returning to Rust, <code>extern &quot;C&quot;</code> foreign functions are implicitly marked as <code>#[no_mangle]</code>, which means that this level
of type safety is lost â€“ the linker only sees the &quot;bare&quot; names for functions and variables, and if there are any
differences in type expectations between definition and use, this will only cause problems at runtime.</p>
<h2 id="accessing-c-data-from-rust"><a class="header" href="#accessing-c-data-from-rust">Accessing C Data from Rust</a></h2>
<blockquote>
<p>&quot;I'm playing all the right notes, but not necessarily in the right order.&quot; â€“ Eric Morecambe</p>
</blockquote>
<p>Even though the example of the previous section passed the simplest possible data â€“ an integer that fits in a
machine register â€“ between Rust and C, there were still things to be careful about.  It's no surprise then that
dealing with more complex data structures also has wrinkles to watch out for.</p>
<p>Both C and Rust use the <a name="a015"></a><code>struct</code> to combine related data into a single data structure.
However, when a <code>struct</code> is realised in memory, the two languages may well choose to put different
fields in different places or even in different orders (the
<em><a name="a016"></a><a href="https://doc.rust-lang.org/reference/type-layout.html">layout</a></em>).  To prevent mismatches,
<strong>use <a name="a017"></a><code>#[repr(C)]</code> for Rust types used in FFI</strong>; this <a href="https://doc.rust-lang.org/reference/type-layout.html#the-c-representation">representation is designed
for the purpose of allowing C
interoperability</a>.</p>
<pre><code class="language-c">/* C data structure definition. */
/* Changes here must be reflected in lib.rs. */
typedef struct {
    uint8_t byte;
    uint32_t integer;
} FfiStruct;
</code></pre>
<pre><code class="language-rust ignore">// Equivalent Rust data structure.
// Changes here must be reflected in lib.h / lib.c.
#[repr(C)]
pub struct FfiStruct {
    pub byte: u8,
    pub integer: u32,
}</code></pre>
<p>The structure definitions have a comment to remind the humans involved that the two places need to be kept in sync.
Relying on the constant vigilance of humans is likely to go wrong in the long term; as for function signatures, it's
better to automate this synchronization between the two languages via a tool like <code>bindgen</code> (<a href="bindgen.html">Item 35</a>).</p>
<p>One type (pun intended) of data that's worth thinking about carefully for FFI interactions is strings.  The default
definitions of what makes up a string are somewhat different between C and Rust.</p>
<ul>
<li>A Rust <a name="a018"></a><a href="https://doc.rust-lang.org/alloc/string/struct.String.html"><code>String</code></a> holds <a name="a019"></a>UTF-8 encoded data,
possibly including zero bytes,  with an explicitly known length.</li>
<li>A C string (<code>char *</code>) holds byte values (which may or may not be signed), with its length implicitly determined by the
first zero byte (<code>\0</code>) found in the data.</li>
</ul>
<p>Fortunately, dealing with C-style strings in Rust is comparatively straightforward, because the Rust library designers
have already done the heavy lifting by providing a pair of types to encode them. <strong>Use the
<a name="a020"></a><a href="https://doc.rust-lang.org/alloc/ffi/struct.CString.html"><code>CString</code></a> type</strong> to hold strings that need to be
interoperable with C, and then use the <a href="https://doc.rust-lang.org/core/ffi/struct.CStr.html#method.as_ptr"><code>as_ptr()</code></a>
method to pass the contents to any FFI function that's expecting a <code>const char*</code> C string.  Note that the <code>const</code> is
important: this can't be used for an FFI function that needs to modify the contents (<code>char *</code>) of the string that's
passed to it.</p>
<h2 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h2>
<p>Most data structures are too big to fit in a register, and so have to be held in memory instead.  That in turn means that
access to the data is performed via the location of that memory. In C terms this means a <em><a name="a021"></a>pointer</em>: a number
that encodes a memory address â€“ with no other semantics attached.</p>
<p>In Rust, a location in memory is generally represented as a <em><a name="a022"></a>reference</em>, and its numeric value can be extracted
as a <em><a name="a023"></a>raw pointer</em>, ready to feed into an FFI boundary.</p>
<pre><code class="language-rust ignore">extern &quot;C&quot; {
    pub fn use_struct(v: *const FfiStruct) -&gt; u32;
}</code></pre>
<pre><code class="language-rust ignore">    let v = FfiStruct {
        byte: 1,
        integer: 42,
    };
    let x = unsafe { use_struct(&amp;v as *const FfiStruct) };</code></pre>
<p>However, a Rust reference comes with additional constraints around the <em><a name="a024"></a>lifetime</em> of the associated chunk of
memory (as described in <a href="lifetimes.html">Item 14</a>), and these constraints get lost in the conversion to a raw pointer.  That makes use of
raw pointers inherently <code>unsafe</code>, as a marker that Here Be Dragons: the C code on the other side of the FFI boundary
could do any number of things that will destroy Rust's memory safety:</p>
<ul>
<li>The C code could hang on to the value of the pointer, and use it at a later point when the associated memory has
either been freed from the heap (&quot;<a name="a025"></a>use-after-free&quot;), or re-used on the stack.</li>
<li>The C code could decide to cast away the <code>const</code>-ness of a pointer that's passed to it, and modify data that Rust
expects to be immutable.</li>
<li>The C code is not subject to Rust's <code>Mutex</code> protections, so the spectre of data races (<a href="deadlock.html">Item 17</a>)
rears its ugly head.</li>
<li>The C code could mistakenly return associated heap memory to the allocator (by calling C's <a name="a026"></a> <code>free()</code>
library function), meaning that the <em>Rust</em> code might now be performing use-after-free operations.</li>
</ul>
<p>All of these dangers form part of the cost-benefit analysis of using an existing library via FFI.  On the plus side, you
get to re-use existing code that's (presumably) in good working order, with only the need to write (or auto-generate)
corresponding declarations; on the minus side, you lose the memory protections that are a big reason to use Rust in the
first place.</p>
<p>As a first step to reduce the chances of memory-related problems, <strong>allocate and free memory on the
same side of the FFI boundary</strong>.  For example, this might appear as a symmetric pair of functions:</p>
<pre><code class="language-c">/* C functions. */
FfiStruct* new_struct(uint32_t v);
void free_struct(FfiStruct* s);
</code></pre>
<p>with corresponding Rust FFI declarations:</p>
<pre><code class="language-rust ignore">extern &quot;C&quot; {
    pub fn new_struct(v: u32) -&gt; *mut FfiStruct;
    pub fn free_struct(s: *mut FfiStruct);
}</code></pre>
<p>To make sure that allocation and freeing are kept in sync, it can be a good idea to implement an
<a name="a027"></a>RAII wrapper that automatically prevents C-allocated memory from being leaked.  The wrapper
structure owns the C-allocated memory:</p>
<pre><code class="language-rust ignore">/// Wrapper structure that owns memory allocated by the C library.
struct FfiWrapper {
    // Invariant: inner is non-NULL.
    inner: *mut FfiStruct,
}</code></pre>
<p>and the <a name="a028"></a><code>Drop</code> implementation returns that memory to the C library, to avoid the potential for
leaks:</p>
<pre><code class="language-rust ignore">/// Manual implementation of [`Drop`] which ensures that memory allocated by the
/// C library is freed by it.
impl Drop for FfiWrapper {
    fn drop(&amp;mut self) {
        // Safety: `inner` is non-NULL, and besides `free_struct()` copes with
        // NULL pointers.
        unsafe { free_struct(self.inner) }
    }
}</code></pre>
<p>The same principle applies to more that just heap memory; as described in <a href="raii.html">Item 11</a>, <strong>implement <code>Drop</code> to apply RAII to
FFI-derived resources</strong> â€“ open files, database connections, etc.</p>
<p>Encapsulating the interactions with the C library into a wrapper <code>struct</code> also makes it possible to
catch some other potential footguns, transforming an otherwise invisible failure into a <code>Result</code>:</p>
<pre><code class="language-rust ignore">impl FfiWrapper {
    pub fn new(val: u32) -&gt; Result&lt;Self, Error&gt; {
        let p: *mut FfiStruct = unsafe { new_struct(val) };
        // Raw pointers are not guaranteed to be non-NULL.
        if p.is_null() {
            Err(&quot;Failed to get inner struct!&quot;.into())
        } else {
            Ok(Self { inner: p })
        }
    }
}</code></pre>
<p>The wrapper structure can then offer safe methods that allow use of the C library's functionality:</p>
<pre><code class="language-rust ignore">impl FfiWrapper {
    pub fn set_byte(&amp;mut self, b: u8) {
        let r: &amp;mut FfiStruct = unsafe { &amp;mut *self.inner };
        r.byte = b;
    }
}</code></pre>
<p>Alternatively, if the underlying C data structure has an equivalent Rust mapping, and if it's safe
to directly manipulate that data structure, then implementations of the <a name="a029"></a><code>AsRef</code> and
<a name="a030"></a><code>AsMut</code> traits allow more direct use:</p>
<pre><code class="language-rust ignore">impl AsMut&lt;FfiStruct&gt; for FfiWrapper {
    fn as_mut(&amp;mut self) -&gt; &amp;mut FfiStruct {
        // Safety: `inner` is non-NULL.
        unsafe { &amp;mut *self.inner }
    }
}</code></pre>
<pre><code class="language-rust ignore">        let mut wrapper = FfiWrapper::new(42).expect(&quot;real code would check&quot;);
        wrapper.as_mut().byte = 12;</code></pre>
<p>This example illustrates a useful principle for dealing with FFI: <strong>encapsulate access to an <code>unsafe</code> FFI library inside
safe Rust code</strong>; this allows the rest of the application to follow the advice of <a href="unsafe.html">Item 16</a> and avoid writing <code>unsafe</code>
code.  It also concentrates all of the dangerous code in one place, which you can then study (and test) carefully to
uncover problems â€“ and treat as the most likely suspect when something does go wrong.</p>
<h2 id="invoking-rust-from-c"><a class="header" href="#invoking-rust-from-c">Invoking Rust from C</a></h2>
<p>What counts as &quot;foreign&quot; depends on where you're standing; if you're writing an application in C, then it may be a
<em>Rust</em> library that's accessed via a foreign function interface.</p>
<p>The basics of exposing a Rust library to C code are similar to the opposite direction:</p>
<ul>
<li>Rust functions that are exposed to C need an <a name="a031"></a><code>extern &quot;C&quot;</code> marker to ensure they're C-compatible.</li>
<li>Rust symbols are name mangled<sup><a name="to-footnote-1"><a href="ffi.html#footnote-1">1</a></a></sup> by default (like C++), so
function definitions also need a <code>#[no_mangle]</code> attribute to ensure that they're accessible via a
simple name.  This in turn means that the function name is part of a single global namespace that
can clash with any other symbol defined in the program.  As such, <strong>consider using a prefix for
exposed names</strong> to avoid ambiguities (<code>mylib_...</code>).</li>
<li>Data structure definitions need the <code>#[repr(C)]</code> attribute to ensure that the layout of the contents is compatible
with an equivalent C data structure.</li>
</ul>
<p>Also like the opposite direction, more subtle problems arise when dealing with pointers, references and lifetimes.
A C pointer is different from a Rust reference, and you forget that at your peril:</p>
<pre><code class="language-rust ignore not_desired_behaviour">#[no_mangle]
pub extern &quot;C&quot; fn add_contents(p: *const FfiStruct) -&gt; u32 {
    let s: &amp;FfiStruct = unsafe { &amp;*p }; // Ruh-roh
    s.integer + s.byte as u32
}</code></pre>
<pre><code class="language-c">    /* C code invoking Rust. */
    uint32_t result = add_contents(NULL); // Boom!
</code></pre>
<p>When you're dealing with raw pointers, it's your responsibility to ensure that any use of them complies with Rust's
assumptions and guarantees around references.</p>
<pre><code class="language-rust ignore">#[no_mangle]
pub extern &quot;C&quot; fn add_contents_safer(p: *const FfiStruct) -&gt; u32 {
    let s = match unsafe { p.as_ref() } {
        Some(r) =&gt; r,
        None =&gt; return 0, // Pesky C code gave us a NULL.
    };
    s.integer + s.byte as u32
}</code></pre>
<p>In the examples above, the C code provides a raw pointer to the Rust code, and the Rust code converts it to a reference
in order to operate on the structure.  But where did that pointer come from?  What does the Rust reference refer to?</p>
<p>The very first example in <a href="references.html">Item 9</a> showed how Rust's memory safety prevents references to expired stack objects from
being returned; those problems reappear if you try to hand out a raw pointer:</p>
<pre><code class="language-rust ignore not_desired_behaviour">// No compilation errors here.
#[no_mangle]
pub extern &quot;C&quot; fn new_struct(v: u32) -&gt; *mut FfiStruct {
    let mut s = FfiStruct::new(v);
    &amp;mut s // return raw pointer to a stack object that's about to expire!
}</code></pre>
<p>Any pointers passed back from Rust to C should generally refer to heap memory, not stack memory.  But naively trying to
put the object on the heap via a <code>Box</code> doesn't help:</p>
<pre><code class="language-rust ignore not_desired_behaviour">// No compilation errors here either.
#[no_mangle]
pub extern &quot;C&quot; fn new_struct_heap(v: u32) -&gt; *mut FfiStruct {
    let s = FfiStruct::new(v); // create `FfiStruct` on stack
    let mut b = Box::new(s); // move `FfiStruct` to heap
    &amp;mut *b // return raw pointer to a heap object that's about to expire!
}</code></pre>
<p>because the owning <code>Box</code> is on the stack, so when it goes out of scope it will free the heap object.</p>
<p>The tool for the job here is
<a name="a033"></a><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.into_raw"><code>Box::into_raw</code></a>, which abnegates
responsibility for the heap object, effectively &quot;forgetting&quot; about it:</p>
<pre><code class="language-rust ignore">#[no_mangle]
pub extern &quot;C&quot; fn new_struct_raw(v: u32) -&gt; *mut FfiStruct {
    let s = FfiStruct::new(v); // create `FfiStruct` on stack
    let b = Box::new(s); // move `FfiStruct` to heap

    // Consume the `Box` and take responsibility for the heap memory.
    Box::into_raw(b)
}</code></pre>
<p>This of course raises the question of how the heap object now gets freed. The advice above was that allocating and
freeing memory should happen on the same side of the FFI boundary, which means that we need to persuade the Rust side of
things to do the freeing.  The corresponding tool for the job is
<a name="a034"></a><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.from_raw"><code>Box::from_raw</code></a>, which builds a <code>Box</code> from
a raw pointer:</p>
<pre><code class="language-rust ignore">#[no_mangle]
pub extern &quot;C&quot; fn free_struct_raw(p: *mut FfiStruct) {
    let _b = unsafe { Box::from_raw(p) }; // assumes non-NULL
} // `_b` drops at end of scope, freeing the `FfiStruct`</code></pre>
<p>This does still leave the Rust code at the mercy of the C code; if the C code gets confused and asks Rust to free the
same pointer twice, Rust's allocator is likely to become terminally confused.</p>
<p>That illustrates the general theme of this Item: using FFI exposes you to risks that aren't present in standard Rust.
That may well be worthwhile, as long as you're aware of the dangers and costs involved.  Controlling the details of what
passes across the FFI boundary helps to reduce that risk, but by no means eliminates it.</p>
<p><hr/>
<p><a name="footnote-1"><a href="ffi.html#to-footnote-1">1</a></a>: The Rust equivalent of the <code>c++filt</code> tool for translating
mangled names back to programmer-visible names is <a name="a032"></a><code>rustfilt</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="item-35-prefer-bindgen-to-manual-ffi-mappings"><a class="header" href="#item-35-prefer-bindgen-to-manual-ffi-mappings">Item 35: Prefer <code>bindgen</code> to manual FFI mappings</a></h1>
<p><a href="ffi.html">Item 34</a> discussed the mechanics of invoking C code from a Rust program, describing how declarations of C structures and
functions need to have an equivalent Rust declaration to allow them to be used over FFI. The C and Rust declarations
need to be kept in sync, and <a href="ffi.html">Item 34</a> warned that the toolchain wouldn't help with this â€“ mismatches would be
silently ignored, hiding problems for later.</p>
<p>Keeping two things perfectly in sync sounds like a good target for automation, and the Rust toolchain comes with the
right tool for the job: <a name="a001"></a><a href="https://rust-lang.github.io/rust-bindgen/"><code>bindgen</code></a>. The primary function of <code>bindgen</code>
is to parse a C header file, and emit the corresponding Rust declarations.</p>
<p>Taking some of the example C declarations from <a href="ffi.html">Item 34</a>:</p>
<pre><code class="language-c">/* C data structure definition. */
/* Changes here must be reflected in lib.rs. */
typedef struct {
    uint8_t byte;
    uint32_t integer;
} FfiStruct;

uint32_t add32(uint32_t x, uint32_t y);
int add(int x, int y);
</code></pre>
<p>the <code>bindgen</code> tool can be manually invoked (or invoked by a <a name="a002"></a><code>build.rs</code> build script) to create a corresponding
Rust file:</p>
<pre><code class="language-shell">% bindgen --no-layout-tests \
          --allowlist-function=&quot;add.*&quot; \
          --allowlist-type=FfiStruct \
          -o src/generated.rs \
          ../elsewhere/somelib.h
</code></pre>
<p>The generated Rust is identical to the hand-crafted declarations of <a href="ffi.html">Item 34</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/* automatically generated by rust-bindgen 0.59.2 */

extern &quot;C&quot; {
    pub fn add32(x: u32, y: u32) -&gt; u32;
}
extern &quot;C&quot; {
    pub fn add(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -&gt; ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfiStruct {
    pub byte: u8,
    pub integer: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>and can be pulled into the code with the source-level <a name="a003"></a><a href="https://doc.rust-lang.org/std/macro.include.html"><code>include!</code>
macro</a>:</p>
<pre><code class="language-rust ignore">// Include the auto-generated Rust declarations.
include!(&quot;generated.rs&quot;);</code></pre>
<p>For anything but the most trivial FFI declarations, <strong>use <code>bindgen</code> to generate Rust bindings for C code</strong> â€“ this
is an area where machine-made, mass-produced code is definitely preferable to hand-crafted artisanal declarations.  If a
C function definition changes, the C compiler will complain if the C declaration no longer matches the C definition, but
nothing will complain that the Rust declaration no longer matches the C declaration; auto-generating the Rust
declaration from the C declaration ensures that never happens.</p>
<p>This also means that the <code>bindgen</code> step is an ideal candidate to include in a continuous integration system (<a href="ci.html">Item 32</a>);
if the generated code is included in source control, the CI system can error out if a freshly-generated file doesn't
match the checked-in version.</p>
<p>The <code>bindgen</code> tool comes particularly into its own when you're dealing with an existing C codebase that has a large API.
Creating Rust equivalents to a big <code>lib_api.h</code> header file is manual and tedious, therefore error-prone â€“ and as
noted above, many categories of mismatch error will not be detected by the toolchain.  <code>bindgen</code> also has a
<a href="https://rust-lang.github.io/rust-bindgen/allowlisting.html">panoply</a> of
<a href="https://rust-lang.github.io/rust-bindgen/blocklisting.html">options</a> that allow specific subsets of an API to be
targeted (such as the <code>--allowlist-function</code> and <code>--allowlist-type</code> options illustrated above<sup><a name="to-footnote-1"><a href="bindgen.html#footnote-1">1</a></a></sup>).</p>
<p>This also allows a layered approach to exposing an existing C library in Rust; a common convention for wrapping some
<code>xyzzy</code> library is to have:</p>
<ul>
<li>An <code>xyzzy-sys</code> crate that holds (just) the <code>bindgen</code>-erated code â€“ use of which is necessarily <code>unsafe</code>.</li>
<li>An <code>xyzzy</code> crate that encapsulates the <code>unsafe</code> code, and provides safe Rust access to the underyling functionality.</li>
</ul>
<p>This concentrates the <code>unsafe</code> code in one layer, and allows the rest of the program to follow the advice of <a href="unsafe.html">Item 16</a>.</p>
<h2 id="beyond-c"><a class="header" href="#beyond-c">Beyond C</a></h2>
<p>The <code>bindgen</code> tool has the ability to <a href="https://rust-lang.github.io/rust-bindgen/cpp.html">handle some C++ constructs</a>,
but only a subset and in a limited fashion. For better (but still somewhat limited) integration <strong>consider using the
<a name="a005"></a><a href="https://cxx.rs"><code>cxx</code></a> crate for C++/Rust interoperation</strong>. Instead of generating Rust code from C++
declarations, <code>cxx</code> takes the approach of auto-generating <em>both</em> Rust and C++ code from a common schema, allowing for
tighter integration.</p>
<p><hr/>
<p><a name="footnote-1"><a href="bindgen.html#to-footnote-1">1</a></a>: The example
also used the <code>--no-layout-tests</code> option to keep the output simple; by default, the generated code will include <code>#[test]</code>
code to check that structures are indeed <a name="a004"></a>laid out correctly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index"><a class="header" href="#index">Index</a></h1>
<p>!, see exclamation mark<br/>
Ï€, <a href="clippy.html#a003">1</a><br/>
<code>()</code>, <a href="use-types.html#a025">1</a>, <a href="use-types.html#a026">2</a><br/>
<code>..</code>, see struct update syntax<br/>
<code>?</code>, <a href="transform.html#a016">1</a>, <a href="errors.html#a003">2</a>, <a href="errors.html#a015">3</a>, <a href="errors.html#a023">4</a>, <a href="macros.html#a018">5</a>, <a href="testing.html#a015">6</a><br/>
abstract class, <a href="use-types-2.html#a018">1</a><br/>
abstract syntax tree, <a href="macros.html#a008">1</a>, <a href="macros.html#a012">2</a>, <a href="use-tools.html#a015">3</a><br/>
Adams, Douglas, <a href="panic.html#a001">1</a><br/>
<code>Add</code>, <a href="std-traits.html#a061">1</a>, <a href="std-traits.html#a077">2</a><br/>
<code>AddAssign</code>, <a href="std-traits.html#a078">1</a><br/>
AddressSanitizer, <a href="testing.html#a024">1</a><br/>
ADT, see algebraic data type<br/>
AFL, <a href="testing.html#a028">1</a><br/>
afraid, reasons to be, <a href="deadlock.html#a002">1</a><br/>
algebraic data type, <a href="use-types.html#a041">1</a>, <a href="types.html#a005">2</a><br/>
aliasing, <a href="borrows.html#a015">1</a><br/>
alignment, <a href="references.html#a002">1</a>, <a href="references.html#a032">2</a><br/>
<code>all</code>, <a href="iterators.html#a055">1</a><br/>
<code>alloc</code>, <a href="no-std.html#a012">1</a>, <a href="no-std.html#a032">2</a><br/>
allocation, fallible, <a href="no-std.html#a039">1</a><br/>
allocation, infallible, <a href="no-std.html#a033">1</a><br/>
<code>allow</code>, <a href="clippy.html#a004">1</a><br/>
also-implements, <a href="reflection.html#a026">1</a><br/>
<code>Any</code>, <a href="reflection.html#a013">1</a><br/>
<code>any</code>, <a href="iterators.html#a054">1</a><br/>
<code>anyhow</code>, <a href="errors.html#a028">1</a><br/>
<code>Arc</code>, <a href="references.html#a053">1</a>, <a href="borrows.html#a023">2</a>, <a href="unsafe.html#a008">3</a>, <a href="deadlock.html#a026">4</a>, <a href="no-std.html#a017">5</a><br/>
array, <a href="use-types.html#a032">1</a>, <a href="references.html#a022">2</a><br/>
<code>as</code>, <a href="casts.html#a004">1</a>, <a href="casts.html#a019">2</a>, <a href="clippy.html#a011">3</a><br/>
<code>as_ref</code>, <a href="transform.html#a025">1</a><br/>
<code>AsMut</code>, <a href="std-traits.html#a111">1</a>, <a href="references.html#a017">2</a>, <a href="ffi.html#a030">3</a><br/>
<code>AsRef</code>, <a href="transform.html#a026">1</a>, <a href="std-traits.html#a110">2</a>, <a href="references.html#a016">3</a>, <a href="ffi.html#a029">4</a><br/>
associated type, <a href="casts.html#a012">1</a>, <a href="references.html#a015">2</a><br/>
AST, see abstract syntax tree<br/>
<code>async</code>, <a href="borrows.html#a034">1</a><br/>
attacker, <a href="lifetimes.html#a012">1</a><br/>
auto trait, <a href="deadlock.html#a032">1</a><br/>
B language, <a href="iterators.html#a001">1</a><br/>
back-compatibility, <a href="intro.html#a007">1</a>, <a href="default-impl.html#a009">2</a>, <a href="semver.html#a009">3</a>, <a href="visibility.html#a006">4</a>, <a href="wildcard.html#a004">5</a>, <a href="re-export.html#a004">6</a>, <a href="dep-graph.html#a005">7</a>, <a href="documentation.html#a010">8</a>, <a href="testing.html#a012">9</a><br/>
Barbossa, Hector, <a href="intro.html#a001">1</a><br/>
benchmarks, <a href="testing.html#a016">1</a><br/>
<code>bindgen</code>, <a href="ffi.html#a008">1</a>, <a href="bindgen.html#a001">2</a><br/>
<code>BitAnd</code>, <a href="std-traits.html#a079">1</a><br/>
<code>BitAndAssign</code>, <a href="std-traits.html#a080">1</a><br/>
<code>BitOr</code>, <a href="std-traits.html#a081">1</a><br/>
<code>BitOrAssign</code>, <a href="std-traits.html#a082">1</a><br/>
<code>BitXor</code>, <a href="std-traits.html#a083">1</a><br/>
<code>BitXorAssign</code>, <a href="std-traits.html#a084">1</a><br/>
<code>black_box</code>, <a href="testing.html#a018">1</a><br/>
blanket implementation, <a href="errors.html#a026">1</a>, <a href="casts.html#a015">2</a>, <a href="references.html#a037">3</a>, <a href="reflection.html#a014">4</a>, <a href="semver.html#a017">5</a><br/>
<code>bool</code>, <a href="use-types.html#a021">1</a>, <a href="use-types.html#a037">2</a>, <a href="clippy.html#a005">3</a><br/>
BoringSSL, <a href="dep-graph.html#a010">1</a><br/>
<code>Borrow</code>, <a href="std-traits.html#a112">1</a>, <a href="references.html#a035">2</a><br/>
borrow, <a href="borrows.html#a008">1</a><br/>
borrow checker, <a href="intro.html#a005">1</a>, <a href="std-traits.html#a031">2</a>, <a href="builders.html#a008">3</a>, <a href="references.html#a005">4</a>, <a href="borrows.html#a002">5</a>, <a href="unsafe.html#a001">6</a>, <a href="unsafe.html#a016">7</a>, <a href="deadlock.html#a017">8</a>, <a href="concepts.html#a001">9</a><br/>
<code>BorrowMut</code>, <a href="std-traits.html#a113">1</a>, <a href="references.html#a036">2</a><br/>
<code>Box</code>, <a href="references.html#a010">1</a>, <a href="references.html#a043">2</a>, <a href="no-std.html#a015">3</a><br/>
Â Â Â Â Â Â <code>Box::from_raw</code>, <a href="ffi.html#a034">1</a><br/>
Â Â Â Â Â Â <code>Box::into_raw</code>, <a href="ffi.html#a033">1</a><br/>
<code>BTreeMap</code>, <a href="no-std.html#a021">1</a><br/>
<code>BTreeSet</code>, <a href="iterators.html#a062">1</a>, <a href="no-std.html#a022">2</a><br/>
bug, <a href="deadlock.html#a009">1</a>, <a href="semver.html#a028">2</a>, <a href="testing.html#a011">3</a>, <a href="testing.html#a021">4</a>, <a href="testing.html#a034">5</a>, <a href="ci.html#a020">6</a><br/>
<code>build.rs</code>, <a href="dep-graph.html#a023">1</a>, <a href="bindgen.html#a002">2</a><br/>
builder pattern, <a href="std-traits.html#a042">1</a>, <a href="builders.html#a006">2</a><br/>
<code>byteorder</code>, <a href="unsafe.html#a020">1</a><br/>
C, <a href="iterators.html#a002">1</a>, <a href="lifetimes.html#a009">2</a>, <a href="borrows.html#a003">3</a>, <a href="macros.html#a005">4</a>, <a href="ffi.html#a003">5</a><br/>
Â Â Â Â Â Â C99, <a href="iterators.html#a005">1</a><br/>
C++, <a href="intro.html#a004">1</a>, <a href="use-types.html#a003">2</a>, <a href="use-types-2.html#a013">3</a>, <a href="std-traits.html#a003">4</a>, <a href="references.html#a006">5</a>, <a href="iterators.html#a004">6</a>, <a href="raii.html#a003">7</a>, <a href="generics.html#a004">8</a>, <a href="lifetimes.html#a010">9</a>, <a href="borrows.html#a004">10</a>, <a href="unsafe.html#a022">11</a>, <a href="deadlock.html#a005">12</a>, <a href="panic.html#a006">13</a>, <a href="reflection.html#a005">14</a>, <a href="concepts.html#a003">15</a>, <a href="dep-graph.html#a006">16</a>, <a href="features.html#a004">17</a>, <a href="macros.html#a006">18</a>, <a href="testing.html#a023">19</a>, <a href="no-std.html#a036">20</a>, <a href="ffi.html#a011">21</a><br/>
Â Â Â Â Â Â C++11, <a href="intro.html#a008">1</a>, <a href="iterators.html#a009">2</a>, <a href="raii.html#a006">3</a><br/>
Â Â Â Â Â Â C++20, <a href="use-types-2.html#a028">1</a><br/>
<code>c++filt</code>, <a href="ffi.html#a014">1</a><br/>
<code>c_int</code>, <a href="ffi.html#a007">1</a><br/>
cackle maniacally, <a href="lifetimes.html#a013">1</a><br/>
Cargill, Tom, <a href="panic.html#a011">1</a><br/>
Cargo, <a href="reflection.html#a034">1</a>, <a href="semver.html#a002">2</a>, <a href="re-export.html#a001">3</a>, <a href="dep-graph.html#a001">4</a>, <a href="features.html#a005">5</a>, <a href="deps.html#a003">6</a>, <a href="clippy.html#a002">7</a><br/>
<code>cargo bench</code>, <a href="use-tools.html#a007">1</a><br/>
<code>cargo check</code>, <a href="use-tools.html#a004">1</a><br/>
<code>cargo doc</code>, <a href="documentation.html#a006">1</a>, <a href="use-tools.html#a006">2</a>, <a href="ci.html#a006">3</a><br/>
<code>cargo fmt</code>, <a href="use-tools.html#a001">1</a><br/>
<code>cargo metadata</code>, <a href="use-tools.html#a011">1</a><br/>
<code>cargo update</code>, <a href="use-tools.html#a008">1</a><br/>
<code>cargo-bench</code>, <a href="testing.html#a017">1</a>, <a href="ci.html#a015">2</a><br/>
<code>cargo-deny</code>, <a href="semver.html#a025">1</a>, <a href="dep-graph.html#a017">2</a>, <a href="use-tools.html#a014">3</a>, <a href="ci.html#a011">4</a><br/>
<code>cargo-expand</code>, <a href="use-tools.html#a017">1</a><br/>
<code>cargo-fmt</code>, <a href="use-tools.html#a003">1</a><br/>
<code>cargo-fuzz</code>, <a href="testing.html#a030">1</a><br/>
<code>cargo-tarpaulin</code>, <a href="use-tools.html#a018">1</a>, <a href="ci.html#a014">2</a><br/>
<code>cargo-tree</code>, <a href="dep-graph.html#a020">1</a>, <a href="use-tools.html#a010">2</a><br/>
<code>cargo-udeps</code>, <a href="dep-graph.html#a016">1</a>, <a href="use-tools.html#a013">2</a>, <a href="ci.html#a010">3</a><br/>
<code>Cargo.lock</code>, <a href="dep-graph.html#a012">1</a>, <a href="ci.html#a016">2</a><br/>
<code>Cargo.toml</code>, <a href="panic.html#a008">1</a>, <a href="semver.html#a004">2</a>, <a href="dep-graph.html#a002">3</a>, <a href="features.html#a007">4</a>, <a href="features.html#a009">5</a>, <a href="features.html#a010">6</a><br/>
<code>cargo_metadata</code>, <a href="use-tools.html#a012">1</a><br/>
cast, <a href="use-types.html#a018">1</a>, <a href="casts.html#a003">2</a>, <a href="casts.html#a020">3</a>, <a href="clippy.html#a010">4</a><br/>
<code>catch_unwind</code>, <a href="panic.html#a007">1</a><br/>
<code>Cell</code>, <a href="references.html#a052">1</a>, <a href="borrows.html#a026">2</a>, <a href="deadlock.html#a033">3</a><br/>
<code>cfg</code>, <a href="features.html#a002">1</a><br/>
<code>cfg_attr</code>, <a href="features.html#a003">1</a><br/>
<code>chain</code>, <a href="iterators.html#a024">1</a><br/>
channel (Go), <a href="deadlock.html#a045">1</a><br/>
<code>char</code>, <a href="use-types.html#a028">1</a><br/>
Chromium, <a href="lifetimes.html#a014">1</a><br/>
CI, see continuous integration<br/>
Clang, <a href="deadlock.html#a016">1</a><br/>
Clippy, <a href="std-traits.html#a038">1</a>, <a href="clippy.html#a001">2</a>, <a href="use-tools.html#a005">3</a>, <a href="ci.html#a005">4</a><br/>
<code>Clone</code>, <a href="std-traits.html#a005">1</a>, <a href="std-traits.html#a028">2</a>, <a href="std-traits.html#a066">3</a>, <a href="builders.html#a009">4</a>, <a href="generics.html#a018">5</a>, <a href="default-impl.html#a008">6</a><br/>
<code>cloned</code>, <a href="iterators.html#a029">1</a>, <a href="default-impl.html#a007">2</a><br/>
closure, <a href="use-types-2.html#a008">1</a><br/>
coercion, see type coercion<br/>
<code>collect</code>, <a href="iterators.html#a059">1</a><br/>
conditional compilation, <a href="features.html#a001">1</a><br/>
<code>const</code>, <a href="lifetimes.html#a029">1</a><br/>
continuous integration, <a href="semver.html#a024">1</a>, <a href="dep-graph.html#a013">2</a>, <a href="dep-graph.html#a019">3</a>, <a href="documentation.html#a007">4</a>, <a href="testing.html#a009">5</a>, <a href="testing.html#a010">6</a>, <a href="testing.html#a031">7</a>, <a href="ci.html#a001">8</a>, <a href="no-std.html#a030">9</a><br/>
<code>copied</code>, <a href="iterators.html#a030">1</a><br/>
<code>Copy</code>, <a href="std-traits.html#a006">1</a>, <a href="std-traits.html#a034">2</a>, <a href="std-traits.html#a067">3</a>, <a href="generics.html#a017">4</a>, <a href="borrows.html#a006">5</a><br/>
copy semantics, <a href="std-traits.html#a037">1</a><br/>
<code>core</code>, <a href="errors.html#a006">1</a>, <a href="no-std.html#a008">2</a><br/>
corpus, <a href="testing.html#a033">1</a><br/>
<code>Cow</code>, <a href="references.html#a039">1</a>, <a href="borrows.html#a033">2</a>, <a href="unsafe.html#a012">3</a><br/>
CPAN, <a href="deps.html#a002">1</a><br/>
<code>crates.io</code>, <a href="borrows.html#a031">1</a>, <a href="unsafe.html#a017">2</a>, <a href="semver.html#a007">3</a>, <a href="dep-graph.html#a003">4</a>, <a href="documentation.html#a008">5</a>, <a href="testing.html#a035">6</a><br/>
Criterion, <a href="testing.html#a020">1</a><br/>
cross-compilation, <a href="beyond-std.html#a001">1</a><br/>
CRUD, <a href="borrows.html#a009">1</a><br/>
<code>CString</code>, <a href="ffi.html#a020">1</a><br/>
<code>cxx</code>, <a href="unsafe.html#a021">1</a>, <a href="bindgen.html#a005">2</a><br/>
<code>cycle</code>, <a href="iterators.html#a025">1</a><br/>
data race, <a href="deadlock.html#a004">1</a>, <a href="deadlock.html#a036">2</a><br/>
deadlock, <a href="deadlock.html#a037">1</a>, <a href="deadlock.html#a040">2</a><br/>
<code>Debug</code>, <a href="errors.html#a009">1</a>, <a href="std-traits.html#a013">2</a>, <a href="std-traits.html#a058">3</a>, <a href="std-traits.html#a074">4</a><br/>
<code>Default</code>, <a href="std-traits.html#a007">1</a>, <a href="std-traits.html#a039">2</a>, <a href="std-traits.html#a068">3</a>, <a href="builders.html#a002">4</a><br/>
default features, <a href="semver.html#a019">1</a>, <a href="features.html#a008">2</a><br/>
default implementation, <a href="errors.html#a010">1</a>, <a href="generics.html#a012">2</a>, <a href="default-impl.html#a001">3</a>, <a href="semver.html#a011">4</a>, <a href="features.html#a012">5</a><br/>
<code>defer</code> (Go), <a href="raii.html#a004">1</a><br/>
Dependabot, <a href="semver.html#a029">1</a>, <a href="dep-graph.html#a015">2</a><br/>
dependency graph, <a href="newtype.html#a006">1</a><br/>
<code>Deref</code>, <a href="std-traits.html#a023">1</a>, <a href="std-traits.html#a115">2</a>, <a href="casts.html#a023">3</a>, <a href="references.html#a012">4</a>, <a href="deadlock.html#a022">5</a><br/>
<code>DerefMut</code>, <a href="std-traits.html#a024">1</a>, <a href="std-traits.html#a116">2</a>, <a href="casts.html#a024">3</a>, <a href="references.html#a013">4</a>, <a href="deadlock.html#a023">5</a><br/>
<code>derive</code>, <a href="errors.html#a019">1</a>, <a href="std-traits.html#a029">2</a>, <a href="std-traits.html#a040">3</a>, <a href="std-traits.html#a045">4</a>, <a href="std-traits.html#a053">5</a>, <a href="std-traits.html#a060">6</a>, <a href="std-traits.html#a064">7</a>, <a href="std-traits.html#a076">8</a>, <a href="std-traits.html#a099">9</a>, <a href="newtype.html#a009">10</a>, <a href="builders.html#a004">11</a><br/>
<code>derive_builder</code>, <a href="builders.html#a011">1</a><br/>
directed graph, <a href="deadlock.html#a042">1</a><br/>
<code>Display</code>, <a href="errors.html#a008">1</a>, <a href="std-traits.html#a014">2</a>, <a href="std-traits.html#a059">3</a>, <a href="std-traits.html#a065">4</a>, <a href="std-traits.html#a075">5</a><br/>
<code>Div</code>, <a href="std-traits.html#a085">1</a><br/>
<code>DivAssign</code>, <a href="std-traits.html#a086">1</a><br/>
<code>dlopen</code>, <a href="reflection.html#a030">1</a><br/>
doc test, see test, doc<br/>
domain-specific language, <a href="macros.html#a025">1</a>, <a href="macros.html#a028">2</a><br/>
<code>DoubleEndedIterator</code>, <a href="std-traits.html#a124">1</a>, <a href="iterators.html#a027">2</a><br/>
<code>downcast_mut</code>, <a href="reflection.html#a021">1</a><br/>
<code>downcast_ref</code>, <a href="reflection.html#a020">1</a><br/>
<code>Drop</code>, <a href="std-traits.html#a019">1</a>, <a href="std-traits.html#a125">2</a>, <a href="references.html#a033">3</a>, <a href="raii.html#a008">4</a>, <a href="raii.html#a011">5</a>, <a href="lifetimes.html#a016">6</a>, <a href="borrows.html#a016">7</a>, <a href="deadlock.html#a025">8</a>, <a href="ffi.html#a028">9</a><br/>
<code>drop</code>, <a href="raii.html#a012">1</a><br/>
DSL, see domain-specific language<br/>
duck typing, <a href="use-types-2.html#a029">1</a><br/>
<code>dynamic_cast</code> (C++), <a href="reflection.html#a008">1</a><br/>
<em>Effective C++</em>, <a href="intro.html#a003">1</a>, <a href="visibility.html#a009">2</a><br/>
<em>Effective Java</em>, <a href="use-types-2.html#a020">1</a>, <a href="reflection.html#a028">2</a>, <a href="visibility.html#a008">3</a>, <a href="documentation.html#a001">4</a><br/>
<code>enum</code>, <a href="use-types.html#a036">1</a>, <a href="use-types.html#a042">2</a>, <a href="use-types-2.html#a003">3</a>, <a href="transform.html#a001">4</a>, <a href="errors.html#a018">5</a>, <a href="casts.html#a021">6</a>, <a href="types.html#a004">7</a>, <a href="borrows.html#a032">8</a>, <a href="semver.html#a013">9</a>, <a href="macros.html#a024">10</a>, <a href="macros.html#a030">11</a><br/>
<code>enumerate</code>, <a href="iterators.html#a031">1</a><br/>
<code>Eq</code>, <a href="std-traits.html#a009">1</a>, <a href="std-traits.html#a044">2</a>, <a href="std-traits.html#a070">3</a><br/>
<code>Err</code>, <a href="use-types.html#a054">1</a>, <a href="transform.html#a008">2</a><br/>
<code>Error</code>, <a href="transform.html#a021">1</a>, <a href="errors.html#a004">2</a>, <a href="std-traits.html#a018">3</a>, <a href="std-traits.html#a105">4</a><br/>
error handling, <a href="use-types.html#a019">1</a><br/>
<code>ExactSizeIterator</code>, <a href="std-traits.html#a123">1</a>, <a href="default-impl.html#a003">2</a><br/>
exception, <a href="panic.html#a004">1</a>, <a href="no-std.html#a037">2</a><br/>
exception safety, <a href="panic.html#a010">1</a><br/>
exclamation mark, <a href="macros.html#a016">1</a><br/>
<code>expect</code>, <a href="transform.html#a012">1</a>, <a href="panic.html#a022">2</a>, <a href="clippy.html#a015">3</a><br/>
<code>expect_err</code>, <a href="panic.html#a023">1</a><br/>
<code>extern &quot;C&quot;</code>, <a href="ffi.html#a005">1</a>, <a href="ffi.html#a031">2</a><br/>
<code>extern crate</code>, <a href="no-std.html#a014">1</a><br/>
<code>f32</code>, <a href="use-types.html#a023">1</a><br/>
Â Â Â Â Â Â <code>f32::NAN</code>, <a href="std-traits.html#a049">1</a><br/>
<code>f64</code>, <a href="use-types.html#a024">1</a><br/>
Â Â Â Â Â Â <code>f64::NAN</code>, <a href="std-traits.html#a050">1</a><br/>
fallible, <a href="panic.html#a017">1</a>, <a href="no-std.html#a040">2</a><br/>
fat pointer, <a href="casts.html#a026">1</a>, <a href="references.html#a020">2</a>, <a href="generics.html#a007">3</a>, <a href="reflection.html#a016">4</a>, <a href="clippy.html#a012">5</a><br/>
@FearlessSon, <a href="testing.html#a001">1</a><br/>
feature, <a href="semver.html#a020">1</a>, <a href="dep-graph.html#a004">2</a>, <a href="features.html#a006">3</a>, <a href="clippy.html#a018">4</a>, <a href="ci.html#a009">5</a>, <a href="no-std.html#a031">6</a>, <a href="no-std.html#a041">7</a><br/>
feature unification, <a href="dep-graph.html#a011">1</a>, <a href="features.html#a011">2</a><br/>
Ferris, <a href="intro.html#a009">1</a><br/>
FFI, see foreign function interface<br/>
<code>file!()</code>, <a href="macros.html#a026">1</a><br/>
<code>filter</code>, <a href="iterators.html#a033">1</a><br/>
<code>find</code>, <a href="iterators.html#a051">1</a><br/>
<code>flatten</code>, <a href="iterators.html#a036">1</a><br/>
floating point, <a href="use-types.html#a022">1</a>, <a href="std-traits.html#a048">2</a><br/>
<code>Fn</code>, <a href="use-types-2.html#a012">1</a>, <a href="std-traits.html#a015">2</a>, <a href="std-traits.html#a102">3</a><br/>
<code>FnMut</code>, <a href="use-types-2.html#a011">1</a>, <a href="std-traits.html#a017">2</a>, <a href="std-traits.html#a103">3</a><br/>
<code>FnOnce</code>, <a href="use-types-2.html#a010">1</a>, <a href="std-traits.html#a016">2</a>, <a href="std-traits.html#a104">3</a><br/>
<code>fold</code>, <a href="iterators.html#a049">1</a><br/>
<code>for</code>, <a href="iterators.html#a003">1</a>, <a href="iterators.html#a040">2</a><br/>
for-each, <a href="iterators.html#a007">1</a><br/>
<code>for_each</code>, <a href="iterators.html#a039">1</a><br/>
foreign function interface, <a href="unsafe.html#a023">1</a>, <a href="panic.html#a013">2</a>, <a href="dep-graph.html#a007">3</a>, <a href="ffi.html#a001">4</a>, <a href="beyond-std.html#a002">5</a><br/>
formal verification, <a href="use-tools.html#a020">1</a><br/>
<code>format!</code>, <a href="no-std.html#a020">1</a><br/>
<code>free</code> (C), <a href="ffi.html#a026">1</a><br/>
<code>From</code>, <a href="transform.html#a023">1</a>, <a href="errors.html#a014">2</a>, <a href="errors.html#a016">3</a>, <a href="errors.html#a020">4</a>, <a href="errors.html#a022">5</a>, <a href="std-traits.html#a021">6</a>, <a href="std-traits.html#a106">7</a>, <a href="casts.html#a001">8</a>, <a href="casts.html#a007">9</a>, <a href="clippy.html#a008">10</a><br/>
<code>from_utf8</code>, <a href="panic.html#a019">1</a><br/>
<code>from_utf8_unchecked</code>, <a href="panic.html#a018">1</a><br/>
<code>FromIterator</code>, <a href="std-traits.html#a122">1</a><br/>
function pointer, <a href="use-types-2.html#a006">1</a>, <a href="generics.html#a009">2</a><br/>
functional style, <a href="iterators.html#a070">1</a><br/>
fuzz test, see test, fuzz<br/>
Galileo, <a href="lifetimes.html#a001">1</a><br/>
generics, <a href="use-types-2.html#a030">1</a>, <a href="generics.html#a002">2</a>, <a href="types.html#a007">3</a>, <a href="lifetimes.html#a035">4</a>, <a href="reflection.html#a032">5</a>, <a href="macros.html#a010">6</a>, <a href="macros.html#a022">7</a><br/>
Â Â Â Â Â Â generic function, <a href="transform.html#a019">1</a>, <a href="casts.html#a018">2</a>, <a href="references.html#a019">3</a>, <a href="reflection.html#a009">4</a><br/>
Â Â Â Â Â Â generic method, <a href="use-types-2.html#a035">1</a>, <a href="reflection.html#a018">2</a><br/>
Â Â Â Â Â Â generic trait, <a href="casts.html#a006">1</a><br/>
Â Â Â Â Â Â generic type, <a href="use-types-2.html#a022">1</a><br/>
<code>get_mut</code>, <a href="references.html#a047">1</a><br/>
GitHub Actions, <a href="ci.html#a021">1</a><br/>
Gjengset, Jon, <a href="borrows.html#a036">1</a><br/>
glob import, see wildcard import<br/>
global variable, <a href="lifetimes.html#a027">1</a><br/>
global variables, <a href="use-types.html#a050">1</a><br/>
Go, <a href="use-types.html#a004">1</a>, <a href="use-types.html#a051">2</a>, <a href="use-types-2.html#a016">3</a>, <a href="transform.html#a015">4</a>, <a href="deadlock.html#a007">5</a>, <a href="deadlock.html#a044">6</a>, <a href="reflection.html#a004">7</a>, <a href="dep-graph.html#a022">8</a><br/>
Godbolt compiler explorer, <a href="iterators.html#a068">1</a>, <a href="testing.html#a019">2</a><br/>
Graham, Paul, <a href="macros.html#a001">1</a><br/>
Groenen, Nick, <a href="errors.html#a029">1</a><br/>
<code>Hash</code>, <a href="std-traits.html#a012">1</a>, <a href="std-traits.html#a055">2</a>, <a href="std-traits.html#a073">3</a>, <a href="iterators.html#a018">4</a><br/>
<code>HashMap</code>, <a href="std-traits.html#a056">1</a>, <a href="iterators.html#a019">2</a>, <a href="iterators.html#a061">3</a>, <a href="no-std.html#a023">4</a><br/>
<code>HashSet</code>, <a href="std-traits.html#a057">1</a>, <a href="no-std.html#a024">2</a><br/>
Haskell, <a href="types.html#a003">1</a><br/>
heap, <a href="references.html#a009">1</a>, <a href="references.html#a024">2</a>, <a href="references.html#a046">3</a>, <a href="lifetimes.html#a005">4</a>, <a href="lifetimes.html#a030">5</a>, <a href="lifetimes.html#a032">6</a>, <a href="borrows.html#a043">7</a>, <a href="no-std.html#a011">8</a><br/>
hygienic macro, <a href="macros.html#a009">1</a><br/>
Hyrum's Law, <a href="semver.html#a008">1</a>, <a href="semver.html#a026">2</a><br/>
<code>i128</code>, <a href="use-types.html#a010">1</a><br/>
<code>i16</code>, <a href="use-types.html#a007">1</a><br/>
<code>i32</code>, <a href="use-types.html#a008">1</a><br/>
<code>i64</code>, <a href="use-types.html#a009">1</a><br/>
<code>i8</code>, <a href="use-types.html#a006">1</a><br/>
<code>if let</code>, <a href="transform.html#a009">1</a><br/>
<code>include!</code>, <a href="bindgen.html#a003">1</a><br/>
<code>Index</code>, <a href="std-traits.html#a117">1</a>, <a href="references.html#a028">2</a><br/>
<code>IndexMut</code>, <a href="std-traits.html#a118">1</a>, <a href="references.html#a029">2</a><br/>
infallible, <a href="panic.html#a016">1</a>, <a href="no-std.html#a035">2</a><br/>
<code>inline</code>, <a href="transform.html#a020">1</a><br/>
integration test, see test, integration<br/>
interior mutability, <a href="references.html#a049">1</a>, <a href="deadlock.html#a024">2</a><br/>
<code>Into</code>, <a href="std-traits.html#a108">1</a>, <a href="casts.html#a002">2</a>, <a href="casts.html#a009">3</a>, <a href="clippy.html#a009">4</a><br/>
<code>IntoIterator</code>, <a href="std-traits.html#a121">1</a>, <a href="iterators.html#a015">2</a><br/>
<code>is</code>, <a href="reflection.html#a019">1</a><br/>
<code>is_empty()</code>, <a href="default-impl.html#a002">1</a><br/>
<code>isize</code>, <a href="use-types.html#a016">1</a><br/>
iterable, <a href="iterators.html#a014">1</a><br/>
<code>Iterator</code>, <a href="std-traits.html#a025">1</a>, <a href="std-traits.html#a120">2</a>, <a href="iterators.html#a011">3</a>, <a href="iterators.html#a020">4</a>, <a href="default-impl.html#a006">5</a>, <a href="clippy.html#a013">6</a>, <a href="no-std.html#a007">7</a><br/>
iterator, <a href="iterators.html#a006">1</a><br/>
iterator transform, <a href="iterators.html#a010">1</a><br/>
Java, <a href="use-types.html#a005">1</a>, <a href="use-types-2.html#a017">2</a>, <a href="iterators.html#a008">3</a>, <a href="deadlock.html#a006">4</a>, <a href="panic.html#a005">5</a>, <a href="reflection.html#a003">6</a><br/>
lambda expression, <a href="use-types-2.html#a009">1</a><br/>
lattice, <a href="std-traits.html#a054">1</a><br/>
layout, <a href="ffi.html#a016">1</a>, <a href="bindgen.html#a004">2</a><br/>
<code>leak</code>, <a href="lifetimes.html#a031">1</a><br/>
<code>let</code>, <a href="borrows.html#a017">1</a><br/>
<code>libFuzzer</code>, <a href="testing.html#a029">1</a><br/>
license, <a href="semver.html#a018">1</a>, <a href="dep-graph.html#a018">2</a><br/>
lifetime, <a href="intro.html#a006">1</a>, <a href="lifetimes.html#a002">2</a>, <a href="concepts.html#a002">3</a>, <a href="ffi.html#a024">4</a><br/>
lifetime annotation, <a href="lifetimes.html#a033">1</a>, <a href="borrows.html#a019">2</a><br/>
lifetime bounds, <a href="lifetimes.html#a023">1</a>, <a href="lifetimes.html#a037">2</a><br/>
lifetime elision, <a href="lifetimes.html#a024">1</a>, <a href="lifetimes.html#a025">2</a><br/>
<code>line!()</code>, <a href="macros.html#a027">1</a><br/>
linker, <a href="newtype.html#a007">1</a>, <a href="generics.html#a010">2</a>, <a href="ffi.html#a010">3</a><br/>
Liskov substitution, <a href="generics.html#a014">1</a>, <a href="reflection.html#a025">2</a><br/>
Lisp, <a href="macros.html#a002">1</a><br/>
lock inversion, <a href="deadlock.html#a041">1</a><br/>
<code>lock_guard</code> (C++), <a href="deadlock.html#a014">1</a><br/>
locking hierarchy, <a href="deadlock.html#a050">1</a><br/>
macro, <a href="builders.html#a010">1</a>, <a href="borrows.html#a007">2</a>, <a href="reflection.html#a035">3</a>, <a href="visibility.html#a005">4</a>, <a href="macros.html#a003">5</a>, <a href="macros.html#a023">6</a><br/>
Â Â Â Â Â Â macro, declarative, <a href="macros.html#a013">1</a>, <a href="macros.html#a020">2</a><br/>
Â Â Â Â Â Â macro, derive, <a href="std-traits.html#a004">1</a>, <a href="reflection.html#a036">2</a>, <a href="macros.html#a029">3</a><br/>
Â Â Â Â Â Â macro, procedural, <a href="macros.html#a015">1</a><br/>
<code>macro_export</code>, <a href="macros.html#a014">1</a><br/>
<code>main</code>, <a href="panic.html#a015">1</a>, <a href="testing.html#a014">2</a><br/>
<code>map</code>, <a href="iterators.html#a028">1</a><br/>
<code>map_err</code>, <a href="transform.html#a022">1</a><br/>
Markdown, <a href="documentation.html#a002">1</a><br/>
marker trait, <a href="use-types-2.html#a021">1</a>, <a href="std-traits.html#a035">2</a>, <a href="std-traits.html#a046">3</a>, <a href="borrows.html#a040">4</a>, <a href="deadlock.html#a029">5</a><br/>
<code>match</code>, <a href="use-types.html#a039">1</a>, <a href="transform.html#a002">2</a>, <a href="semver.html#a012">3</a><br/>
<code>max</code>, <a href="iterators.html#a044">1</a><br/>
<code>max_by</code>, <a href="iterators.html#a047">1</a><br/>
memory safety, <a href="lifetimes.html#a003">1</a><br/>
metaprogramming, <a href="macros.html#a004">1</a><br/>
method signature, <a href="use-types-2.html#a005">1</a><br/>
methods, <a href="use-types-2.html#a001">1</a><br/>
Meyers, Scott, <a href="intro.html#a002">1</a>, <a href="documentation.html#a012">2</a><br/>
<code>min</code>, <a href="iterators.html#a043">1</a><br/>
<code>min_by</code>, <a href="iterators.html#a046">1</a><br/>
<code>minimal-versions</code>, <a href="semver.html#a005">1</a>, <a href="ci.html#a008">2</a><br/>
minimum supported Rust version, <a href="semver.html#a021">1</a>, <a href="semver.html#a023">2</a>, <a href="ci.html#a007">3</a><br/>
Miri, <a href="unsafe.html#a024">1</a><br/>
module, <a href="visibility.html#a001">1</a>, <a href="wildcard.html#a002">2</a>, <a href="testing.html#a004">3</a><br/>
monomorphization, <a href="use-types-2.html#a026">1</a>, <a href="generics.html#a006">2</a>, <a href="reflection.html#a010">3</a>, <a href="reflection.html#a031">4</a><br/>
<em>More Effective C++</em>, <a href="documentation.html#a013">1</a><br/>
move semantics, <a href="std-traits.html#a036">1</a>, <a href="lifetimes.html#a017">2</a>, <a href="borrows.html#a010">3</a><br/>
<code>mpsc</code>, <a href="deadlock.html#a046">1</a><br/>
MSRV, see minimum supported Rust version<br/>
<code>Mul</code>, <a href="std-traits.html#a087">1</a><br/>
<code>MulAssign</code>, <a href="std-traits.html#a088">1</a><br/>
<code>must_use</code>, <a href="transform.html#a014">1</a><br/>
mutable reference, <a href="references.html#a007">1</a><br/>
<code>Mutex</code>, <a href="std-traits.html#a033">1</a>, <a href="references.html#a054">2</a>, <a href="raii.html#a005">3</a>, <a href="borrows.html#a024">4</a>, <a href="unsafe.html#a009">5</a>, <a href="deadlock.html#a020">6</a>, <a href="no-std.html#a025">7</a><br/>
<code>MutexGuard</code>, <a href="std-traits.html#a032">1</a>, <a href="references.html#a055">2</a>, <a href="raii.html#a009">3</a>, <a href="deadlock.html#a021">4</a><br/>
name mangling, <a href="ffi.html#a012">1</a><br/>
<code>Neg</code>, <a href="std-traits.html#a062">1</a>, <a href="std-traits.html#a089">2</a><br/>
newtype pattern, <a href="use-types.html#a038">1</a>, <a href="errors.html#a013">2</a>, <a href="newtype.html#a002">3</a><br/>
<code>nm</code>, <a href="ffi.html#a013">1</a><br/>
<code>no_deadlocks</code>, <a href="deadlock.html#a047">1</a><br/>
<code>no_mangle</code>, <a href="ffi.html#a006">1</a><br/>
<code>no_panic</code>, <a href="panic.html#a026">1</a><br/>
<code>no_std</code>, <a href="errors.html#a005">1</a>, <a href="features.html#a013">2</a>, <a href="ci.html#a013">3</a>, <a href="no-std.html#a004">4</a><br/>
non-lexical lifetimes, <a href="lifetimes.html#a021">1</a>, <a href="borrows.html#a014">2</a>, <a href="borrows.html#a018">3</a><br/>
<code>non_exhaustive</code>, <a href="use-types.html#a040">1</a>, <a href="semver.html#a014">2</a><br/>
<code>None</code>, <a href="use-types.html#a045">1</a>, <a href="transform.html#a005">2</a>, <a href="iterators.html#a013">3</a><br/>
<code>NonNull</code>, <a href="borrows.html#a038">1</a><br/>
<code>Not</code>, <a href="std-traits.html#a090">1</a><br/>
<code>nothrow</code> (C++), <a href="no-std.html#a038">1</a><br/>
<code>nth</code>, <a href="iterators.html#a053">1</a><br/>
<code>NULL</code> (SQL), <a href="use-types.html#a047">1</a><br/>
<code>nullptr</code> (C++), <a href="borrows.html#a005">1</a><br/>
object safety, <a href="use-types-2.html#a036">1</a>, <a href="generics.html#a015">2</a>, <a href="semver.html#a016">3</a><br/>
object-oriented, <a href="use-types-2.html#a002">1</a>, <a href="use-types-2.html#a019">2</a>, <a href="generics.html#a023">3</a>, <a href="reflection.html#a023">4</a><br/>
OCaml, <a href="types.html#a002">1</a><br/>
ODR, see one definition rule<br/>
<code>Ok</code>, <a href="use-types.html#a053">1</a>, <a href="transform.html#a007">2</a><br/>
<code>once_cell</code>, <a href="unsafe.html#a018">1</a><br/>
one definition rule, <a href="reflection.html#a033">1</a>, <a href="dep-graph.html#a008">2</a><br/>
<code>Option</code>, <a href="use-types.html#a043">1</a>, <a href="transform.html#a003">2</a>, <a href="errors.html#a001">3</a>, <a href="iterators.html#a037">4</a>, <a href="borrows.html#a013">5</a>, <a href="clippy.html#a006">6</a>, <a href="no-std.html#a005">7</a><br/>
<code>Ord</code>, <a href="std-traits.html#a011">1</a>, <a href="std-traits.html#a052">2</a>, <a href="std-traits.html#a072">3</a>, <a href="iterators.html#a045">4</a><br/>
orphan rule, <a href="errors.html#a011">1</a>, <a href="errors.html#a021">2</a>, <a href="newtype.html#a005">3</a>, <a href="builders.html#a005">4</a><br/>
OSS-Fuzz, <a href="testing.html#a032">1</a><br/>
ostrich manoeuvre, <a href="transform.html#a010">1</a><br/>
<code>ouroborous</code>, <a href="borrows.html#a044">1</a><br/>
<code>panic!</code>, <a href="use-types.html#a020">1</a>, <a href="transform.html#a013">2</a>, <a href="transform.html#a024">3</a>, <a href="borrows.html#a028">4</a>, <a href="panic.html#a003">5</a>, <a href="documentation.html#a004">6</a>, <a href="clippy.html#a014">7</a>, <a href="testing.html#a027">8</a>, <a href="no-std.html#a034">9</a><br/>
<code>parking_lot::deadlock</code>, <a href="deadlock.html#a049">1</a><br/>
<code>PartialEq</code>, <a href="std-traits.html#a008">1</a>, <a href="std-traits.html#a043">2</a>, <a href="std-traits.html#a069">3</a><br/>
<code>PartialOrd</code>, <a href="std-traits.html#a010">1</a>, <a href="std-traits.html#a051">2</a>, <a href="std-traits.html#a071">3</a><br/>
<code>partition</code>, <a href="iterators.html#a065">1</a><br/>
<code>PhantomPinned</code>, <a href="borrows.html#a041">1</a><br/>
<code>Pin</code>, <a href="borrows.html#a037">1</a>, <a href="unsafe.html#a011">2</a><br/>
<code>Pointer</code>, <a href="std-traits.html#a119">1</a>, <a href="references.html#a034">2</a><br/>
pointer, <a href="references.html#a001">1</a>, <a href="unsafe.html#a002">2</a>, <a href="ffi.html#a021">3</a><br/>
<code>position</code>, <a href="iterators.html#a052">1</a><br/>
prelude, <a href="wildcard.html#a006">1</a>, <a href="no-std.html#a002">2</a>, <a href="no-std.html#a010">3</a>, <a href="no-std.html#a029">4</a><br/>
preprocessor (C), <a href="macros.html#a007">1</a>, <a href="macros.html#a021">2</a><br/>
principle of least astonishment, <a href="documentation.html#a011">1</a>, <a href="macros.html#a019">2</a><br/>
<code>product</code>, <a href="iterators.html#a042">1</a><br/>
<em>Programming Rust</em>, <a href="iterators.html#a066">1</a><br/>
<code>prost</code>, <a href="ci.html#a018">1</a><br/>
protocol buffer, <a href="ci.html#a017">1</a><br/>
<code>pub</code>, <a href="visibility.html#a002">1</a>, <a href="visibility.html#a007">2</a>, <a href="testing.html#a005">3</a><br/>
Â Â Â Â Â Â <code>pub(crate)</code>, <a href="visibility.html#a003">1</a><br/>
Â Â Â Â Â Â <code>pub(super)</code>, <a href="visibility.html#a004">1</a><br/>
Python, <a href="deadlock.html#a008">1</a>, <a href="reflection.html#a002">2</a><br/>
question mark, see <code>?</code><br/>
RAII, <a href="std-traits.html#a020">1</a>, <a href="std-traits.html#a030">2</a>, <a href="raii.html#a002">3</a>, <a href="lifetimes.html#a011">4</a>, <a href="deadlock.html#a015">5</a>, <a href="ffi.html#a027">6</a><br/>
<code>rand</code>, <a href="unsafe.html#a019">1</a>, <a href="re-export.html#a002">2</a>, <a href="documentation.html#a009">3</a><br/>
<code>Range</code>, <a href="references.html#a026">1</a><br/>
range expression, <a href="references.html#a025">1</a><br/>
range expressions, <a href="iterators.html#a063">1</a><br/>
raw pointer, <a href="references.html#a003">1</a>, <a href="unsafe.html#a003">2</a>, <a href="deadlock.html#a035">3</a>, <a href="ffi.html#a023">4</a><br/>
<code>Rc</code>, <a href="references.html#a041">1</a>, <a href="lifetimes.html#a034">2</a>, <a href="borrows.html#a021">3</a>, <a href="unsafe.html#a006">4</a>, <a href="no-std.html#a016">5</a><br/>
re-export, <a href="wildcard.html#a005">1</a>, <a href="re-export.html#a006">2</a>, <a href="no-std.html#a009">3</a><br/>
<code>reduce</code>, <a href="iterators.html#a048">1</a><br/>
<code>Ref</code>, <a href="lifetimes.html#a038">1</a><br/>
<code>Ref&lt;T&gt;</code>, <a href="references.html#a050">1</a><br/>
<code>RefCell</code>, <a href="lifetimes.html#a039">1</a>, <a href="borrows.html#a022">2</a>, <a href="unsafe.html#a007">3</a>, <a href="deadlock.html#a034">4</a><br/>
<code>RefCell&lt;T&gt;</code>, <a href="references.html#a048">1</a><br/>
reference, <a href="use-types-2.html#a033">1</a>, <a href="references.html#a004">2</a>, <a href="lifetimes.html#a015">3</a>, <a href="borrows.html#a001">4</a>, <a href="ffi.html#a022">5</a><br/>
reflection, <a href="reflection.html#a001">1</a><br/>
reflexive, <a href="std-traits.html#a047">1</a>, <a href="casts.html#a017">2</a><br/>
<code>RefMut&lt;T&gt;</code>, <a href="references.html#a051">1</a><br/>
Reid, Alastair, <a href="use-tools.html#a019">1</a><br/>
<code>Rem</code>, <a href="std-traits.html#a091">1</a><br/>
<code>RemAssign</code>, <a href="std-traits.html#a092">1</a><br/>
<code>replace</code>, <a href="borrows.html#a011">1</a>, <a href="unsafe.html#a015">2</a><br/>
<code>repr(C)</code>, <a href="ffi.html#a017">1</a><br/>
<code>repr(transparent)</code>, <a href="newtype.html#a004">1</a><br/>
required method, <a href="default-impl.html#a004">1</a><br/>
<code>Result</code>, <a href="use-types.html#a052">1</a>, <a href="transform.html#a006">2</a>, <a href="errors.html#a002">3</a>, <a href="casts.html#a011">4</a>, <a href="iterators.html#a038">5</a>, <a href="iterators.html#a067">6</a>, <a href="panic.html#a002">7</a>, <a href="panic.html#a014">8</a>, <a href="clippy.html#a007">9</a>, <a href="testing.html#a013">10</a>, <a href="no-std.html#a006">11</a><br/>
<code>return</code>, <a href="macros.html#a017">1</a><br/>
<code>rev</code>, <a href="iterators.html#a026">1</a><br/>
rewrite it in Rust, <a href="ffi.html#a002">1</a><br/>
RIIR, see rewrite it in Rust<br/>
<code>ring</code>, <a href="dep-graph.html#a009">1</a><br/>
RTTI, <a href="reflection.html#a006">1</a><br/>
<em>Rust for Rustaceans</em>, <a href="borrows.html#a035">1</a><br/>
<code>rust-semverver</code>, <a href="semver.html#a022">1</a><br/>
RustCrypto, <a href="re-export.html#a003">1</a><br/>
<code>rustfilt</code>, <a href="ffi.html#a032">1</a><br/>
<code>rustfmt</code>, <a href="use-tools.html#a002">1</a>, <a href="ci.html#a012">2</a><br/>
<em>Rustonomicon</em>, <a href="ffi.html#a004">1</a>, <a href="beyond-std.html#a003">2</a><br/>
<code>RwLock</code>, <a href="references.html#a056">1</a>, <a href="borrows.html#a025">2</a>, <a href="unsafe.html#a010">3</a><br/>
<code>scan</code>, <a href="iterators.html#a050">1</a><br/>
scope, <a href="lifetimes.html#a018">1</a><br/>
segment, <a href="lifetimes.html#a004">1</a><br/>
<code>Self</code>, <a href="use-types-2.html#a034">1</a>, <a href="builders.html#a007">2</a>, <a href="iterators.html#a016">3</a>, <a href="iterators.html#a017">4</a>, <a href="generics.html#a016">5</a><br/>
semantic versioning, <a href="semver.html#a003">1</a>, <a href="re-export.html#a005">2</a>, <a href="dep-graph.html#a014">3</a>, <a href="testing.html#a006">4</a>, <a href="use-tools.html#a009">5</a><br/>
semicolon, <a href="lifetimes.html#a019">1</a><br/>
semver, see semantic versioning<br/>
<code>Send</code>, <a href="std-traits.html#a026">1</a>, <a href="std-traits.html#a100">2</a>, <a href="std-traits.html#a127">3</a>, <a href="lifetimes.html#a040">4</a>, <a href="deadlock.html#a030">5</a><br/>
sentinel values, <a href="use-types.html#a046">1</a>, <a href="use-types.html#a049">2</a><br/>
separate compilation, <a href="ffi.html#a009">1</a><br/>
<code>serde</code>, <a href="newtype.html#a008">1</a><br/>
shared-state, <a href="references.html#a057">1</a>, <a href="raii.html#a010">2</a>, <a href="unsafe.html#a025">3</a>, <a href="deadlock.html#a003">4</a>, <a href="deadlock.html#a027">5</a>, <a href="deadlock.html#a043">6</a><br/>
<code>shared_ptr</code> (C++), <a href="references.html#a042">1</a>, <a href="borrows.html#a027">2</a><br/>
<code>Shl</code>, <a href="std-traits.html#a093">1</a><br/>
<code>ShlAssign</code>, <a href="std-traits.html#a094">1</a><br/>
<code>Shr</code>, <a href="std-traits.html#a095">1</a><br/>
<code>ShrAssign</code>, <a href="std-traits.html#a096">1</a><br/>
<code>Sized</code>, <a href="std-traits.html#a126">1</a>, <a href="generics.html#a020">2</a><br/>
Â Â Â Â Â Â <code>!Sized</code>, <a href="generics.html#a021">1</a><br/>
<code>skip</code>, <a href="iterators.html#a022">1</a><br/>
<code>skip_while</code>, <a href="iterators.html#a035">1</a><br/>
<code>sleep</code>, <a href="deadlock.html#a010">1</a><br/>
slice, <a href="references.html#a021">1</a><br/>
<code>SliceIndex&lt;T&gt;</code>, <a href="references.html#a027">1</a><br/>
smart pointer, <a href="casts.html#a016">1</a>, <a href="references.html#a040">2</a>, <a href="borrows.html#a020">3</a>, <a href="unsafe.html#a005">4</a><br/>
Smith, Agent, <a href="raii.html#a001">1</a><br/>
software engineering, <a href="tooling.html#a002">1</a><br/>
<code>Some</code>, <a href="use-types.html#a044">1</a>, <a href="transform.html#a004">2</a>, <a href="iterators.html#a012">3</a><br/>
<code>spin</code>, <a href="no-std.html#a027">1</a><br/>
SQL, <a href="use-types.html#a048">1</a><br/>
stack, <a href="references.html#a008">1</a>, <a href="lifetimes.html#a006">2</a><br/>
stack frame, <a href="lifetimes.html#a007">1</a><br/>
stack pointer, <a href="lifetimes.html#a008">1</a><br/>
<code>'static</code>, <a href="lifetimes.html#a022">1</a>, <a href="lifetimes.html#a026">2</a><br/>
<code>static</code>, <a href="lifetimes.html#a028">1</a><br/>
<code>std</code>, <a href="no-std.html#a001">1</a>, <a href="no-std.html#a026">2</a><br/>
<code>step_by</code>, <a href="iterators.html#a023">1</a><br/>
<code>String</code>, <a href="references.html#a018">1</a>, <a href="no-std.html#a019">2</a>, <a href="ffi.html#a018">3</a><br/>
<code>struct</code>, <a href="use-types-2.html#a004">1</a>, <a href="builders.html#a001">2</a>, <a href="borrows.html#a042">3</a>, <a href="semver.html#a015">4</a>, <a href="ffi.html#a015">5</a><br/>
struct, <a href="use-types.html#a034">1</a><br/>
struct update syntax, <a href="std-traits.html#a041">1</a>, <a href="builders.html#a003">2</a><br/>
<code>Sub</code>, <a href="std-traits.html#a063">1</a>, <a href="std-traits.html#a097">2</a><br/>
<code>SubAssign</code>, <a href="std-traits.html#a098">1</a><br/>
<code>sum</code>, <a href="iterators.html#a041">1</a><br/>
supply chain attacks, <a href="dep-graph.html#a021">1</a>, <a href="ci.html#a022">2</a><br/>
Sutter, Herb, <a href="panic.html#a012">1</a><br/>
<code>swap</code>, <a href="unsafe.html#a014">1</a><br/>
<code>syn</code>, <a href="use-tools.html#a016">1</a><br/>
<code>Sync</code>, <a href="std-traits.html#a027">1</a>, <a href="std-traits.html#a101">2</a>, <a href="std-traits.html#a128">3</a>, <a href="deadlock.html#a031">4</a><br/>
synchronization, <a href="deadlock.html#a018">1</a><br/>
syntactic sugar, <a href="transform.html#a017">1</a><br/>
tag (Git), <a href="semver.html#a006">1</a><br/>
<code>take</code>, <a href="iterators.html#a021">1</a>, <a href="unsafe.html#a013">2</a><br/>
<code>take_while</code>, <a href="iterators.html#a034">1</a><br/>
taste, <a href="iterators.html#a069">1</a><br/>
template (C++), <a href="use-types-2.html#a027">1</a>, <a href="generics.html#a005">2</a><br/>
temporaries, <a href="lifetimes.html#a020">1</a><br/>
test, <a href="testing.html#a002">1</a><br/>
Â Â Â Â Â Â test, doc, <a href="documentation.html#a003">1</a>, <a href="testing.html#a008">2</a>, <a href="ci.html#a004">3</a><br/>
Â Â Â Â Â Â test, fuzz, <a href="testing.html#a022">1</a><br/>
Â Â Â Â Â Â test, integration, <a href="deadlock.html#a039">1</a>, <a href="testing.html#a007">2</a>, <a href="ci.html#a003">3</a><br/>
Â Â Â Â Â Â test, unit, <a href="deadlock.html#a038">1</a>, <a href="testing.html#a003">2</a>, <a href="ci.html#a002">3</a><br/>
test, flaky, <a href="ci.html#a019">1</a><br/>
@thingskatedid, <a href="use-types.html#a001">1</a><br/>
<code>thiserror</code>, <a href="errors.html#a024">1</a><br/>
thread-compatible, <a href="deadlock.html#a011">1</a><br/>
thread-hostile, <a href="deadlock.html#a013">1</a><br/>
thread-safe, <a href="deadlock.html#a012">1</a>, <a href="deadlock.html#a019">2</a><br/>
ThreadSanitizer, <a href="deadlock.html#a048">1</a>, <a href="testing.html#a025">2</a><br/>
Tolnay, David, <a href="errors.html#a027">1</a><br/>
<code>ToOwned</code>, <a href="std-traits.html#a114">1</a>, <a href="references.html#a038">2</a><br/>
trait, <a href="use-types-2.html#a015">1</a>, <a href="std-traits.html#a002">2</a>, <a href="types.html#a006">3</a>, <a href="reflection.html#a029">4</a><br/>
trait bound, <a href="use-types-2.html#a014">1</a>, <a href="use-types-2.html#a024">2</a>, <a href="use-types-2.html#a025">3</a>, <a href="errors.html#a007">4</a>, <a href="casts.html#a014">5</a>, <a href="generics.html#a001">6</a>, <a href="generics.html#a011">7</a>, <a href="generics.html#a019">8</a>, <a href="default-impl.html#a005">9</a>, <a href="lifetimes.html#a036">10</a>, <a href="reflection.html#a024">11</a>, <a href="macros.html#a011">12</a><br/>
trait coherence, <a href="casts.html#a013">1</a><br/>
trait object, <a href="use-types-2.html#a023">1</a>, <a href="use-types-2.html#a031">2</a>, <a href="errors.html#a025">3</a>, <a href="casts.html#a025">4</a>, <a href="references.html#a030">5</a>, <a href="generics.html#a003">6</a>, <a href="reflection.html#a015">7</a>, <a href="reflection.html#a022">8</a><br/>
<code>try_find</code>, <a href="iterators.html#a058">1</a><br/>
<code>try_fold</code>, <a href="iterators.html#a057">1</a><br/>
<code>try_for_each</code>, <a href="iterators.html#a056">1</a><br/>
<code>TryFrom</code>, <a href="std-traits.html#a022">1</a>, <a href="std-traits.html#a107">2</a>, <a href="casts.html#a008">3</a><br/>
<code>TryInto</code>, <a href="std-traits.html#a109">1</a>, <a href="casts.html#a010">2</a><br/>
tuple, <a href="use-types.html#a033">1</a><br/>
tuple struct, <a href="use-types.html#a035">1</a>, <a href="newtype.html#a001">2</a><br/>
Turon, Aaron, <a href="deadlock.html#a001">1</a><br/>
type alias, <a href="errors.html#a012">1</a>, <a href="newtype.html#a003">2</a><br/>
type coercion, <a href="use-types-2.html#a007">1</a>, <a href="casts.html#a005">2</a>, <a href="casts.html#a022">3</a>, <a href="references.html#a014">4</a><br/>
type erasure, <a href="generics.html#a022">1</a><br/>
type system, <a href="use-types.html#a002">1</a>, <a href="transform.html#a018">2</a>, <a href="std-traits.html#a001">3</a>, <a href="types.html#a001">4</a><br/>
<code>type_name</code>, <a href="reflection.html#a011">1</a><br/>
<code>TypeId</code>, <a href="reflection.html#a012">1</a><br/>
<code>typeid</code> (C++), <a href="reflection.html#a007">1</a><br/>
<code>u128</code>, <a href="use-types.html#a015">1</a><br/>
<code>u16</code>, <a href="use-types.html#a012">1</a><br/>
<code>u32</code>, <a href="use-types.html#a013">1</a><br/>
<code>u64</code>, <a href="use-types.html#a014">1</a><br/>
<code>u8</code>, <a href="use-types.html#a011">1</a><br/>
Unicode, <a href="use-types.html#a029">1</a>, <a href="use-types.html#a031">2</a><br/>
<code>unique_ptr</code> (C++), <a href="references.html#a011">1</a><br/>
unit test, see test, unit<br/>
unit type, see <code>()</code><br/>
<code>Unpin</code>, <a href="borrows.html#a039">1</a><br/>
<code>unreachable!</code>, <a href="panic.html#a024">1</a><br/>
<code>unsafe</code>, <a href="raii.html#a007">1</a>, <a href="borrows.html#a012">2</a>, <a href="borrows.html#a030">3</a>, <a href="unsafe.html#a004">4</a>, <a href="deadlock.html#a028">5</a>, <a href="documentation.html#a005">6</a>, <a href="testing.html#a026">7</a><br/>
<code>unwrap</code>, <a href="transform.html#a011">1</a>, <a href="panic.html#a020">2</a><br/>
<code>unwrap_err</code>, <a href="panic.html#a021">1</a><br/>
<code>unzip</code>, <a href="iterators.html#a064">1</a><br/>
<code>use</code>, <a href="wildcard.html#a001">1</a>, <a href="no-std.html#a003">2</a>, <a href="no-std.html#a028">3</a><br/>
use-after-free, <a href="ffi.html#a025">1</a><br/>
<code>usize</code>, <a href="use-types.html#a017">1</a><br/>
UTF-8, <a href="use-types.html#a030">1</a>, <a href="errors.html#a017">2</a>, <a href="ffi.html#a019">3</a><br/>
<code>Vec</code>, <a href="references.html#a023">1</a>, <a href="iterators.html#a060">2</a>, <a href="no-std.html#a013">3</a>, <a href="no-std.html#a018">4</a><br/>
vigilance, constant, <a href="panic.html#a025">1</a><br/>
<code>void</code> (C), <a href="use-types.html#a027">1</a><br/>
vtable, <a href="use-types-2.html#a032">1</a>, <a href="casts.html#a027">2</a>, <a href="references.html#a031">3</a>, <a href="generics.html#a008">4</a>, <a href="generics.html#a013">5</a>, <a href="reflection.html#a017">6</a>, <a href="reflection.html#a027">7</a><br/>
<code>Weak</code>, <a href="references.html#a044">1</a>, <a href="borrows.html#a029">2</a><br/>
<code>weak_ptr</code> (C++), <a href="references.html#a045">1</a><br/>
WebAssembly, <a href="panic.html#a009">1</a><br/>
wildcard dependency, <a href="semver.html#a027">1</a>, <a href="clippy.html#a016">2</a><br/>
wildcard import, <a href="semver.html#a010">1</a>, <a href="wildcard.html#a003">2</a>, <a href="clippy.html#a017">3</a><br/>
Wilde, Oscar, <a href="deps.html#a001">1</a><br/>
Winters, Titus, <a href="semver.html#a001">1</a>, <a href="tooling.html#a001">2</a><br/>
<code>zip</code>, <a href="iterators.html#a032">1</a><br/></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/third_party/ferris/ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
