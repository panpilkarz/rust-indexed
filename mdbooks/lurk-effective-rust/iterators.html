<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Item 10: Consider using iterator transforms instead of explicit loops - Effective Rust</title>


        <!-- Custom HTML head -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-23228806-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
        <meta name="description" content="A collection of specific ways to improve your use of Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/third_party/ferris/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cover.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="use-types.html"><strong aria-hidden="true">3.1.</strong> Item 1: Use the type system to express your data structures</a></li><li class="chapter-item expanded "><a href="use-types-2.html"><strong aria-hidden="true">3.2.</strong> Item 2: Use the type system to express common behaviour</a></li><li class="chapter-item expanded "><a href="transform.html"><strong aria-hidden="true">3.3.</strong> Item 3: Avoid matching Option and Result</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">3.4.</strong> Item 4: Prefer idiomatic Error variants</a></li><li class="chapter-item expanded "><a href="std-traits.html"><strong aria-hidden="true">3.5.</strong> Item 5: Familiarize yourself with standard traits</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">3.6.</strong> Item 6: Understand type conversions</a></li><li class="chapter-item expanded "><a href="newtype.html"><strong aria-hidden="true">3.7.</strong> Item 7: Embrace the newtype pattern</a></li><li class="chapter-item expanded "><a href="builders.html"><strong aria-hidden="true">3.8.</strong> Item 8: Use builders for complex types</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.9.</strong> Item 9: Familiarize yourself with reference and pointer types</a></li><li class="chapter-item expanded "><a href="iterators.html" class="active"><strong aria-hidden="true">3.10.</strong> Item 10: Consider using iterator transforms instead of explicit loops</a></li><li class="chapter-item expanded "><a href="raii.html"><strong aria-hidden="true">3.11.</strong> Item 11: Implement the Drop trait for RAII patterns</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">3.12.</strong> Item 12: Prefer generics to trait objects</a></li><li class="chapter-item expanded "><a href="default-impl.html"><strong aria-hidden="true">3.13.</strong> Item 13: Use default implementations to minimize required trait methods</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">4.1.</strong> Item 14: Understand lifetimes</a></li><li class="chapter-item expanded "><a href="borrows.html"><strong aria-hidden="true">4.2.</strong> Item 15: Understand the borrow checker</a></li><li class="chapter-item expanded "><a href="unsafe.html"><strong aria-hidden="true">4.3.</strong> Item 16: Avoid writing unsafe code</a></li><li class="chapter-item expanded "><a href="deadlock.html"><strong aria-hidden="true">4.4.</strong> Item 17: Be wary of shared-state parallelism</a></li><li class="chapter-item expanded "><a href="panic.html"><strong aria-hidden="true">4.5.</strong> Item 18: Don't panic</a></li><li class="chapter-item expanded "><a href="reflection.html"><strong aria-hidden="true">4.6.</strong> Item 19: Avoid reflection</a></li><li class="chapter-item expanded "><a href="optimize.html"><strong aria-hidden="true">4.7.</strong> Item 20: Avoid the temptation to over-optimize</a></li></ol></li><li class="chapter-item expanded "><a href="deps.html"><strong aria-hidden="true">5.</strong> Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="semver.html"><strong aria-hidden="true">5.1.</strong> Item 21: Understand what semantic versioning promises</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.2.</strong> Item 22: Minimize visibility</a></li><li class="chapter-item expanded "><a href="wildcard.html"><strong aria-hidden="true">5.3.</strong> Item 23: Avoid wildcard imports</a></li><li class="chapter-item expanded "><a href="re-export.html"><strong aria-hidden="true">5.4.</strong> Item 24: Re-export dependencies whose types appear in your API</a></li><li class="chapter-item expanded "><a href="dep-graph.html"><strong aria-hidden="true">5.5.</strong> Item 25: Manage your dependency graph</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">5.6.</strong> Item 26: Be wary of feature creep</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">6.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">6.1.</strong> Item 27: Document public interfaces</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">6.2.</strong> Item 28: Use macros judiciously</a></li><li class="chapter-item expanded "><a href="clippy.html"><strong aria-hidden="true">6.3.</strong> Item 29: Listen to Clippy</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.4.</strong> Item 30: Write more than unit tests</a></li><li class="chapter-item expanded "><a href="use-tools.html"><strong aria-hidden="true">6.5.</strong> Item 31: Take advantage of the tooling ecosystem</a></li><li class="chapter-item expanded "><a href="ci.html"><strong aria-hidden="true">6.6.</strong> Item 32: Set up a continuous integration (CI) system</a></li></ol></li><li class="chapter-item expanded "><a href="beyond-std.html"><strong aria-hidden="true">7.</strong> Beyond Standard Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="no-std.html"><strong aria-hidden="true">7.1.</strong> Item 33: Consider making library code no_std compatible</a></li><li class="chapter-item expanded "><a href="ffi.html"><strong aria-hidden="true">7.2.</strong> Item 34: Control what crosses FFI boundaries</a></li><li class="chapter-item expanded "><a href="bindgen.html"><strong aria-hidden="true">7.3.</strong> Item 35: Prefer bindgen to manual FFI mappings</a></li></ol></li><li class="chapter-item expanded "><a href="indexing.html"><strong aria-hidden="true">8.</strong> Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="item-10-consider-using-iterator-transforms-instead-of-explicit-loops"><a class="header" href="#item-10-consider-using-iterator-transforms-instead-of-explicit-loops">Item 10: Consider using iterator transforms instead of explicit loops</a></h1>
<p>The humble loop has had a long journey of increasing convenience and increasing abstraction.  The
<a name="a001"></a><a href="https://web.archive.org/web/20150611114427/https://www.bell-labs.com/usr/dmr/www/kbman.pdf">B</a> language (the
precursor to <a name="a002"></a>C) only had <code>while (condition) { ... }</code>, but with the arrival of C the common scenario of iterating
through indexes of an array was made more convenient with the addition of the <a name="a003"></a><code>for</code> loop:</p>
<pre><code class="language-c">  // C code
  int i;
  for (i = 0; i &lt; len; i++) {
    Item item = collection[i];
    // body
  }
</code></pre>
<p>The early versions of <a name="a004"></a>C++ improved convenience and scoping further by allowing the loop variable declaration to be
embedded in the <code>for</code> statement (and this was also adopted by C in <a name="a005"></a>C99):</p>
<pre><code class="language-c++">  // C++98 code
  for (int i = 0; i &lt; len; i++) {
    Item item = collection[i];
    // ...
  }
</code></pre>
<p>Most modern languages abstract the idea of the loop further: the core function of a loop is often to move to the next
item of some container, and tracking the logistics that are required to reach that item (<code>index++</code> or <code>++it</code>) is mostly
an irrelevant detail.  This realization produced two core concepts:</p>
<ul>
<li><a name="a006"></a><strong>Iterators</strong>: a type whose purpose is to repeatedly emit the next item of a container<sup><a name="to-footnote-1"><a href="#footnote-1">1</a></a></sup>, until exhausted.</li>
<li><a name="a007"></a><strong>For-Each Loops</strong>: a compact loop expression for iterating over all of the items in a container, binding a loop
variable to the <em>item</em> rather than to the details of reaching that item.</li>
</ul>
<p>These concepts allow for loop code that's shorter, and (more importantly) clearer about what's intended:</p>
<pre><code class="language-c++">  // C++11 code
  for (Item&amp; item : collection) {
    // ...
  }
</code></pre>
<p>Once these concepts were available, they were so obviously powerful that they were quickly retrofitted to those
languages that didn't already have them (e.g. for-each loops were added to <a href="https://docs.oracle.com/javase/1.5.0/docs/guide/language/foreach.html"><a name="a008"></a>Java
1.5</a> and <a name="a009"></a>C++11).</p>
<p>Rust includes iterators and for-each style loops, but it also includes the next step in abstraction: allowing the whole
loop to be expressed as an <em><a name="a010"></a>iterator transform</em>.  As with <a href="transform.html">Item 3</a>'s discussion of <code>Option</code> and <code>Result</code>, this
Item will attempt to show how these iterator transforms can be used instead of explicit loops, and to give guidance as
to when it's a good idea.</p>
<p>By the end of this Item, a C-like explicit loop to sum the squares of the first five even items of a vector:</p>
<pre><code class="language-rust ignore">    let mut even_sum_squares = 0;
    let mut even_count = 0;
    for i in 0..values.len() {
        if values[i] % 2 != 0 {
            continue;
        }
        even_sum_squares += values[i] * values[i];
        even_count += 1;
        if even_count == 5 {
            break;
        }
    }</code></pre>
<p>should start to feel more natural expressed as a functional style expression:</p>
<pre><code class="language-rust ignore">    let even_sum_squares: u64 = values
        .iter()
        .filter(|x| *x % 2 == 0)
        .take(5)
        .map(|x| x * x)
        .sum();</code></pre>
<p>Iterator transformation expressions like this can roughly be broken down into three parts:</p>
<ul>
<li>An initial source iterator, from one of Rust's iterator traits.</li>
<li>A sequence of iterator transforms.</li>
<li>A final consumer method to combine the results of the iteration into a final value.</li>
</ul>
<p>The first two of these effectively move functionality out of the loop body and into the <code>for</code> expression; the last
removes the need for the <code>for</code> statement altogether.</p>
<h2 id="iterator-traits"><a class="header" href="#iterator-traits">Iterator Traits</a></h2>
<p>The core <a name="a011"></a><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a> trait has a very simple interface:
a single method <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#tymethod.next"><code>next</code></a> that yields <a name="a012"></a><code>Some</code>
items until it doesn't (<a name="a013"></a><code>None</code>).</p>
<p>Collections that allow iteration over their contents – called <em><a name="a014"></a>iterables</em> – implement the
<a name="a015"></a><a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> trait; the
<a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html#tymethod.into_iter"><code>into_iter</code></a> method of this trait
consumes <a name="a016"></a><code>Self</code> and emits an <code>Iterator</code> in its stead.  The compiler will automatically use this trait for
expressions of the form</p>
<pre><code class="language-rust ignore">    for item in collection {
        // body
    }</code></pre>
<p>effectively converting them to code roughly like:</p>
<pre><code class="language-rust ignore">    let mut iter = collection.into_iter();
    loop {
        let item: Thing = match iter.next() {
            Some(item) =&gt; item,
            None =&gt; break,
        };
        // body
    }</code></pre>
<p>or more succinctly and more idiomatically:</p>
<pre><code class="language-rust ignore">    let mut iter = collection.into_iter();
    while let Some(item) = iter.next() {
        // body
    }</code></pre>
<p>(To keep things running smoothly, there's also an implementation of <code>IntoIterator</code> for any <code>Iterator</code>, which just
returns <code>self</code>; after all, it's easy to convert an <code>Iterator</code> into an <code>Iterator</code>!)</p>
<p>This initial form is a consuming iterator, using up the collection as it's created:</p>
<pre><code class="language-rust ignore">    let collection = vec![Thing(0), Thing(1), Thing(2), Thing(3)];
    for item in collection {
        println!(&quot;Consumed item {:?}&quot;, item);
    }</code></pre>
<p>Any attempt to use the collection after it's been iterated over fails:</p>
<pre><code class="language-rust ignore">    println!(&quot;Collection = {:?}&quot;, collection);</code></pre>
<pre><code class="language-text">error[E0382]: borrow of moved value: `collection`
   --&gt; iterators/src/main.rs:156:35
    |
148 |     let collection = vec![Thing(0), Thing(1), Thing(2), Thing(3)];
    |         ---------- move occurs because `collection` has type `Vec&lt;Thing&gt;`, which does not implement the `Copy` trait
149 |     for item in collection {
    |                 ----------
    |                 |
    |                 `collection` moved due to this implicit call to `.into_iter()`
    |                 help: consider borrowing to avoid moving into the for loop: `&amp;collection`
...
156 |     println!(&quot;Collection = {:?}&quot;, collection);
    |                                   ^^^^^^^^^^ value borrowed here after move
    |
note: this function takes ownership of the receiver `self`, which moves `collection`
</code></pre>
<p>While simple to understand, this all-consuming behaviour is often undesired; some kind of <em>borrow</em> of the iterated items
is needed.</p>
<p>To ensure that behaviour is clear, the examples here use an <code>Item</code> type that is <em>not</em> <code>Copy</code> (<a href="std-traits.html">Item 5</a>), as that would
hide questions of ownership (<a href="borrows.html">Item 15</a>) – the compiler would silently make copies everywhere.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Deliberately not `Copy`
    #[derive(Clone, Debug, Eq, PartialEq)]
    struct Thing(u64);

    let collection = vec![Thing(0), Thing(1), Thing(2), Thing(3)];
<span class="boring">}</span></code></pre></pre>
<p>If the collection being iterated over is prefixed with <code>&amp;</code>:</p>
<pre><code class="language-rust ignore">    for item in &amp;collection {
        println!(&quot;{}&quot;, item.0);
    }
    println!(&quot;collection still around {:?}&quot;, collection);</code></pre>
<p>then the Rust compiler will look for an implementation of
<a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> for the type <code>&amp;Collection</code>. Properly
designed collection types will provide such an implementation; this implementation will still consume <code>Self</code>, but now
<a name="a017"></a><code>Self</code> is <code>&amp;Collection</code> rather than <code>Collection</code>, and the associated <code>Item</code> type will be a reference <code>&amp;Thing</code>.</p>
<p>This leaves the collection intact after iteration, and the equivalent expanded code is:</p>
<pre><code class="language-rust ignore">    let mut iter = (&amp;collection).into_iter();
    while let Some(item) = iter.next() {
        println!(&quot;{}&quot;, item.0);
    }</code></pre>
<p>If it makes sense to provide iteration over mutable references<sup><a name="to-footnote-2"><a href="#footnote-2">2</a></a></sup>, then a similar pattern applies for <code>for item in &amp;mut collection</code>: the compiler
looks for and uses an implementation of <code>IntoIterator</code> for <code>&amp;mut Collection</code>, with each <code>Item</code> being of type <code>&amp;mut Thing</code>.</p>
<p>By convention, standard containers also provide an <code>iter()</code> method that returns an iterator over references to the
underlying item, and equivalent an <code>iter_mut()</code> method if appropriate, with the same behaviour as just described. These
methods can be used in <code>for</code> loops, but have a more obvious benefit when used as the start of an iterator
transformation:</p>
<pre><code class="language-rust ignore">    let result: u64 = (&amp;collection).into_iter().map(|thing| thing.0).sum();</code></pre>
<p>becomes:</p>
<pre><code class="language-rust ignore">    let result: u64 = collection.iter().map(|thing| thing.0).sum();</code></pre>
<h2 id="iterator-transforms"><a class="header" href="#iterator-transforms">Iterator Transforms</a></h2>
<p>The <a name="a020"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> trait has a single required method
(<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next"><code>next</code></a>), but also provides default
implementations (<a href="default-impl.html">Item 13</a>) of a large number of other methods that perform transformations on an iterator.</p>
<p>Some of these tranformations affect the overall iteration process:</p>
<ul>
<li><a name="a021"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take"><code>take(n)</code></a> restricts an iterator to
emitting at most <code>n</code> items.</li>
<li><a name="a022"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.skip"><code>skip(n)</code></a> skips over the first <code>n</code> elements of
the iterator.</li>
<li><a name="a023"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.step_by"><code>step_by(n)</code></a> converts an iterator so it only
emits every n-th item.</li>
<li><a name="a024"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain"><code>chain(other)</code></a> glues together two iterators,
to build a combined iterator that moves through one then the other.</li>
<li><a name="a025"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cycle"><code>cycle()</code></a> converts an iterator that terminates
into one that repeats forever, starting at the beginning again whenever it reaches the end.  (The iterator must
support <code>Clone</code> to allow this.)</li>
<li><a name="a026"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.rev"><code>rev()</code></a> reverses the direction of an
iterator. (The iterator must implement the
<a name="a027"></a><a href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> trait, which has an
additional <a href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html#tymethod.next_back"><code>next_back</code></a>
required method.)</li>
</ul>
<p>Other transformations affect the nature of the <code>Item</code> that's the subject of the <code>Iterator</code>:</p>
<ul>
<li><a name="a028"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map"><code>map(|item| {...})</code></a> is the most general
version, repeatedly applying a closure to transform each item in turn. Several of the following entries in this list
are convenience variants that could be equivalently implemented as a <code>map</code>.</li>
<li><a name="a029"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cloned"><code>cloned()</code></a> produces a clone of all of the
items in the original iterator; this is particularly useful with iterators over <code>&amp;Item</code> references. (This obviously
requires the underlying <code>Item</code> type to implement <code>Clone</code>).</li>
<li><a name="a030"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cloned"><code>copied()</code></a> produces a copy of all of the
items in the original iterator; this is particularly useful with iterators over <code>&amp;Item</code> references. (This obviously
requires the underlying <code>Item</code> type to implement <code>Copy</code>).</li>
<li><a name="a031"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.enumerate"><code>enumerate()</code></a> converts an iterator over
items to be an iterator over <code>(usize, Item)</code> pairs, providing an index to the items in the iterator.</li>
<li><a name="a032"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.zip"><code>zip(it)</code></a> joins an iterator with a second
iterator, to produce a combined iterator that emits pairs of items, one from each of the original iterators, until the
shorter of the two iterators is finished.</li>
</ul>
<p>Yet other transformations perform filtering on the <code>Item</code>s being emitted by the <code>Iterator</code>:</p>
<ul>
<li><a name="a033"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter"><code>filter(|item| {...})</code></a> is the
most general version, applying a <code>bool</code>-returning closure to each item reference to determine whether it should be
passed through.</li>
<li><a name="a034"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take_while"><code>take_while()</code></a> and
<a name="a035"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.skip_while"><code>skip_while()</code></a> are
mirror images of each other, emitting either an initial subrange or a final subrange of the iterator, based on a
predicate.</li>
</ul>
<p>The <a name="a036"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flatten"><code>flatten()</code></a> method deals
with an iterator whose items are themselves iterators, flattening the result.  On its own, this doesn't seem that
helpful, but it becomes much more useful when combined with the observation that both
<a name="a037"></a><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.iter"><code>Option</code></a> and
<a name="a038"></a><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.iter"><code>Result</code></a> act as iterators: they produce either zero
(for <code>None</code>, <code>Err(e)</code>) or one (for <code>Some(v)</code>, <code>Ok(v)</code>) items.  This means that <code>flatten</code>ing a stream of <code>Option</code> /
<code>Result</code> values is a simple way to extract just the valid values, ignoring the rest.</p>
<p>Taken as a whole, these methods allow iterators to be transformed so that they produce exactly the sequence of elements
that are needed for most situations.</p>
<h2 id="iterator-consumers"><a class="header" href="#iterator-consumers">Iterator Consumers</a></h2>
<p>The previous two sections described how to obtain an iterator, and how to transmute it into exactly the right form for
precise iteration.  This precisely-targetted iteration could happen as an explicit for-each loop:</p>
<pre><code class="language-rust ignore">    let mut even_sum_squares = 0;
    for value in values.iter().filter(|x| *x % 2 == 0).take(5) {
        even_sum_squares += value * value;
    }</code></pre>
<p>However, the large collection of <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code> methods</a> includes
many that allow an iteration to be consumed in a single method call, removing the need for an explicit <code>for</code> loop.</p>
<p>The most general of these methods is <a name="a039"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.for_each"><code>for_each(|item| {...})</code></a>, which runs a closure for each item
produced by the <code>Iterator</code>. This can do <em>most</em> of the things that an explicit <code>for</code> loop could do (the exceptions are
described below), but its generality also makes it a little awkward to use – the closure needs to use mutable
references to external state in order to emit anything:</p>
<pre><code class="language-rust ignore">    let mut even_sum_squares = 0;
    values
        .iter()
        .filter(|x| *x % 2 == 0)
        .take(5)
        .for_each(|value| {
            // closure needs a mutable reference to state elsewhere
            even_sum_squares += value * value;
        });</code></pre>
<p>However, if the body of the <a name="a040"></a><code>for</code> loop matches one of a number of common patterns, there are more specific
iterator-consuming methods that are clearer, shorter and more idiomatic.</p>
<p>These patterns include shortcuts for building a single value out of the collection:</p>
<ul>
<li><a name="a041"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.sum"><code>sum()</code></a>, for summing a collection of
numeric values (integers or floats).</li>
<li><a name="a042"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.product"><code>product()</code></a>, for multiplying
together a collection of numeric values.</li>
<li><a name="a043"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.min"><code>min()</code></a> and
<a name="a044"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.max"><code>max()</code></a>, for finding the extreme
values of a collection, relative to the <code>Item</code>'s <a name="a045"></a><code>Ord</code> implementation (see <a href="std-traits.html">Item 5</a>).</li>
<li><a name="a046"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.min_by"><code>min_by(f)</code></a> and
<a name="a047"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.max_by"><code>max_by(f)</code></a>, for finding the
extreme values of a collection, relative to a user-specified comparison function <code>f</code>.</li>
<li><a name="a048"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.reduce"><code>reduce(f)</code></a> is a more general
operation that encompasses the previous methods, building an accumulated value of the <code>Item</code> type by running a closure
at each step that takes the value accumulated so far and the current item.</li>
<li><a name="a049"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.fold"><code>fold(f)</code></a> is a generalization of
<code>reduce</code>, allowing the &quot;accumulated value&quot; to be of an arbitrary type (not just the <code>Iterator::Item</code> type).</li>
<li><a name="a050"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.scan"><code>scan(f)</code></a> generalizes in a slightly
different way, giving the closure a mutable reference to some internal state at each step.</li>
</ul>
<p>There are also methods for <em>selecting</em> a single value out of the collection:</p>
<ul>
<li><a name="a051"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find"><code>find(p)</code></a> finds the first item that
satisfies a predicate.</li>
<li><a name="a052"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.position"><code>position(p)</code></a> also finds
the first item satisfying a predicate, but this time it returns the index of the item.</li>
<li><a name="a053"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.nth"><code>nth(n)</code></a> returns the <code>n</code>-th element
of the iterator, if available.</li>
</ul>
<p>There are methods for testing against every item in the collection:</p>
<ul>
<li><a name="a054"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any"><code>any(p)</code></a> indicates whether a
predicate is <code>true</code> for <em>any</em> item in the collection.</li>
<li><a name="a055"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any"><code>all(p)</code></a> indicates whether a
predicate is <code>true</code> for <em>all</em> items in the collection.</li>
</ul>
<p>(In either case, iteration will terminate early if the relevant counter-example is found.)</p>
<p>There are methods that allow for the possibility of failure in the closures used with each item; in each case, if a
closure returns a failure for an item, the iteration is terminated and the operation as a whole returns the first
failure.</p>
<ul>
<li><a name="a056"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_for_each"><code>try_for_each(f)</code></a>
is like <code>for_each</code>, but the closure can fail.</li>
<li><a name="a057"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_for_each"><code>try_fold(f)</code></a> is like
<code>fold</code>, but the closure can fail.</li>
<li><a name="a058"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_find"><code>try_find(f)</code></a> is like
<code>find</code>, but the closure can fail.</li>
</ul>
<p>Finally, there are methods that accumulate all of the iterated items into a new collection.  The most important of these
is <a name="a059"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect"><code>collect()</code></a>, which can be
used to build a new instance of any collection type that implements the
<a href="https://doc.rust-lang.org/core/iter/trait.FromIterator.html"><code>FromIterator</code></a> trait.</p>
<p>The <code>FromIterator</code> trait is implemented for all of the standard library collection types
(<a name="a060"></a><a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html#impl-FromIterator%3CT%3E"><code>Vec</code></a>,
<a name="a061"></a><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#impl-FromIterator%3C(K%2C%20V)%3E"><code>HashMap</code></a>,
<a name="a062"></a><a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html#impl-FromIterator%3CT%3E"><code>BTreeSet</code></a> etc.) but
this ubiquity also means that you often have to use explicit types, because otherwise the
compiler can't figure out whether you're trying to assemble (say) a <code>Vec&lt;i32&gt;</code> or <code>HashSet&lt;i32&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::collections::HashSet;

    // Build collections of even numbers.  Type must be specified, because
    // the expression is the same for either type.
    let myvec: Vec&lt;i32&gt; = (0..10).into_iter().filter(|x| x % 2 == 0).collect();
    let h: HashSet&lt;i32&gt; = (0..10).into_iter().filter(|x| x % 2 == 0).collect();
<span class="boring">}</span></code></pre></pre>
<p>(As an aside, this example also illustrates the use of <a name="a063"></a><a href="https://doc.rust-lang.org/reference/expressions/range-expr.html">range
expressions</a> to generate the initial data to be
iterated over.)</p>
<p>Other (more obscure) collection-producing methods include:</p>
<ul>
<li><a name="a064"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.unzip"><code>unzip()</code></a>, which divides an
iterator of pairs into two collections.</li>
<li><a name="a065"></a><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.partition"><code>partition(p)</code></a>, which
splits an iterator into two collections based on a predicate that is applied to each item.</li>
</ul>
<p>This Item has touched on a wide selection of <code>Iterator</code> methods, but this is only a subset of the methods available;
for more information, consult the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">iterator documentation</a> or
read Chapter 15 of <a name="a066"></a><em>Programming Rust</em> (2nd edition), which has extensive coverage of the possibilities.</p>
<p>This rich collection of iterator transformations is meant to be used – to produce code that is more idiomatic,
more compact, and with clearer intent.</p>
<h2 id="building-collections-from-result-values"><a class="header" href="#building-collections-from-result-values">Building Collections From <code>Result</code> Values</a></h2>
<p>The previous section described the use of <code>collect()</code> to build collections from iterators, but <code>collect()</code> also has  a
particularly helpful feature when dealing with <a name="a067"></a><code>Result</code> values.</p>
<p>Consider an attempt to convert a vector of <code>i64</code> values into bytes (<code>u8</code>), with the optimistic expectation that they
will all fit:</p>
<pre><code class="language-rust ignore panics">    use std::convert::TryFrom;
    let inputs: Vec&lt;i64&gt; = vec![0, 1, 2, 3, 4];
    let result: Vec&lt;u8&gt; = inputs
        .into_iter()
        .map(|v| &lt;u8&gt;::try_from(v).unwrap())
        .collect();</code></pre>
<p>This works until some unexpected input comes along:</p>
<pre><code class="language-rust ignore">    let inputs: Vec&lt;i64&gt; = vec![0, 1, 2, 3, 4, 512];</code></pre>
<p>and causes a run-time failure:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: TryFromIntError(())', iterators/src/main.rs:249:36
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Following the advice of <a href="transform.html">Item 3</a>, we want to keep the <code>Result</code> type in play, and use the <strong><code>?</code></strong> operator to make any
failure the problem of the calling code.  The obvious modification to emit the <code>Result</code> doesn't really help:</p>
<pre><code class="language-rust ignore">    let result: Vec&lt;Result&lt;u8, _&gt;&gt; =
        inputs.into_iter().map(|v| &lt;u8&gt;::try_from(v)).collect();
    // Now what?  Still need to iterate to extract results and detect errors.</code></pre>
<p>However, there's an alternative version of <code>collect()</code>, which can assemble a <code>Result</code> holding a <code>Vec</code>, instead of a
<code>Vec</code> holding <code>Result</code>s.</p>
<p>Forcing use of this version requires the turbofish (<code>::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;</code>):</p>
<pre><code class="language-rust ignore">    let result: Vec&lt;u8&gt; = inputs
        .into_iter()
        .map(|v| &lt;u8&gt;::try_from(v))
        .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?;</code></pre>
<p>Combining this with the question mark operator gives useful behaviour:</p>
<ul>
<li>If the iteration encounters an error value, that error value is emitted to the caller and iteration stops.</li>
<li>If no errors are encountered, the remainder of the code can deal with a sensible collection of values of the right type.</li>
</ul>
<h2 id="loop-transformation"><a class="header" href="#loop-transformation">Loop Transformation</a></h2>
<p>The aim of this Item is to convince you that many explicit loops can be regarded as something to be converted to
iterator transformations.  This can feel somewhat unnatural for programmers who aren't used to it, so let's walk through
a transformation step by step.</p>
<p>Starting with a very C-like explicit loop to sum the squares of the first five even items of a vector:</p>
<pre><code class="language-rust ignore">    let mut even_sum_squares = 0;
    let mut even_count = 0;
    for i in 0..values.len() {
        if values[i] % 2 != 0 {
            continue;
        }
        even_sum_squares += values[i] * values[i];
        even_count += 1;
        if even_count == 5 {
            break;
        }
    }</code></pre>
<p>The first step is to replace vector indexing with direct use of an iterator in a for-each loop:</p>
<pre><code class="language-rust ignore">    let mut even_sum_squares = 0;
    let mut even_count = 0;
    for value in values.iter() {
        if value % 2 != 0 {
            continue;
        }
        even_sum_squares += value * value;
        even_count += 1;
        if even_count == 5 {
            break;
        }
    }</code></pre>
<p>An initial arm of the loop that uses <code>continue</code> to skip over some items is naturally expressed as a <code>filter()</code>:</p>
<pre><code class="language-rust ignore">    let mut even_sum_squares = 0;
    let mut even_count = 0;
    for value in values.iter().filter(|x| *x % 2 == 0) {
        even_sum_squares += value * value;
        even_count += 1;
        if even_count == 5 {
            break;
        }
    }</code></pre>
<p>Next, the early exit from the loop once 5 even items have been spotted maps to a <code>take(5)</code>:</p>
<pre><code class="language-rust ignore">    let mut even_sum_squares = 0;
    for value in values.iter().filter(|x| *x % 2 == 0).take(5) {
        even_sum_squares += value * value;
    }</code></pre>
<p>The value of the item is never used directly, only in the <code>value * value</code> combination, which makes it an ideal target
for a <code>map()</code>:</p>
<pre><code class="language-rust ignore">    let mut even_sum_squares = 0;
    for val_sqr in values.iter().filter(|x| *x % 2 == 0).take(5).map(|x| x * x)
    {
        even_sum_squares += val_sqr;
    }</code></pre>
<p>These refactorings of the original loop have resulting in a loop body that's the perfect nail to fit under the hammer of
the <code>sum()</code> method:</p>
<pre><code class="language-rust ignore">    let even_sum_squares: u64 = values
        .iter()
        .filter(|x| *x % 2 == 0)
        .take(5)
        .map(|x| x * x)
        .sum();</code></pre>
<h2 id="when-explicit-is-better"><a class="header" href="#when-explicit-is-better">When Explicit is Better</a></h2>
<p>This Item has highlighted the advantages of iterator transformations, particularly with respect to concision and
clarity.  So when are iterator transformations <em>not</em> appropriate or idiomatic?</p>
<ul>
<li>If the loop body is large and/or multi-functional, it makes sense to keep it as an explicit body rather than squeezing
it into a closure.</li>
<li>If the loop body involves error conditions that result in early termination of the surrounding function, these are
often best kept explicit – the <code>try_..()</code> methods only help a little.  However, <code>collect()</code>'s ability to convert
a collection of <code>Result</code> values into a <code>Result</code> holding a collection of values often allows error conditions to still
be handled with the <strong><code>?</code></strong> operator.</li>
<li>If performance is vital, an iterator transform that involves a closure <em>should</em> get optimized so that it is <a href="https://doc.rust-lang.org/book/ch13-04-performance.html">just
as fast</a> as the equivalent explicit code.  But if performance
of a core loop is that important, <em>measure</em> different variants and tune appropriately.
<ul>
<li>Be careful to ensure that your measurements reflect real-world performance – the compiler's optimizer can
give over-optimistic results on test data (as described in <a href="testing.html">Item 30</a>).</li>
<li>The <a name="a068"></a><a href="https://godbolt.org/">Godbolt compiler explorer</a> is an amazing tool for exploring what the compiler
spits out.</li>
</ul>
</li>
</ul>
<p>Most importantly, don't convert a loop into an iteration transformation if the conversion is forced or awkward.  This is
a matter of <a name="a069"></a>taste to be sure – but be aware that your taste is likely to change as you become more familiar
with the <a name="a070"></a>functional style.</p>
<p><hr/>
<p><a name="footnote-1"><a href="#to-footnote-1">1</a></a>: In fact, the
iterator can be more general – the idea of emitting next items until done need not be associated with a
container.</p>
<p><a name="footnote-2"><a href="#to-footnote-2">2</a></a>: This method can't be provided if a mutation to
the item might invalidate the container's internal guarantees. For example, changing the item's contents in a way that
alters its <a name="a018"></a><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a> value would invalidate the internal
data structures of a <a name="a019"></a><code>HashMap</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="references.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="raii.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="references.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="raii.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/third_party/ferris/ferris.js"></script>


    </div>
    </body>
</html>
