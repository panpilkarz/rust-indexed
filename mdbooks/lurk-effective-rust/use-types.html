<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Item 1: Use the type system to express your data structures - Effective Rust</title>


        <!-- Custom HTML head -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-23228806-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
        <meta name="description" content="A collection of specific ways to improve your use of Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/third_party/ferris/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cover.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="use-types.html" class="active"><strong aria-hidden="true">3.1.</strong> Item 1: Use the type system to express your data structures</a></li><li class="chapter-item expanded "><a href="use-types-2.html"><strong aria-hidden="true">3.2.</strong> Item 2: Use the type system to express common behaviour</a></li><li class="chapter-item expanded "><a href="transform.html"><strong aria-hidden="true">3.3.</strong> Item 3: Avoid matching Option and Result</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">3.4.</strong> Item 4: Prefer idiomatic Error variants</a></li><li class="chapter-item expanded "><a href="std-traits.html"><strong aria-hidden="true">3.5.</strong> Item 5: Familiarize yourself with standard traits</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">3.6.</strong> Item 6: Understand type conversions</a></li><li class="chapter-item expanded "><a href="newtype.html"><strong aria-hidden="true">3.7.</strong> Item 7: Embrace the newtype pattern</a></li><li class="chapter-item expanded "><a href="builders.html"><strong aria-hidden="true">3.8.</strong> Item 8: Use builders for complex types</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.9.</strong> Item 9: Familiarize yourself with reference and pointer types</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">3.10.</strong> Item 10: Consider using iterator transforms instead of explicit loops</a></li><li class="chapter-item expanded "><a href="raii.html"><strong aria-hidden="true">3.11.</strong> Item 11: Implement the Drop trait for RAII patterns</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">3.12.</strong> Item 12: Prefer generics to trait objects</a></li><li class="chapter-item expanded "><a href="default-impl.html"><strong aria-hidden="true">3.13.</strong> Item 13: Use default implementations to minimize required trait methods</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">4.1.</strong> Item 14: Understand lifetimes</a></li><li class="chapter-item expanded "><a href="borrows.html"><strong aria-hidden="true">4.2.</strong> Item 15: Understand the borrow checker</a></li><li class="chapter-item expanded "><a href="unsafe.html"><strong aria-hidden="true">4.3.</strong> Item 16: Avoid writing unsafe code</a></li><li class="chapter-item expanded "><a href="deadlock.html"><strong aria-hidden="true">4.4.</strong> Item 17: Be wary of shared-state parallelism</a></li><li class="chapter-item expanded "><a href="panic.html"><strong aria-hidden="true">4.5.</strong> Item 18: Don't panic</a></li><li class="chapter-item expanded "><a href="reflection.html"><strong aria-hidden="true">4.6.</strong> Item 19: Avoid reflection</a></li><li class="chapter-item expanded "><a href="optimize.html"><strong aria-hidden="true">4.7.</strong> Item 20: Avoid the temptation to over-optimize</a></li></ol></li><li class="chapter-item expanded "><a href="deps.html"><strong aria-hidden="true">5.</strong> Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="semver.html"><strong aria-hidden="true">5.1.</strong> Item 21: Understand what semantic versioning promises</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.2.</strong> Item 22: Minimize visibility</a></li><li class="chapter-item expanded "><a href="wildcard.html"><strong aria-hidden="true">5.3.</strong> Item 23: Avoid wildcard imports</a></li><li class="chapter-item expanded "><a href="re-export.html"><strong aria-hidden="true">5.4.</strong> Item 24: Re-export dependencies whose types appear in your API</a></li><li class="chapter-item expanded "><a href="dep-graph.html"><strong aria-hidden="true">5.5.</strong> Item 25: Manage your dependency graph</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">5.6.</strong> Item 26: Be wary of feature creep</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">6.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">6.1.</strong> Item 27: Document public interfaces</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">6.2.</strong> Item 28: Use macros judiciously</a></li><li class="chapter-item expanded "><a href="clippy.html"><strong aria-hidden="true">6.3.</strong> Item 29: Listen to Clippy</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.4.</strong> Item 30: Write more than unit tests</a></li><li class="chapter-item expanded "><a href="use-tools.html"><strong aria-hidden="true">6.5.</strong> Item 31: Take advantage of the tooling ecosystem</a></li><li class="chapter-item expanded "><a href="ci.html"><strong aria-hidden="true">6.6.</strong> Item 32: Set up a continuous integration (CI) system</a></li></ol></li><li class="chapter-item expanded "><a href="beyond-std.html"><strong aria-hidden="true">7.</strong> Beyond Standard Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="no-std.html"><strong aria-hidden="true">7.1.</strong> Item 33: Consider making library code no_std compatible</a></li><li class="chapter-item expanded "><a href="ffi.html"><strong aria-hidden="true">7.2.</strong> Item 34: Control what crosses FFI boundaries</a></li><li class="chapter-item expanded "><a href="bindgen.html"><strong aria-hidden="true">7.3.</strong> Item 35: Prefer bindgen to manual FFI mappings</a></li></ol></li><li class="chapter-item expanded "><a href="indexing.html"><strong aria-hidden="true">8.</strong> Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="item-1-use-the-type-system-to-express-your-data-structures"><a class="header" href="#item-1-use-the-type-system-to-express-your-data-structures">Item 1: Use the type system to express your data structures</a></h1>
<blockquote>
<p>&quot;who called them programers and not type writers&quot; –
<a name="a001"></a><a href="https://twitter.com/thingskatedid/status/1400213496785108997">@thingskatedid</a></p>
</blockquote>
<p>The basics of Rust's <a name="a002"></a>type system are pretty familiar to anyone coming
from another statically typed programming language (such as <a name="a003"></a>C++, <a name="a004"></a>Go or <a name="a005"></a>Java).
There's a collection of integer types with specific sizes, both signed
(<a name="a006"></a><a href="https://doc.rust-lang.org/std/primitive.i8.html"><code>i8</code></a>,
<a name="a007"></a><a href="https://doc.rust-lang.org/std/primitive.i16.html"><code>i16</code></a>,
<a name="a008"></a><a href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>,
<a name="a009"></a><a href="https://doc.rust-lang.org/std/primitive.i64.html"><code>i64</code></a>,
<a name="a010"></a><a href="https://doc.rust-lang.org/std/primitive.i128.html"><code>i128</code></a>)
and unsigned
(<a name="a011"></a><a href="https://doc.rust-lang.org/std/primitive.u8.html"><code>u8</code></a>,
<a name="a012"></a><a href="https://doc.rust-lang.org/std/primitive.u16.html"><code>u16</code></a>,
<a name="a013"></a><a href="https://doc.rust-lang.org/std/primitive.u32.html"><code>u32</code></a>,
<a name="a014"></a><a href="https://doc.rust-lang.org/std/primitive.u64.html"><code>u64</code></a>,
<a name="a015"></a><a href="https://doc.rust-lang.org/std/primitive.u128.html"><code>u128</code></a>).</p>
<p>There's also signed (<a name="a016"></a><a href="https://doc.rust-lang.org/std/primitive.isize.html"><code>isize</code></a>) and unsigned
(<a name="a017"></a><a href="https://doc.rust-lang.org/std/primitive.usize.html"><code>usize</code></a>) integers whose size matches the pointer size on
the target system.  Rust isn't a language where you're going to be doing much in the way of converting between pointers
and integers, so that characterization isn't really relevant. However, standard collections return their size as a
<code>usize</code> (from <code>.len()</code>), so collection indexing means that <code>usize</code> values are quite common – which is obviously
fine from a capacity perspective, as there can't be more items in an in-memory collection than there are memory
addresses on the system.</p>
<p>The integral types do give us the first hint that Rust is a stricter world than C++ – attempting to
<a name="a018"></a> put a quart (<code>i32</code>) into a pint pot (<code>i16</code>) generates a compile-time error.</p>
<pre><code class="language-rust ignore does_not_compile">        let x: i32 = 42;
        let y: i16 = x;</code></pre>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:14:22
   |
14 |         let y: i16 = x;
   |                ---   ^ expected `i16`, found `i32`
   |                |
   |                expected due to this
   |
help: you can convert an `i32` to an `i16` and panic if the converted value doesn't fit
   |
14 |         let y: i16 = x.try_into().unwrap();
   |                       ++++++++++++++++++++
</code></pre>
<p>This is reassuring: Rust is not going to sit there quietly while the programmer does things that are risky.  It also
gives an early indication that while Rust has stronger rules, it also has helpful compiler messages that point the way
to how to comply with the rules.  The suggested solution raises the question of how to handle situations where the
conversion would alter the value, and we'll have more to say on both <a name="a019"></a>error handling (<a href="errors.html">Item 4</a>) and using
<a name="a020"></a><code>panic!</code> (<a href="panic.html">Item 18</a>) later.</p>
<p>Rust also doesn't allow some things that might appear &quot;safe&quot;:</p>
<pre><code class="language-rust ignore does_not_compile">        let x = 42i32; // Integer literal with type suffix
        let y: i64 = x;</code></pre>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:23:22
   |
23 |         let y: i64 = x;
   |                ---   ^ expected `i64`, found `i32`
   |                |
   |                expected due to this
   |
help: you can convert an `i32` to an `i64`
   |
23 |         let y: i64 = x.into();
   |                       +++++++
</code></pre>
<p>Here, the suggested solution doesn't raise the spectre of error handling, but the conversion does still need to be
explicit. We'll discuss type conversions in more detail later (<a href="casts.html">Item 6</a>).</p>
<p>Continuing with the unsurprising primitive types, Rust has a
<a name="a021"></a><a href="https://doc.rust-lang.org/std/primitive.bool.html"><code>bool</code></a> type, <a name="a022"></a>floating point types
(<a name="a023"></a><a href="https://doc.rust-lang.org/std/primitive.f32.html"><code>f32</code></a>,
<a name="a024"></a><a href="https://doc.rust-lang.org/std/primitive.f64.html"><code>f64</code></a>)
and a <a name="a025"></a><a href="https://en.wikipedia.org/wiki/Unit_type">unit type</a> <a name="a026"></a><a href="https://doc.rust-lang.org/std/primitive.unit.html"><code>()</code></a>
(like C's <a name="a027"></a><code>void</code>).</p>
<p>More interesting is the <a name="a028"></a><a href="https://doc.rust-lang.org/std/primitive.char.html"><code>char</code></a> character type, which holds a
<a name="a029"></a><a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode value</a> (similar to Go's <a href="https://golang.org/doc/go1#rune"><code>rune</code>
type</a>). Although this is stored as 4 bytes internally, there are again no silent
conversions to or from a 32-bit integer.</p>
<p>This precision in the type system forces you to be explicit about what you're trying to express – a <code>u32</code> value is
different than a <code>char</code>, which in turn is different than a sequence of <a name="a030"></a>UTF-8 bytes, which in turn is different
than a sequence of arbitrary bytes, and it's up to you to specify exactly which you mean<sup><a name="to-footnote-1"><a href="#footnote-1">1</a></a></sup>.  Joel Spolsky's <a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">famous blog
post</a> can help you understand which you need.</p>
<p>Of course, there are helper methods that allow you to convert between these different types, but their signatures force
you to handle (or explicitly ignore) the possibility of failure.  For example, a <a name="a031"></a>Unicode code point<sup><a name="to-footnote-2"><a href="#footnote-2">2</a></a></sup> can always be represented in 32 bits, so <code>'a' as u32</code>
is allowed, but the other direction is trickier (as there are <code>u32</code> values that are not valid Unicode code points):</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.char.html#method.from_u32"><code>char::from_u32</code></a> returns an <code>Option&lt;char&gt;</code>
forcing the caller to handle the failure case</li>
<li><a href="https://doc.rust-lang.org/std/primitive.char.html#method.from_u32_unchecked"><code>char::from_u32_unchecked</code></a> makes the
assumption of validity, but is marked <code>unsafe</code> as a result, forcing the caller to use <code>unsafe</code> too (<a href="unsafe.html">Item 16</a>).</li>
</ul>
<h2 id="aggregate-types"><a class="header" href="#aggregate-types">Aggregate Types</a></h2>
<p>Moving on to aggregate types, Rust has:</p>
<ul>
<li><a name="a032"></a><a href="https://doc.rust-lang.org/std/primitive.array.html">Arrays</a>, which hold multiple instances of a single
type, where the number of instances is known at compile time.  For example <code>[u32; 4]</code> is four 4-byte integers in a
row.</li>
<li><a name="a033"></a><a href="https://doc.rust-lang.org/std/primitive.tuple.html">Tuples</a>, which hold instances of multiple
heterogeneous types, where the number of elements and their types are known at compile time, for example
<code>(WidgetOffset, WidgetSize, WidgetColour)</code>.  If the types in the tuple aren't distinctive – for example <code>(i32, i32, &amp;'static str, bool)</code> – it's better to give each element a name and use…</li>
<li><a name="a034"></a><a href="https://doc.rust-lang.org/std/keyword.struct.html">Structs</a>, which also hold instances of heterogeneous
types known at compile time, but which allows both the overall type and the individual fields to be referred to by
name.</li>
</ul>
<p>The <em><a name="a035"></a>tuple struct</em> is a cross-breed of a <code>struct</code> with a tuple: there's a name for the overall type, but no names
for the individual fields – they are referred to by number instead: <code>s.0</code>, <code>s.1</code>, etc.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct TextMatch(usize, String);
    let m = TextMatch(12, &quot;needle&quot;.to_owned());
    assert_eq!(m.0, 12);
<span class="boring">}</span></code></pre></pre>
<p>This brings us to the jewel in the crown of Rust's type system, the <a name="a036"></a><code>enum</code>.</p>
<p>In its basic form, it's hard to see what there is to get excited about.  As with other languages, the <code>enum</code> allows you
to specify a set of mutually exclusive values, possibly with a numeric or string value attached.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    enum HttpResultCode {
        Ok = 200,
        NotFound = 404,
        Teapot = 418,
    }
    let code = HttpResultCode::NotFound;
    assert_eq!(code as i32, 404);
<span class="boring">}</span></code></pre></pre>
<p>Because each <code>enum</code> definition creates a distinct type, this can be used to improve readability and maintainability of
functions that take <a name="a037"></a><code>bool</code> arguments. Instead of:</p>
<pre><code class="language-rust ignore">        print_page(/* both_sides= */ true, /* colour= */ false);</code></pre>
<p>a version that uses a pair of <code>enum</code>s:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub enum Sides {
        Both,
        Single,
    }

    pub enum Output {
        BlackAndWhite,
        Colour,
    }

    pub fn print_page(sides: Sides, colour: Output) {
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>is more type-safe and easier to read at the point of invocation:</p>
<pre><code class="language-rust ignore">        print_page(Sides::Both, Output::BlackAndWhite);</code></pre>
<p>Unlike the <code>bool</code> version, if a library user were to accidentally flip the order of the arguments, the compiler would
immediately complain:</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:89:20
   |
89 |         print_page(Output::BlackAndWhite, Sides::Single);
   |                    ^^^^^^^^^^^^^^^^^^^^^ expected enum `enums::Sides`, found enum `enums::Output`
error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:89:43
   |
89 |         print_page(Output::BlackAndWhite, Sides::Single);
   |                                           ^^^^^^^^^^^^^ expected enum `enums::Output`, found enum `enums::Sides`
</code></pre>
<p>(Using the <a name="a038"></a>newtype pattern (<a href="newtype.html">Item 7</a>) to wrap a <code>bool</code> also achieves type safety and maintainability; it's
generally best to use that if the semantics will always be Boolean, and to use an <code>enum</code> if there's a chance that a new
alternative (e.g. <code>Sides::BothAlternateOrientation</code>) could arise in the future.)</p>
<p>The type safety of Rust's <code>enum</code>s continues with the <a name="a039"></a><code>match</code> expression:</p>
<pre><code class="language-rust ignore does_not_compile">        let msg = match code {
            HttpResultCode::Ok =&gt; &quot;Ok&quot;,
            HttpResultCode::NotFound =&gt; &quot;Not found&quot;,
            // forgot to deal with the all-important &quot;I'm a teapot&quot; code
        };</code></pre>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `Teapot` not covered
  --&gt; use-types/src/main.rs:65:25
   |
51 | /     enum HttpResultCode {
52 | |         Ok = 200,
53 | |         NotFound = 404,
54 | |         Teapot = 418,
   | |         ------ not covered
55 | |     }
   | |_____- `HttpResultCode` defined here
...
65 |           let msg = match code {
   |                           ^^^^ pattern `Teapot` not covered
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `HttpResultCode`
</code></pre>
<p>The compiler forces the programmer to consider <em>all</em> of the possibilities<sup><a name="to-footnote-3"><a href="#footnote-3">3</a></a></sup>  that are represented by the <code>enum</code>, even if the result is just to add a default arm <code>_ =&gt; {}</code>.
(Note that modern C++ compilers can and do warn about missing <code>switch</code> arms for <code>enum</code>s as well.)</p>
<h2 id="enums-with-fields"><a class="header" href="#enums-with-fields"><code>enum</code>s With Fields</a></h2>
<p>The true power of Rust's <code>enum</code> feature comes from the fact that each variant can have data that
comes along with it, making it into an <a name="a041"></a><a href="https://en.wikipedia.org/wiki/Algebraic_data_type"><em>algebraic data
type</em></a> (ADT).  This is less familiar to
programmers of mainstream languages; in C/C++ terms it's like a combination of an <code>enum</code> with a
<code>union</code> – only type-safe.</p>
<p>This means that the invariants of the program's data structures can be encoded into Rust's type system; states that
don't comply with those invariants won't even compile.  A well-designed <code>enum</code> makes the creator's intent clear to
humans as well as to the compiler:</p>
<pre><code class="language-rust ignore">pub enum SchedulerState {
    Inert,
    Pending(HashSet&lt;Job&gt;),
    Running(HashMap&lt;CpuId, Vec&lt;Job&gt;&gt;),
}</code></pre>
<p>Just from the type definition, it's reasonable to guess that <code>Job</code>s get queued up in the <code>Pending</code> state until the
scheduler is fully active, at which point they're assigned to some per-CPU pool.</p>
<p>This highlights the central theme of this Item, which is to use Rust's type system to express the concepts that are
associated with the design of your software.</p>
<p>A dead giveaway for when this is <em>not</em> happening is a comment that explains when some field or parameter is valid:</p>
<pre><code class="language-rust ignore">struct DisplayProps {
    x: u32,
    y: u32,
    monochrome: bool,
    // `fg_colour` must be (0, 0, 0) if `monochrome` is true.
    fg_colour: RgbColour,
}</code></pre>
<p>This is a prime candidate for replacement with an <code>enum</code> holding data:</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
enum Colour {
    Monochrome,
    Foreground(RgbColour),
}

struct DisplayProperties {
    x: u32,
    y: u32,
    colour: Colour,
}</code></pre>
<p>This small example illustrates a key piece of advice: <strong>make invalid states inexpressible in your types</strong>.  Types that
only support valid combinations of values mean that whole classes of error are rejected by the compiler, leading to
smaller and safer code.</p>
<h2 id="options-and-errors"><a class="header" href="#options-and-errors">Options and Errors</a></h2>
<p>Returning to the power of the <a name="a042"></a><code>enum</code>, there are two concepts that are so common that Rust includes built-in <code>enum</code>
types to express them.</p>
<p>The first is the concept of an <a name="a043"></a><a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>: either there's a
value of a particular type (<a name="a044"></a><code>Some(T)</code>), or there isn't (<a name="a045"></a><code>None</code>). <strong>Always use <code>Option</code> for values
that can be absent</strong>; never fall back to using <a name="a046"></a>sentinel values (-1, <code>nullptr</code>, …) to try to express the
same concept in-band.</p>
<p>There is one subtle point to consider though.  If you're dealing with a <em>collection</em> of things, you need to decide
whether having zero things in the collection is the same as not having a collection. For most situations, the
distinction doesn't arise and you can go ahead and use <code>Vec&lt;Thing&gt;</code>: a count of zero things implies an absence of
things.</p>
<p>However, there are definitely other rare scenarios where the two cases need to be distinguished with
<code>Option&lt;Vec&lt;Thing&gt;&gt;</code> – for example, a cryptographic system might need to distinguish between <a href="https://tools.ietf.org/html/rfc8152#section-4.1">&quot;payload transported
separately&quot;</a> and &quot;empty payload provided&quot;.  (This is related to the
debates around the <a name="a047"></a><a href="https://en.wikipedia.org/wiki/Null_(SQL)"><code>NULL</code> marker</a> columns in <a name="a048"></a>SQL.)</p>
<p>One common edge case that's in the middle is a <code>String</code> which might be absent – does <code>&quot;&quot;</code> or <code>None</code> make more
sense to indicate the absence of a value?  Either way works, but <code>Option&lt;String&gt;</code> clearly communicates the possibility
that this value may be absent.</p>
<p>The second common concept arises from error processing: if a function fails, how should that failure be reported?
Historically, special <a name="a049"></a>sentinel values (e.g. <code>-errno</code> return values from Linux system calls) or <a name="a050"></a>global
variables (<code>errno</code> for POSIX systems) were used. More recently, languages that support multiple or tuple return values
(such as <a name="a051"></a>Go) from functions may have a convention of returning a <code>(result, error)</code> pair, assuming the existence of
some suitable &quot;zero&quot; value for the <code>result</code> when the <code>error</code> is non-&quot;zero&quot;.</p>
<p>In Rust, <strong>always encode the result of an operation that might fail as a <a name="a052"></a><a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;T, E&gt;</code></a></strong>.  The <code>T</code> type holds the successful result (in the
<a name="a053"></a><code>Ok</code> variant), and the <code>E</code> type holds error details (in the <a name="a054"></a><code>Err</code> variant) on failure.  Using the standard
type makes the intent of the design clear, and allows the use of standard transformations (<a href="transform.html">Item 3</a>) and error
processing (<a href="errors.html">Item 4</a>); it also makes it possible to streamline error processing with the <code>?</code> operator.</p>
<p><hr/>
<p><a name="footnote-1"><a href="#to-footnote-1">1</a></a>: The situation gets
muddier still if the filesystem is involved, since filenames on popular platforms are somewhere in between arbitrary
bytes and UTF-8 sequences: see the <a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>std::ffi::OsString</code></a>
documentation.</p>
<p><a name="footnote-2"><a href="#to-footnote-2">2</a></a>: Technically, a <em>Unicode scalar value</em> rather than a code point</p>
<p><a name="footnote-3"><a href="#to-footnote-3">3</a></a>: This also means that adding a new
variant to an existing <code>enum</code> in a library is a <em>breaking change</em> (<a href="semver.html">Item 21</a>): clients of the library will need to change
their code to cope with the new variant.  If an <code>enum</code> is really just an old-style list of values, this behaviour can be
avoided by marking it as a
<a name="a040"></a><a href="https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a>
<code>enum</code>; see <a href="semver.html">Item 21</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="use-types-2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="use-types-2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/third_party/ferris/ferris.js"></script>


    </div>
    </body>
</html>
