<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Item 3: Avoid matching Option and Result - Effective Rust</title>


        <!-- Custom HTML head -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-23228806-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
        <meta name="description" content="A collection of specific ways to improve your use of Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/third_party/ferris/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cover.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="use-types.html"><strong aria-hidden="true">3.1.</strong> Item 1: Use the type system to express your data structures</a></li><li class="chapter-item expanded "><a href="use-types-2.html"><strong aria-hidden="true">3.2.</strong> Item 2: Use the type system to express common behaviour</a></li><li class="chapter-item expanded "><a href="transform.html" class="active"><strong aria-hidden="true">3.3.</strong> Item 3: Avoid matching Option and Result</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">3.4.</strong> Item 4: Prefer idiomatic Error variants</a></li><li class="chapter-item expanded "><a href="std-traits.html"><strong aria-hidden="true">3.5.</strong> Item 5: Familiarize yourself with standard traits</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">3.6.</strong> Item 6: Understand type conversions</a></li><li class="chapter-item expanded "><a href="newtype.html"><strong aria-hidden="true">3.7.</strong> Item 7: Embrace the newtype pattern</a></li><li class="chapter-item expanded "><a href="builders.html"><strong aria-hidden="true">3.8.</strong> Item 8: Use builders for complex types</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.9.</strong> Item 9: Familiarize yourself with reference and pointer types</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">3.10.</strong> Item 10: Consider using iterator transforms instead of explicit loops</a></li><li class="chapter-item expanded "><a href="raii.html"><strong aria-hidden="true">3.11.</strong> Item 11: Implement the Drop trait for RAII patterns</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">3.12.</strong> Item 12: Prefer generics to trait objects</a></li><li class="chapter-item expanded "><a href="default-impl.html"><strong aria-hidden="true">3.13.</strong> Item 13: Use default implementations to minimize required trait methods</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">4.1.</strong> Item 14: Understand lifetimes</a></li><li class="chapter-item expanded "><a href="borrows.html"><strong aria-hidden="true">4.2.</strong> Item 15: Understand the borrow checker</a></li><li class="chapter-item expanded "><a href="unsafe.html"><strong aria-hidden="true">4.3.</strong> Item 16: Avoid writing unsafe code</a></li><li class="chapter-item expanded "><a href="deadlock.html"><strong aria-hidden="true">4.4.</strong> Item 17: Be wary of shared-state parallelism</a></li><li class="chapter-item expanded "><a href="panic.html"><strong aria-hidden="true">4.5.</strong> Item 18: Don't panic</a></li><li class="chapter-item expanded "><a href="reflection.html"><strong aria-hidden="true">4.6.</strong> Item 19: Avoid reflection</a></li><li class="chapter-item expanded "><a href="optimize.html"><strong aria-hidden="true">4.7.</strong> Item 20: Avoid the temptation to over-optimize</a></li></ol></li><li class="chapter-item expanded "><a href="deps.html"><strong aria-hidden="true">5.</strong> Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="semver.html"><strong aria-hidden="true">5.1.</strong> Item 21: Understand what semantic versioning promises</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.2.</strong> Item 22: Minimize visibility</a></li><li class="chapter-item expanded "><a href="wildcard.html"><strong aria-hidden="true">5.3.</strong> Item 23: Avoid wildcard imports</a></li><li class="chapter-item expanded "><a href="re-export.html"><strong aria-hidden="true">5.4.</strong> Item 24: Re-export dependencies whose types appear in your API</a></li><li class="chapter-item expanded "><a href="dep-graph.html"><strong aria-hidden="true">5.5.</strong> Item 25: Manage your dependency graph</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">5.6.</strong> Item 26: Be wary of feature creep</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">6.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">6.1.</strong> Item 27: Document public interfaces</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">6.2.</strong> Item 28: Use macros judiciously</a></li><li class="chapter-item expanded "><a href="clippy.html"><strong aria-hidden="true">6.3.</strong> Item 29: Listen to Clippy</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.4.</strong> Item 30: Write more than unit tests</a></li><li class="chapter-item expanded "><a href="use-tools.html"><strong aria-hidden="true">6.5.</strong> Item 31: Take advantage of the tooling ecosystem</a></li><li class="chapter-item expanded "><a href="ci.html"><strong aria-hidden="true">6.6.</strong> Item 32: Set up a continuous integration (CI) system</a></li></ol></li><li class="chapter-item expanded "><a href="beyond-std.html"><strong aria-hidden="true">7.</strong> Beyond Standard Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="no-std.html"><strong aria-hidden="true">7.1.</strong> Item 33: Consider making library code no_std compatible</a></li><li class="chapter-item expanded "><a href="ffi.html"><strong aria-hidden="true">7.2.</strong> Item 34: Control what crosses FFI boundaries</a></li><li class="chapter-item expanded "><a href="bindgen.html"><strong aria-hidden="true">7.3.</strong> Item 35: Prefer bindgen to manual FFI mappings</a></li></ol></li><li class="chapter-item expanded "><a href="indexing.html"><strong aria-hidden="true">8.</strong> Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="item-3-avoid-matching-option-and-result"><a class="header" href="#item-3-avoid-matching-option-and-result">Item 3: Avoid <code>match</code>ing <code>Option</code> and <code>Result</code></a></h1>
<p><a href="use-types.html">Item 1</a> expounded the virtues of <a name="a001"></a><code>enum</code> and showed how <a name="a002"></a><code>match</code> expressions force the programmer to take all
possibilities into account; this Item explores situations where you should prefer to avoid <code>match</code> expressions –
explicitly at least.</p>
<p><a href="use-types.html">Item 1</a> also introduced the two ubiquitous <code>enum</code>s that are provided by the Rust standard library:</p>
<ul>
<li><a name="a003"></a><a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;T&gt;</code></a> to express that a value (of type
<code>T</code>) <a name="a004"></a>may or <a name="a005"></a>may not be present</li>
<li><a name="a006"></a><a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;T, E&gt;</code></a>, for when an operation to
return a <a name="a007"></a>value (of type <code>T</code>) may not succeed, and may instead return an <a name="a008"></a>error (of type <code>E</code>).</li>
</ul>
<p>For these particular <code>enum</code>s, <em>explicitly</em> using <code>match</code> often leads to code that is less compact than it needs to be,
and which isn't idiomatic Rust.</p>
<p>The first situation where a <code>match</code> is unnecessary is when only the value is relevant, and the absence of value (and any
associated error) can just be ignored.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct S {
        field: Option&lt;i32&gt;,
    }

    let s = S { field: Some(42) };
    match &amp;s.field {
        Some(i) =&gt; println!(&quot;field is {}&quot;, i),
        None =&gt; {}
    }
<span class="boring">}</span></code></pre></pre>
<p>For this situation, an <a name="a009"></a><a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions"><code>if let</code></a>
expression is one line shorter and, more importantly, clearer:</p>
<pre><code class="language-rust ignore">    if let Some(i) = &amp;s.field {
        println!(&quot;field is {}&quot;, i);
    }</code></pre>
<p>However, most of the time the absence of a value, and an associated error, is going to be something that the programmer
has to deal with. Designing software to cope with failure paths is hard, and most of that is essential complexity that
no amount of syntactic support can help with – specifically, deciding what should happen if an operation fails.</p>
<p>In some situations, the right decision is to perform an <a name="a010"></a>ostrich manoeuvre and explicitly not cope with
failure. Doing this with an explicit <code>match</code> would be needlessly verbose:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let result = std::fs::File::open(&quot;/etc/passwd&quot;);
    let f = match result {
        Ok(f) =&gt; f,
        Err(_e) =&gt; panic!(&quot;Failed to open /etc/passwd!&quot;),
    };
<span class="boring">}</span></code></pre></pre>
<p>Both <code>Option</code> and <code>Result</code> provide a pair of methods that extract their inner value and <code>panic!</code> if it's absent:
<a name="a011"></a><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>unwrap</code></a> and
<a name="a012"></a><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect</code></a>.  The latter allows the error
message on failure to be personalized, but in either case the resulting code is shorter and simpler – error
handling is delegated to the <code>.unwrap()</code> suffix (but is still present).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let f = std::fs::File::open(&quot;/etc/passwd&quot;).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Be clear, though: these helper functions still <a name="a013"></a><code>panic!</code>, so choosing to use them is the same as choosing to <code>panic!</code>
(<a href="panic.html">Item 18</a>).</p>
<p>However, in many situations, the right decision for error handling is to defer the decision to somebody else.  This is
particularly true when writing a library, where the code may be used in all sorts of different environments that can't
be foreseen by the library author.  To make that somebody else's job easier, <strong>prefer <code>Result</code> to <code>Option</code></strong>, even
though this may involve conversions between different error types (<a href="errors.html">Item 4</a>).</p>
<p><code>Result</code> has also a
<a name="a014"></a><a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute"><code>[#must_use]</code></a>
attribute to nudge library users in the right direction – if the code using the returned <code>Result</code> ignores it, the
compiler will generate a warning:</p>
<pre><code class="language-text">warning: unused `Result` that must be used
  --&gt; transform/src/main.rs:32:5
   |
32 |     f.set_len(0); // Truncate the file
   |     ^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled
</code></pre>
<p>Explicitly using a <code>match</code> allows an error to propagate, but at the cost of some visible boilerplate (reminiscent of
<a name="a015"></a><a href="https://blog.golang.org/errors-are-values">Go</a>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, std::io::Error&gt; {
        let f = match std::fs::File::open(&quot;/etc/passwd&quot;) {
            Ok(f) =&gt; f,
            Err(e) =&gt; return Err(e),
        };
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>The key ingredient for reducing boilerplate is Rust's <a name="a016"></a><a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator">question mark operator
<code>?</code></a>.  This piece of
<a name="a017"></a>syntactic sugar takes care of matching the <code>Err</code> arm and the <code>return Err(...)</code> expression in a single character:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, std::io::Error&gt; {
        let f = std::fs::File::open(&quot;/etc/passwd&quot;)?;
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>Newcomers to Rust sometimes find this disconcerting: the question mark can be hard to spot on first glance, leading to
disquiet as to how the code can possibly work. However, even with a single character, the <a name="a018"></a>type system is still at
work, ensuring that all of the possibilities expressed in the relevant types (<a href="use-types.html">Item 1</a>) are covered – leaving the
programmer to focus on the mainline code path without distractions.</p>
<p>What's more, there's generally no cost to these apparent method invocations: they are all <a name="a019"></a>generic functions marked
as <a name="a020"></a><a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute"><code>#[inline]</code></a>, so
the generated code will typically compile to machine code that's identical to the manual version.</p>
<p>These two factors taken together mean that you should <strong>prefer <code>Option</code> and <code>Result</code> transforms to explicit <code>match</code>
expressions</strong>.</p>
<p>In the previous example, the error types lined up: both the inner and outer methods expressed errors as <a name="a021"></a>
<a href="https://doc.rust-lang.org/std/io/struct.Error.html"><code>std::io::Error</code></a>. That's often not the case; one function may
accumulate errors from a variety of different sub-libraries, each of which uses different error types.</p>
<p>Error mapping in general is discussed in <a href="errors.html">Item 4</a>; for now, just be aware that a manual mapping:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, String&gt; {
        let f = match std::fs::File::open(&quot;/etc/passwd&quot;) {
            Ok(f) =&gt; f,
            Err(e) =&gt; {
                return Err(format!(&quot;Failed to open password file: {:?}&quot;, e))
            }
        };
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>can be more succinctly and idiomatically expressed with the
<a name="a022"></a><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>.map_err()</code></a> transformation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, String&gt; {
        let f = std::fs::File::open(&quot;/etc/passwd&quot;)
            .map_err(|e| format!(&quot;Failed to open password file: {:?}&quot;, e))?;
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>Better still, even this may not be necessary – if the outer error type can be created from the inner error type
via an implementation of the <a name="a023"></a><code>From</code> standard trait (<a href="std-traits.html">Item 5</a>), then the compiler will automatically perform the
conversion without the need for a call to <code>.map_err()</code>.</p>
<p>These kinds of transformations generalize more widely. The question mark operator is a big hammer; use transformation
methods on <code>Option</code> and <code>Result</code> types to manoeuvre them into a position where they can be a nail.</p>
<p>The standard library provides a wide variety of these transformation methods to make this possible, as shown in the
following map.  In line with <a href="panic.html">Item 18</a>, methods that can <a name="a024"></a><code>panic!</code> are highlighted in red.</p>
<p><img src="images/transform.svg" alt="Option/Result transformations" /></p>
<p>(The <a href="https://tinyurl.com/rust-transform">online version</a> of this diagram is clickable: each box links to the relevant
documentation.)</p>
<p>One common situation which isn't covered by the diagram is dealing with references. For example, consider a structure
that optionally holds some data.</p>
<pre><code class="language-rust ignore">    struct InputData {
        payload: Option&lt;Vec&lt;u8&gt;&gt;,
    }</code></pre>
<p>A method on this <code>struct</code> which tries to pass the payload to an encryption function with signature <code>(&amp;[u8]) -&gt; Vec&lt;u8&gt;</code>
fails if there's a naive attempt to take a reference:</p>
<pre><code class="language-rust ignore does_not_compile">    impl InputData {
        pub fn encrypted(&amp;self) -&gt; Vec&lt;u8&gt; {
            encrypt(&amp;self.payload.unwrap_or(vec![]))
        }
    }</code></pre>
<pre><code class="language-text">error[E0507]: cannot move out of `self.payload` which is behind a shared reference
  --&gt; transform/src/main.rs:62:22
   |
62 |             encrypt(&amp;self.payload.unwrap_or(vec![]))
   |                      ^^^^^^^^^^^^ move occurs because `self.payload` has type `Option&lt;Vec&lt;u8&gt;&gt;`, which does not implement the `Copy` trait
   |
help: consider borrowing the `Option`'s content
   |
62 |             encrypt(&amp;self.payload.as_ref().unwrap_or(vec![]))
   |                                  +++++++++
</code></pre>
<p>The error message describes exactly what's needed to make the code work, the
<a name="a025"></a><a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.as_ref"><code>as_ref()</code></a>
method<sup><a name="to-footnote-1"><a href="#footnote-1">1</a></a></sup>  on <code>Option</code>. This method converts a reference-to-an-<code>Option</code> to be an <code>Option</code>-of-a-reference:</p>
<pre><code class="language-rust ignore">        pub fn encrypted(&amp;self) -&gt; Vec&lt;u8&gt; {
            encrypt(self.payload.as_ref().unwrap_or(&amp;vec![]))
        }</code></pre>
<p>To sum up:</p>
<ul>
<li>Get used to the transformations of <code>Option</code> and <code>Result</code>, and prefer <code>Result</code> to <code>Option</code>.
<ul>
<li>Use <code>.as_ref()</code> as needed when transformations involve references.</li>
</ul>
</li>
<li>Use them in preference to explicit <code>match</code> operations.</li>
<li>In particular, use them to transform result types into a form where the <code>?</code> operator applies.</li>
</ul>
<p><hr/>
<p><a name="footnote-1"><a href="#to-footnote-1">1</a></a>: Note that this method is separate from the <a name="a026"></a><code>AsRef</code> trait, even though the method name is the
same.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="use-types-2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="errors.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="use-types-2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="errors.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/third_party/ferris/ferris.js"></script>


    </div>
    </body>
</html>
