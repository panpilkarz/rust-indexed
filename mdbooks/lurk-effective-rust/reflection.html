<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Item 19: Avoid reflection - Effective Rust</title>


        <!-- Custom HTML head -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-23228806-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
        <meta name="description" content="A collection of specific ways to improve your use of Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/third_party/ferris/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cover.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="use-types.html"><strong aria-hidden="true">3.1.</strong> Item 1: Use the type system to express your data structures</a></li><li class="chapter-item expanded "><a href="use-types-2.html"><strong aria-hidden="true">3.2.</strong> Item 2: Use the type system to express common behaviour</a></li><li class="chapter-item expanded "><a href="transform.html"><strong aria-hidden="true">3.3.</strong> Item 3: Avoid matching Option and Result</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">3.4.</strong> Item 4: Prefer idiomatic Error variants</a></li><li class="chapter-item expanded "><a href="std-traits.html"><strong aria-hidden="true">3.5.</strong> Item 5: Familiarize yourself with standard traits</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">3.6.</strong> Item 6: Understand type conversions</a></li><li class="chapter-item expanded "><a href="newtype.html"><strong aria-hidden="true">3.7.</strong> Item 7: Embrace the newtype pattern</a></li><li class="chapter-item expanded "><a href="builders.html"><strong aria-hidden="true">3.8.</strong> Item 8: Use builders for complex types</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.9.</strong> Item 9: Familiarize yourself with reference and pointer types</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">3.10.</strong> Item 10: Consider using iterator transforms instead of explicit loops</a></li><li class="chapter-item expanded "><a href="raii.html"><strong aria-hidden="true">3.11.</strong> Item 11: Implement the Drop trait for RAII patterns</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">3.12.</strong> Item 12: Prefer generics to trait objects</a></li><li class="chapter-item expanded "><a href="default-impl.html"><strong aria-hidden="true">3.13.</strong> Item 13: Use default implementations to minimize required trait methods</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">4.1.</strong> Item 14: Understand lifetimes</a></li><li class="chapter-item expanded "><a href="borrows.html"><strong aria-hidden="true">4.2.</strong> Item 15: Understand the borrow checker</a></li><li class="chapter-item expanded "><a href="unsafe.html"><strong aria-hidden="true">4.3.</strong> Item 16: Avoid writing unsafe code</a></li><li class="chapter-item expanded "><a href="deadlock.html"><strong aria-hidden="true">4.4.</strong> Item 17: Be wary of shared-state parallelism</a></li><li class="chapter-item expanded "><a href="panic.html"><strong aria-hidden="true">4.5.</strong> Item 18: Don't panic</a></li><li class="chapter-item expanded "><a href="reflection.html" class="active"><strong aria-hidden="true">4.6.</strong> Item 19: Avoid reflection</a></li><li class="chapter-item expanded "><a href="optimize.html"><strong aria-hidden="true">4.7.</strong> Item 20: Avoid the temptation to over-optimize</a></li></ol></li><li class="chapter-item expanded "><a href="deps.html"><strong aria-hidden="true">5.</strong> Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="semver.html"><strong aria-hidden="true">5.1.</strong> Item 21: Understand what semantic versioning promises</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.2.</strong> Item 22: Minimize visibility</a></li><li class="chapter-item expanded "><a href="wildcard.html"><strong aria-hidden="true">5.3.</strong> Item 23: Avoid wildcard imports</a></li><li class="chapter-item expanded "><a href="re-export.html"><strong aria-hidden="true">5.4.</strong> Item 24: Re-export dependencies whose types appear in your API</a></li><li class="chapter-item expanded "><a href="dep-graph.html"><strong aria-hidden="true">5.5.</strong> Item 25: Manage your dependency graph</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">5.6.</strong> Item 26: Be wary of feature creep</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">6.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">6.1.</strong> Item 27: Document public interfaces</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">6.2.</strong> Item 28: Use macros judiciously</a></li><li class="chapter-item expanded "><a href="clippy.html"><strong aria-hidden="true">6.3.</strong> Item 29: Listen to Clippy</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.4.</strong> Item 30: Write more than unit tests</a></li><li class="chapter-item expanded "><a href="use-tools.html"><strong aria-hidden="true">6.5.</strong> Item 31: Take advantage of the tooling ecosystem</a></li><li class="chapter-item expanded "><a href="ci.html"><strong aria-hidden="true">6.6.</strong> Item 32: Set up a continuous integration (CI) system</a></li></ol></li><li class="chapter-item expanded "><a href="beyond-std.html"><strong aria-hidden="true">7.</strong> Beyond Standard Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="no-std.html"><strong aria-hidden="true">7.1.</strong> Item 33: Consider making library code no_std compatible</a></li><li class="chapter-item expanded "><a href="ffi.html"><strong aria-hidden="true">7.2.</strong> Item 34: Control what crosses FFI boundaries</a></li><li class="chapter-item expanded "><a href="bindgen.html"><strong aria-hidden="true">7.3.</strong> Item 35: Prefer bindgen to manual FFI mappings</a></li></ol></li><li class="chapter-item expanded "><a href="indexing.html"><strong aria-hidden="true">8.</strong> Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="item-19-avoid-reflection"><a class="header" href="#item-19-avoid-reflection">Item 19: Avoid reflection</a></h1>
<p>Programmers coming to Rust from other languages are often used to reaching for <a name="a001"></a>reflection as a tool in their toolbox.
They can waste a lot of time trying to implement reflection-based designs in Rust, only to discover that what they're
attempting can only be done poorly, if at all.  This Item hopes to save that time wasted exploring dead-ends, by
describing what Rust does and doesn't have in the way of reflection, and what can be used instead.</p>
<p><em>Reflection</em> is the ability of a program to examine itself at run-time.  Given an item at run-time, it covers:</p>
<ul>
<li>What information can be determined about the item's type?</li>
<li>What can be done with that information?</li>
</ul>
<p>Programming languages with full reflection support have extensive answers to these questions – as well as
determining an item's type at run-time, its contents can be explored, its fields modified and its methods invoked.
Languages that have this level of reflection support <em>tend</em> to be dynamically typed languages (e.g.
<a href="https://docs.python.org/3/library/types.html#module-types"><a name="a002"></a>Python</a>, Ruby), but there are also some notable statically
typed languages that also support this, particularly
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html"><a name="a003"></a>Java</a>
and <a href="https://golang.org/pkg/reflect/"><a name="a004"></a>Go</a>.</p>
<p>Rust does not support this type of reflection, which makes the advice to <strong>avoid reflection</strong> easy to follow at this
level – it's just not possible.  For programmers coming from languages with support for full reflection, this
absence may seem like a significant gap at first, but Rust's other features provide alternative ways of solving many of
the same problems.</p>
<p><a name="a005"></a>C++ has a more limited form of reflection, known as <em>run-time type identification</em> (<a name="a006"></a>RTTI).  The
<a name="a007"></a><a href="https://en.cppreference.com/w/cpp/language/typeid"><code>typeid</code></a> operator returns a unique identifier
for every type, for objects of <em>polymorphic type</em> (roughly: classes with virtual functions):</p>
<ul>
<li><code>typeid</code> can recover the concrete class of an object referred to via a base class reference</li>
<li><a name="a008"></a><a href="https://en.cppreference.com/w/cpp/language/dynamic_cast"><code>dynamic_cast&lt;T&gt;</code></a> allows base
class references to be converted to derived classes, when it is safe and correct to do so.</li>
</ul>
<p>Rust does not support this RTTI style of reflection either, continuing the theme that the advice of this Item is easy to
follow.</p>
<p>Rust does support some features that provide <em>similar</em> functionality (in the
<a href="https://doc.rust-lang.org/std/any/index.html"><code>std::any</code></a> module), but they're limited (in ways explored below) and so
best avoided unless no other alternatives are possible.</p>
<p>The first reflection-like feature <em>looks</em> magic at first – a way of determining the name of an item's type:</p>
<pre><code class="language-rust ignore">    let x = 42u32;
    let y = Square::new(3, 4, 2);
    println!(&quot;x: {} = {}&quot;, tname(&amp;x), x);
    println!(&quot;y: {} = {:?}&quot;, tname(&amp;y), y);</code></pre>
<pre><code class="language-text">x: u32 = 42
y: reflection::Square = Square { top_left: Point { x: 3, y: 4 }, size: 2 }
</code></pre>
<p>The implementation of <code>tname()</code> reveals what's up the compiler's sleeve; the function is <a name="a009"></a>generic
(as per <a href="generics.html">Item 12</a>) and so each invocation of it is actually a <a name="a010"></a>different function (<code>tname::&lt;u32&gt;</code>
or <code>tname::&lt;Square&gt;</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn tname&lt;T: ?Sized&gt;(_v: &amp;T) -&gt; &amp;'static str {
    std::any::type_name::&lt;T&gt;()
}
<span class="boring">}</span></code></pre></pre>
<p>The <a name="a011"></a><a href="https://doc.rust-lang.org/std/any/fn.type_name.html"><code>std::any::type_name&lt;T&gt;</code></a> library function
only has access to <em>compile-time</em> information; nothing clever is happening at run-time.</p>
<p>The string returned by <code>type_name</code> is only suitable for diagnostics – it's explicitly a &quot;best-effort&quot; helper whose
contents may change, and may not be unique – so <strong>don't attempt to parse <code>type_name</code> results</strong>. If you need a
globally unique type identifier, use <a name="a012"></a><a href="https://doc.rust-lang.org/std/any/struct.TypeId.html"><code>TypeId</code></a> instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::any::TypeId;

fn type_id&lt;T: 'static + ?Sized&gt;(_v: &amp;T) -&gt; TypeId {
    TypeId::of::&lt;T&gt;()
}
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-rust ignore">    println!(&quot;x has {:?}&quot;, type_id(&amp;x));
    println!(&quot;y has {:?}&quot;, type_id(&amp;y));</code></pre>
<pre><code class="language-text">x has TypeId { t: 14816064564273904734 }
y has TypeId { t: 7700407161019666586 }
</code></pre>
<p>The output is less helpful for humans, but the guarantee of uniqueness means that the result can be used in code.
However, it's usually best not to do so directly, but to use the
<a name="a013"></a><a href="https://doc.rust-lang.org/std/any/trait.Any.html"><code>std::any::Any</code></a> trait<sup><a name="to-footnote-1"><a href="#footnote-1">1</a></a></sup> instead.</p>
<p>This trait has a single method <a href="https://doc.rust-lang.org/std/any/trait.Any.html#tymethod.type_id"><code>type_id()</code></a>, which
returns the <code>TypeId</code> value for the type that implements the trait. You can't implement this trait yourself though,
because <code>Any</code> already comes with a <a name="a014"></a>blanket implementation for every type <code>T</code>:</p>
<pre><code class="language-rust ignore">impl&lt;T: 'static + ?Sized&gt; Any for T {
    fn type_id(&amp;self) -&gt; TypeId {
        TypeId::of::&lt;T&gt;()
    }
}</code></pre>
<p>Recall from <a href="references.html">Item 9</a> that a <a name="a015"></a>trait object is a <a name="a016"></a>fat pointer that holds a pointer to the underlying item,
together with a pointer to the trait implementation's <a name="a017"></a>vtable.  For <code>Any</code>, the vtable has a single entry, for a
method that returns the item's type.</p>
<pre><code class="language-rust ignore">    let x_any: Box&lt;dyn Any&gt; = Box::new(42u64);
    let y_any: Box&lt;dyn Any&gt; = Box::new(Square::new(3, 4, 3));</code></pre>
<img alt="Any trait objects, each with pointers to concrete items and vtables" src="images/anytraitobj.svg" width=756>
<p>Modulo a couple of indirections, a <code>dyn Any</code> trait object is effectively a combination of a raw pointer and a type
identifier.  This means that <code>Any</code> can offer some additional <a name="a018"></a>generic methods:</p>
<ul>
<li><a name="a019"></a><a href="https://doc.rust-lang.org/std/any/trait.Any.html#method.is"><code>is&lt;T&gt;</code></a> to indicate whether the trait
object's type is equal to some specific other type <code>T</code>.</li>
<li><a name="a020"></a><a href="https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_ref"><code>downcast_ref&lt;T&gt;</code></a> which
returns a reference to the concrete type <code>T</code>, provided that the type matches.</li>
<li><a name="a021"></a><a href="https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_mut"><code>downcast_mut&lt;T&gt;</code></a> for the
mutable variant of <code>downcast_ref</code>.</li>
</ul>
<p>Observe that the <code>Any</code> trait is only approximating reflection functionality: the programmer chooses (at compile-time) to
explicitly build something (<code>&amp;dyn Any</code>) that keeps track of an item's compile-time type as well as its location. The
ability to (say) downcast back to the original type is only possible if the overhead of building an <code>Any</code> trait object
has happened.</p>
<p>There are comparatively few scenarios where Rust has different compile-time and run-time types associated with an
item.  Chief among these is <em><a name="a022"></a>trait objects</em>: an item of a concrete type <code>Square</code> can be coerced into a trait object
<code>dyn Shape</code> for a trait that the type implements.  This coercion builds a fat pointer (object+vtable) from a simple
pointer (object/item).</p>
<p>Recall also from <a href="generics.html">Item 12</a> that Rust's trait objects are not really <a name="a023"></a>object-oriented.  It's not the case that a
<code>Square</code> <strong>is-a</strong> <code>Shape</code>, it's just that a <code>Square</code> implements <code>Shape</code>'s interface.  The same is true for <a name="a024"></a>trait
bounds: a trait bound <code>Shape: Drawable</code> does <em>not</em> mean <a name="a025"></a><strong>is-a</strong>, it just means
<strong><a name="a026"></a>also-implements</strong>; the vtable for <code>Shape</code> includes the entries for the methods of <code>Drawable</code>.</p>
<p>For some simple trait bounds:</p>
<pre><code class="language-rust ignore">trait Drawable: Debug {
    fn bounds(&amp;self) -&gt; Bounds;
}

trait Shape: Drawable {
    fn render_in(&amp;self, bounds: Bounds);
    fn render(&amp;self) {
        self.render_in(overlap(SCREEN_BOUNDS, self.bounds()));
    }
}</code></pre>
<p>the equivalent trait objects:</p>
<pre><code class="language-rust ignore">    let square = Square::new(1, 2, 2);
    let draw: &amp;dyn Drawable = &amp;square;
    let shape: &amp;dyn Shape = &amp;square;</code></pre>
<p>have a layout whose arrows make the problem clear: given a <code>dyn Shape</code> object, there's no way to build a <code>dyn Drawable</code>
trait object, because there's no way to get back to the <a name="a027"></a>vtable for <code>impl Drawable for Square</code> – even though the
relevant parts of its contents (the address of the <code>Square::bounds</code> method) <em>is</em> theoretically recoverable.</p>
<p><img alt="Trait objects for trait bounds, with distinct vtables for Shape and Square" src="images/traitbounds.svg"
width=714></p>
<p>Comparing with the previous diagram, it's also clear that an explicitly constructed <code>&amp;dyn Any</code> trait object doesn't help.
<code>Any</code> allows recovery of the original concrete type of the underlying item, but there is no run-time way to
see what traits it implement, nor to get access to the relevant vtable that might allow creation of a trait object.</p>
<p>So what's available instead?</p>
<p>The primary tool to reach for is trait definitions, and this is in line with advice for other languages –
<a name="a028"></a><em>Effective Java</em> Item 65 recommends &quot;Prefer interfaces to reflection&quot;.  If code needs to rely on certain behaviour being
available for an item, encode that behaviour as a <a name="a029"></a>trait (<a href="use-types-2.html">Item 2</a>). Even if the desired behaviour can't be expressed
as a set of method signatures, use marker traits to indicate compliance with the desired behaviour – it's safer
and more efficient than (say) introspecting the name of a class to check for a particular prefix.</p>
<p>Code that expects trait objects can also be used with objects whose backing code was not available at program link time,
because it has been dynamically loaded at run-time (via <a name="a030"></a><code>dlopen(3)</code> or equivalent) – which means that
<a name="a031"></a>monomorphization of a <a name="a032"></a>generic (<a href="generics.html">Item 12</a>) isn't possible.</p>
<p>Relatedly, reflection is sometimes also used in other languages to allow multiple incompatible versions of the same
dependency library to be loaded into the program at once, bypassing linkage constraints that <a name="a033"></a>There Can Be Only
One. This is not needed in Rust, where <a name="a034"></a>Cargo already copes with multiple versions of the same library (<a href="dep-graph.html">Item 25</a>).</p>
<p>Finally, <a name="a035"></a>macros – especially <a name="a036"></a> <code>derive</code> macros – can be used to auto-generate
ancillary code that understands an item's type at compile-time, as a more efficient and more type-safe equivalent to
code that parses an item's contents at run-time.</p>
<p><hr/>
<p><a name="footnote-1"><a href="#to-footnote-1">1</a></a>: The C++ equivalent of
<code>Any</code> is <a href="https://en.cppreference.com/w/cpp/utility/any"><code>std::any</code></a>, and <a href="https://abseil.io/tips/194">advice is to avoid it
too</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="panic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="optimize.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="panic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="optimize.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/third_party/ferris/ferris.js"></script>


    </div>
    </body>
</html>
