<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Item 5: Familiarize yourself with standard traits - Effective Rust</title>


        <!-- Custom HTML head -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-23228806-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
        <meta name="description" content="A collection of specific ways to improve your use of Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/third_party/ferris/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cover.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="use-types.html"><strong aria-hidden="true">3.1.</strong> Item 1: Use the type system to express your data structures</a></li><li class="chapter-item expanded "><a href="use-types-2.html"><strong aria-hidden="true">3.2.</strong> Item 2: Use the type system to express common behaviour</a></li><li class="chapter-item expanded "><a href="transform.html"><strong aria-hidden="true">3.3.</strong> Item 3: Avoid matching Option and Result</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">3.4.</strong> Item 4: Prefer idiomatic Error variants</a></li><li class="chapter-item expanded "><a href="std-traits.html" class="active"><strong aria-hidden="true">3.5.</strong> Item 5: Familiarize yourself with standard traits</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">3.6.</strong> Item 6: Understand type conversions</a></li><li class="chapter-item expanded "><a href="newtype.html"><strong aria-hidden="true">3.7.</strong> Item 7: Embrace the newtype pattern</a></li><li class="chapter-item expanded "><a href="builders.html"><strong aria-hidden="true">3.8.</strong> Item 8: Use builders for complex types</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.9.</strong> Item 9: Familiarize yourself with reference and pointer types</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">3.10.</strong> Item 10: Consider using iterator transforms instead of explicit loops</a></li><li class="chapter-item expanded "><a href="raii.html"><strong aria-hidden="true">3.11.</strong> Item 11: Implement the Drop trait for RAII patterns</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">3.12.</strong> Item 12: Prefer generics to trait objects</a></li><li class="chapter-item expanded "><a href="default-impl.html"><strong aria-hidden="true">3.13.</strong> Item 13: Use default implementations to minimize required trait methods</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">4.1.</strong> Item 14: Understand lifetimes</a></li><li class="chapter-item expanded "><a href="borrows.html"><strong aria-hidden="true">4.2.</strong> Item 15: Understand the borrow checker</a></li><li class="chapter-item expanded "><a href="unsafe.html"><strong aria-hidden="true">4.3.</strong> Item 16: Avoid writing unsafe code</a></li><li class="chapter-item expanded "><a href="deadlock.html"><strong aria-hidden="true">4.4.</strong> Item 17: Be wary of shared-state parallelism</a></li><li class="chapter-item expanded "><a href="panic.html"><strong aria-hidden="true">4.5.</strong> Item 18: Don't panic</a></li><li class="chapter-item expanded "><a href="reflection.html"><strong aria-hidden="true">4.6.</strong> Item 19: Avoid reflection</a></li><li class="chapter-item expanded "><a href="optimize.html"><strong aria-hidden="true">4.7.</strong> Item 20: Avoid the temptation to over-optimize</a></li></ol></li><li class="chapter-item expanded "><a href="deps.html"><strong aria-hidden="true">5.</strong> Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="semver.html"><strong aria-hidden="true">5.1.</strong> Item 21: Understand what semantic versioning promises</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.2.</strong> Item 22: Minimize visibility</a></li><li class="chapter-item expanded "><a href="wildcard.html"><strong aria-hidden="true">5.3.</strong> Item 23: Avoid wildcard imports</a></li><li class="chapter-item expanded "><a href="re-export.html"><strong aria-hidden="true">5.4.</strong> Item 24: Re-export dependencies whose types appear in your API</a></li><li class="chapter-item expanded "><a href="dep-graph.html"><strong aria-hidden="true">5.5.</strong> Item 25: Manage your dependency graph</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">5.6.</strong> Item 26: Be wary of feature creep</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">6.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">6.1.</strong> Item 27: Document public interfaces</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">6.2.</strong> Item 28: Use macros judiciously</a></li><li class="chapter-item expanded "><a href="clippy.html"><strong aria-hidden="true">6.3.</strong> Item 29: Listen to Clippy</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.4.</strong> Item 30: Write more than unit tests</a></li><li class="chapter-item expanded "><a href="use-tools.html"><strong aria-hidden="true">6.5.</strong> Item 31: Take advantage of the tooling ecosystem</a></li><li class="chapter-item expanded "><a href="ci.html"><strong aria-hidden="true">6.6.</strong> Item 32: Set up a continuous integration (CI) system</a></li></ol></li><li class="chapter-item expanded "><a href="beyond-std.html"><strong aria-hidden="true">7.</strong> Beyond Standard Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="no-std.html"><strong aria-hidden="true">7.1.</strong> Item 33: Consider making library code no_std compatible</a></li><li class="chapter-item expanded "><a href="ffi.html"><strong aria-hidden="true">7.2.</strong> Item 34: Control what crosses FFI boundaries</a></li><li class="chapter-item expanded "><a href="bindgen.html"><strong aria-hidden="true">7.3.</strong> Item 35: Prefer bindgen to manual FFI mappings</a></li></ol></li><li class="chapter-item expanded "><a href="indexing.html"><strong aria-hidden="true">8.</strong> Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="item-5-familiarize-yourself-with-standard-traits"><a class="header" href="#item-5-familiarize-yourself-with-standard-traits">Item 5: Familiarize yourself with standard traits</a></h1>
<p>Rust encodes key behavioural aspects of its <a name="a001"></a>type system in the type system itself, through a collection of fine-grained
standard <a name="a002"></a>traits that describe those behaviours (cf. <a href="use-types-2.html">Item 2</a>).</p>
<p>Many of these traits will seem familiar to programmers coming from <a name="a003"></a>C++, corresponding to concepts such as
copy-constructors, destructors, equality and assignment operators, etc.</p>
<p>As in C++, it's often a good idea to implement many of these traits for your own types; the Rust compiler will give
you helpful error messages if some operation needs one of these traits for your type, and it isn't present.</p>
<p>Implementing such a large collection of traits may seem daunting, but most of the common ones can be automatically
applied to user-defined types, through use of <a name="a004"></a><a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros"><code>derive</code>
macros</a>. This leads to type definitions like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    enum MyBooleanOption {
        Off,
        On,
    }
<span class="boring">}</span></code></pre></pre>
<p>This fine-grained specification of behaviour can be disconcerting at first, but it's important to be familiar with the
most common of these standard traits so that the available behaviours of a type definition can be immediately
understood.</p>
<p>A rough one-sentence summary of each of the standard traits that this Item covers is:</p>
<ul>
<li><a name="a005"></a><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>: Items of this type can make a copy of themselves
when asked.</li>
<li><a name="a006"></a><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>: If the compiler makes a bit-for-bit copy of this
item's memory representation, the result is a valid new item.</li>
<li><a name="a007"></a><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a>: It's possible to make new instances of
this type with sensible default values.</li>
<li><a name="a008"></a><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>: There's a <a href="https://en.wikipedia.org/wiki/Partial_equivalence_relation">partial equivalence
relation</a> for items of this type – any two items
can be definitively compared, but it may not always be true that <code>x==x</code>.</li>
<li><a name="a009"></a><a href="https://doc.rust-lang.org/beta/std/cmp/trait.Eq.html"><code>Eq</code></a>: There's an <a href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence
relation</a> for items of this type: any two items can be
definitively compared, and it <em>is</em> always true that <code>x==x</code>.</li>
<li><a name="a010"></a><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a>: <em>Some</em> items of this type can be
compared and ordered.</li>
<li><a name="a011"></a><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialOrd.html"><code>Ord</code></a>: <em>All</em> items of this type can be
compared and ordered.</li>
<li><a name="a012"></a><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a>: Items of this type can produce a stable hash of their
contents when asked.</li>
<li><a name="a013"></a><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>: Items of this type can be displayed to programmers.</li>
<li><a name="a014"></a><a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a>: Items of this type can be displayed to users.</li>
</ul>
<p>These traits can all be <code>derive</code>d for user-defined types, with the exception of <code>Display</code> (included here because of its
overlap with <code>Debug</code>).  However, there are occasions when a manual implementation – or no implementation –
is preferable.</p>
<p>Rust also allows various built-in unary and binary operators to be overloaded for user-defined types, by implementing
various traits from the <a href="https://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code> module</a>.  These traits are not
derivable, and are typically only needed for types that represent &quot;algebraic&quot; objects.</p>
<p>Other (non-<code>derive</code>able) standard traits are covered in other Items, and so are not included here. These include:</p>
<ul>
<li><a name="a015"></a><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>,
<a name="a016"></a><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> and
<a name="a017"></a><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>: Items implementing this trait represent closures
that can be invoked. See <a href="use-types-2.html">Item 2</a>.</li>
<li><a name="a018"></a><a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a>: Items implementing this trait represent error
information that can be displayed to users or programmers, and which <em>may</em> hold nested sub-error information.  See
<a href="errors.html">Item 4</a>.</li>
<li><a name="a019"></a><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>: Items implementing this trait perform processing
when they are destroyed, which is essential for <a name="a020"></a>RAII patterns. See <a href="raii.html">Item 11</a>.</li>
<li><a name="a021"></a><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and
<a name="a022"></a><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a>: Items implementing this trait can be automatically
created from items of some other type, but with a possibility of failure in the latter case. See <a href="casts.html">Item 6</a>.</li>
<li><a name="a023"></a><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> and
<a name="a024"></a><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a>: Items implementing this trait are
pointer-like objects that can be dereferenced to get access to an inner item. See <a href="references.html">Item 9</a>.</li>
<li><a name="a025"></a><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a> and friends: Items implementing this trait
represent collections that can be iterated over.  See <a href="iterators.html">Item 10</a>.</li>
<li><a name="a026"></a><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>: Items implementing this trait are safe to
transfer between multiple threads. See <a href="deadlock.html">Item 17</a>.</li>
<li><a name="a027"></a><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>: Items implementing this trait are safe to be
referenced by multiple threads. See <a href="deadlock.html">Item 17</a>.</li>
</ul>
<h2 id="clone"><a class="header" href="#clone"><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a></a></h2>
<p>The <a name="a028"></a><code>Clone</code> trait indicates that it's possible to make a new copy of an item, by calling the
<a href="https://doc.rust-lang.org/std/clone/trait.Clone.html#tymethod.clone"><code>clone()</code></a> method.  This is roughly equivalent to
C++'s copy-constructor, but more explicit: the compiler will never silently invoke this method on its own (read on to
the next section for that).</p>
<p><code>Clone</code> can be <a name="a029"></a><code>derive</code>d; the macro implementation clones an aggregate type by cloning each of its members in turn,
again, roughly equivalent to a default copy-constructor in C++.  This makes the trait opt-in (by adding
<code>#[derive(Clone)]</code>), in contrast to the opt-out behaviour in C++ (<code>MyType(const MyType&amp;) = delete;</code>).</p>
<p>This is such a common and useful operation that it's more interesting to investigate the situations where you shouldn't
or can't implement <code>Clone</code>, or where the default <code>derive</code> implementation isn't appropriate.</p>
<ul>
<li>You <em>shouldn't</em> implement <code>Clone</code> if the item embodies unique access to some resource (such as an <a name="a030"></a>RAII type,
<a href="raii.html">Item 11</a>), or when there's another reason to restrict copies (e.g. if the item holds cryptographic key material).</li>
<li>You <em>can't</em> implement <code>Clone</code> if some component of your type is un-<code>Clone</code>able in turn.  Examples include:
<ul>
<li>Fields that are mutable references (<code>&amp;mut T</code>), because the <a name="a031"></a>borrow checker (<a href="borrows.html">Item 15</a>) only allows a single
mutable reference at a time.</li>
<li>Standard library types that fall into the previous category, such as
<a name="a032"></a><a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a> (embodies unique access) or
<a name="a033"></a><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> (restricts copies for thread safety).</li>
</ul>
</li>
<li>You should <em>manually implement</em> <code>Clone</code> if there is anything about your item that won't be captured by a (recursive)
field-by-field copy, or if there is additional book-keeping associated with item lifetimes. For example, consider a
type that tracks the number of extant items at runtime for metrics purposes; a manual <code>Clone</code> implementation can
ensure the counter is kept accurate.</li>
</ul>
<h2 id="copy"><a class="header" href="#copy"><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a></a></h2>
<p>The <a name="a034"></a><code>Copy</code> trait has a trivial declaration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Copy: Clone { }
<span class="boring">}</span></code></pre></pre>
<p>There are no methods in this trait, meaning that it is a <em><a name="a035"></a>marker trait</em> (as described in <a href="use-types-2.html">Item 2</a>): it's
used to indicate some constraint on the type that's not directly expressed in the type system.</p>
<p>In the case of <code>Copy</code>, the meaning of this marker is that not only can items of this type be copied (hence the <code>Clone</code>
trait bound), but also a bit-for-bit copy of the memory holding an item gives a correct new item.  Effectively, this
trait is a marker that says that a type is a <a href="https://en.wikipedia.org/wiki/Passive_data_structure">&quot;plain old data&quot; (POD)
type</a>.</p>
<p>In contrast to user-defined marker traits (<a href="use-types.html">Item 1</a>), <code>Copy</code> has a special significance to the compiler<sup><a name="to-footnote-1"><a href="#footnote-1">1</a></a></sup> over and above being available for trait bounds – it shifts
the compiler from <em><a name="a036"></a>move semantics</em> to <em><a name="a037"></a>copy semantics</em>.</p>
<p>With move semantics for the assignment operator, what the right hand giveth, the left hand taketh away:</p>
<pre><code class="language-rust ignore does_not_compile">        #[derive(Debug, Clone)]
        struct KeyId(u32);
        let k = KeyId(42);
        let k2 = k; // value moves out of k in to k2
        println!(&quot;k={:?}&quot;, k);</code></pre>
<pre><code class="language-text">error[E0382]: borrow of moved value: `k`
  --&gt; std-traits/src/main.rs:52:28
   |
50 |         let k = KeyId(42);
   |             - move occurs because `k` has type `main::KeyId`, which does not implement the `Copy` trait
51 |         let k2 = k; // value moves out of k in to k2
   |                  - value moved here
52 |         println!(&quot;k={:?}&quot;, k);
   |                            ^ value borrowed here after move
   |
   = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<p>With copy semantics, the original item lives on:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        #[derive(Debug, Clone, Copy)]
        struct KeyId(u32);
        let k = KeyId(42);
        let k2 = k; // value bitwise copied from k to k2
        println!(&quot;k={:?}&quot;, k);
<span class="boring">}</span></code></pre></pre>
<p>This makes <code>Copy</code> one of the most important traits to watch out for: it fundamentally changes the behaviour of
assignments – and this includes parameters for method invocations.</p>
<p>In this respect, there are again overlaps with C++'s copy-constructors, but it's worth emphasizing a key distinction: in
Rust there is no way to get the compiler to silently invoke user-defined code – it's either explicit (a call to
<code>.clone()</code>), or it's not user-defined (a bitwise copy).</p>
<p>To finish this section, observe that because <code>Copy</code> has a <code>Clone</code> trait bound, it's possible to <code>.clone()</code> any
<code>Copy</code>-able item.  However, it's not a good idea: a bitwise copy will always be faster than invoking a trait method.
<a name="a038"></a>Clippy (<a href="clippy.html">Item 29</a>) will warn you about this:</p>
<pre><code class="language-rust ignore not_desired_behaviour">        let k3 = k.clone();</code></pre>
<pre><code class="language-text">warning: using `clone` on type `main::KeyId` which implements the `Copy` trait
  --&gt; std-traits/src/main.rs:68:18
   |
68 |         let k3 = k.clone();
   |                  ^^^^^^^^^ help: try removing the `clone` call: `k`
   |
</code></pre>
<h2 id="default"><a class="header" href="#default"><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a></a></h2>
<p>The <a name="a039"></a><code>Default</code> trait defines a <em>default constructor</em>, via a
<a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default"><code>default()</code></a> method. This trait can be
<a name="a040"></a><code>derive</code>d for user-defined types, provided that all of the sub-types involved have a <code>Default</code> implementation of
their own; if they don't, you'll have to implement the trait manually. Continuing the comparison with C++, notice that a
default constructor has to be explicitly triggered; the compiler does not create one automatically.</p>
<p>The most useful aspect of the <code>Default</code> trait is its combination with <a name="a041"></a><a href="https://doc.rust-lang.org/reference/expressions/struct-expr.html#functional-update-syntax"><em>struct update
syntax</em></a>.  This syntax allows
<code>struct</code> fields to be initialized by copying or moving their contents from an existing instance of the same <code>struct</code>,
for any fields that aren't explicitly initialized.  The template to copy from is given at the end of the initialization,
after <code>..</code>, and the <code>Default</code> trait provides an ideal template to use:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[derive(Default)]
    struct Colour {
        red: u8,
        green: u8,
        blue: u8,
        alpha: u8,
    }

    let c = Colour {
        red: 128,
        ..Default::default()
    };
<span class="boring">}</span></code></pre></pre>
<p>This makes it much easier to initialize structures with lots of fields, only some of which have non-default values.
(The <a name="a042"></a>builder pattern, <a href="builders.html">Item 8</a>, may also be appropriate for these situations.)</p>
<h2 id="partialeq-and-eq"><a class="header" href="#partialeq-and-eq"><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a> and <a href="https://doc.rust-lang.org/beta/std/cmp/trait.Eq.html"><code>Eq</code></a></a></h2>
<p>The <a name="a043"></a><code>PartialEq</code> and <a name="a044"></a><code>Eq</code> traits allow you to define equality for user-defined types. These traits have
special significance because if they're present, the compiler will automatically use them for equality (<code>==</code>) checks,
similarly to <code>operator==</code> in C++.  The default <a name="a045"></a><code>derive</code> implementation does this with a recursive field-by-field
comparison.</p>
<p>The <code>Eq</code> version is just a <a name="a046"></a>marker trait extension of <code>PartialEq</code> which adds the assumption of
<a name="a047"></a><em>reflexivity</em>: any type <code>T</code> that claims to support <code>Eq</code> should ensure that <code>x == x</code> is true for any <code>x: T</code>.</p>
<p>This is sufficiently odd to immediately raise the question: when wouldn't <code>x == x</code>?  The primary rationale behind this
split relates to <a name="a048"></a><a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">floating point
numbers</a><sup><a name="to-footnote-2"><a href="#footnote-2">2</a></a></sup>, and specifically to the special &quot;not a
number&quot; value NaN (<a name="a049"></a><code>f32::NAN</code> / <a name="a050"></a><code>f64::NAN</code> in Rust). The floating point specifications require that nothing
compares equal to NaN, <em>including NaN itself</em>; the <code>PartialEq</code> trait is the knock-on effect of this.</p>
<p>For user-defined types that don't have any float-related peculiarities, you should <strong>implement <code>Eq</code> whenever you
implement <code>PartialEq</code></strong>.  The full <code>Eq</code> trait is also required if you want to use the type as the key in a
<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> (as well as the <code>Hash</code> trait).</p>
<p>You should implement <code>PartialEq</code> manually if your type contains any fields that do not affect the item's identity,
such as internal caches and other performance optimizations.</p>
<h2 id="partialord-and-ord"><a class="header" href="#partialord-and-ord"><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a> and <a href="https://doc.rust-lang.org/beta/std/cmp/trait.Ord.html"><code>Ord</code></a></a></h2>
<p>The ordering traits <a name="a051"></a><code>PartialOrd</code> and <a name="a052"></a><code>Ord</code> allow comparisons between two items of a type, returning <code>Less</code>,
<code>Greater</code>, or <code>Equal</code>.  The traits require equivalent equality traits to be implemented (<code>PartialOrd</code> requires
<code>PartialEq</code>, <code>Ord</code> requires <code>Eq</code>), and the two have to agree with each other (watch out for this with manual
implementations in particular).</p>
<p>As with the equality traits, the comparison traits have special significance because the compiler will automatically use
them for comparison operations (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>).</p>
<p>The default implementation produced by <a name="a053"></a><code>derive</code> compares fields (or <code>enum</code> variants) lexicographically in the order
they're defined, so if this isn't correct you'll need to implement the traits manually (or re-order the fields).</p>
<p>Unlike <code>PartialEq</code>, the <code>PartialOrd</code> trait does correspond to a variety of real situations. For example, it could be
used to express a subset relationship<sup><a name="to-footnote-3"><a href="#footnote-3">3</a></a></sup> among collections: <code>{1, 2}</code> is a
subset of <code>{1, 2, 4}</code>, but <code>{1, 3}</code> is not a subset of <code>{2, 4}</code> nor vice versa.</p>
<p>However, even if a partial order does accurately model the behaviour of your type, <strong>be wary of implementing just
<code>PartialOrd</code></strong> (a rare occasion that contradicts the advice of <a href="use-types-2.html">Item 2</a> to encode behaviour in the type system) –
it can lead to surprising results:</p>
<pre><code class="language-rust ignore not_desired_behaviour">    let x = Oddity(1);
    let x2 = Oddity(1);
    if x &lt;= x2 {
        println!(&quot;It's possible to not hit this!&quot;);
    }

    let x = Oddity(1);
    let y = Oddity(2);
    // Programmers are unlikely to cover all possible arms...
    if x &lt;= y {
        println!(&quot;y is bigger&quot;); // Not hit
    } else if y &lt;= x {
        println!(&quot;x is bigger&quot;); // Not hit
    } else {
        println!(&quot;Neither is bigger&quot;); // This one
    }</code></pre>
<h2 id="hash"><a class="header" href="#hash"><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a></a></h2>
<p>The <a name="a055"></a><code>Hash</code> trait is used to produce a single value that has a high probability of being different for different
items; this value is used as the basis for hash-bucket based data structures like
<a name="a056"></a><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> and
<a name="a057"></a><a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html"><code>HashSet</code></a>.</p>
<p>Flipping this around, it's essential that the &quot;same&quot; items (as per <code>Eq</code>) always produce the same hash; if <code>x == y</code>
(via <code>Eq</code>) then it must always be true that <code>hash(x) == hash(y)</code>.  <strong>If you have a manual <code>Eq</code> implementation, check
whether you also need a manual implementation of <code>Hash</code></strong> to comply with this requirement.</p>
<h2 id="debug-and-display"><a class="header" href="#debug-and-display"><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> and <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a></a></h2>
<p>The <a name="a058"></a><code>Debug</code> and <a name="a059"></a><code>Display</code> traits allow a type to specify how it should be included in output, for either
normal (<code>{}</code> format argument) or debugging purposes (<code>{:?}</code> format argument), roughly analogous to an <code>operator&lt;&lt;</code>
overload for <code>iostream</code> in C++.</p>
<p>The differences between the intents of the two traits go beyond which format specifier is needed, though:</p>
<ul>
<li><code>Debug</code> can be automatically <a name="a060"></a>derived, <code>Display</code> can only be manually implemented. This is related
to…</li>
<li>The layout of <code>Debug</code> output may change between different Rust versions.  If the output will ever be parsed by
other code, use <code>Display</code>.</li>
<li><code>Debug</code> is programmer-oriented, <code>Display</code> is user-oriented. A thought experiment that helps with this is to
consider what would happen if the program was
<a href="https://en.wikipedia.org/wiki/Internationalization_and_localization">localized</a> to a language that the authors don't
speak; <code>Display</code> is appropriate if the content should be translated, <code>Debug</code> if not.</li>
</ul>
<p>As a general rule, <strong>add an automatically generated <code>Debug</code> implementation for your types</strong> unless they contain
sensitive information (personal details, cryptographic material etc.).  A manual implementation of <code>Debug</code> can be
appropriate when the automatically generated version would emit voluminous amounts of detail.</p>
<p>Implement <code>Display</code> if your types are designed to be shown to end users in textual output.</p>
<h2 id="operator-overloads"><a class="header" href="#operator-overloads">Operator Overloads</a></h2>
<p>Similarly to C++, Rust allows various arithmetic and bitwise operators to be overloaded for user-defined types.  This
is useful for &quot;algebraic&quot; or bit-manipulation types (respectively) where there is a natural interpretation of these
operators.  However, experience from C++ has shown that it's best to <strong>avoid overloading operators for unrelated types</strong>
as it often leads to code that is hard to maintain and has unexpected performance properties (e.g. <code>x + y</code> silently
invokes an expensive O(N) method).</p>
<p>Continuing with the principle of least surprise, if you implement any operator overloads you should <strong>implement a
coherent set of operator overloads</strong>. For example, if <code>x + y</code> has an overload
(<a name="a061"></a><a href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a>), and <code>-y</code>
(<a name="a062"></a><a href="https://doc.rust-lang.org/std/ops/trait.Neg.html"><code>Neg</code></a>), then you should also implement <code>x - y</code>
(<a name="a063"></a><a href="https://doc.rust-lang.org/std/ops/trait.Sub.html"><code>Sub</code></a>) and make sure it gives the same answer as <code>x + (-y)</code>.</p>
<p>The items passed to the operator overload traits are moved, which means that non-<code>Copy</code> types will be consumed by
default.  Adding implementations for <code>&amp;'a MyType</code> can help with this, but requires more boilerplate to cover all of the
possibilities (e.g. there are 4 = 2 × 2 possibilities for combining reference/non-reference arguments to a binary
operator).</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This item has covered a lot of ground, so some tables that summarize the standard traits that have been touched on are
in order. First, the traits of this Item, all of which can be automatically <a name="a064"></a><code>derive</code>d <strong>except <a name="a065"></a><code>Display</code></strong>.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Trait</th><th style="text-align: center">Compiler Use</th><th style="text-align: center">Bound</th><th style="text-align: left">Methods</th></tr></thead><tbody>
<tr><td style="text-align: left"><a name="a066"></a><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html#tymethod.clone"><code>clone</code></a></td></tr>
<tr><td style="text-align: left"><a name="a067"></a><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a></td><td style="text-align: center"><code>let y = x;</code></td><td style="text-align: center"><code>Clone</code></td><td style="text-align: left">Marker trait</td></tr>
<tr><td style="text-align: left"><a name="a068"></a><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default"><code>default</code></a></td></tr>
<tr><td style="text-align: left"><a name="a069"></a><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a></td><td style="text-align: center"><code>x == y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialEq.html#tymethod.eq"><code>eq</code></a></td></tr>
<tr><td style="text-align: left"><a name="a070"></a><a href="https://doc.rust-lang.org/beta/std/cmp/trait.Eq.html"><code>Eq</code></a></td><td style="text-align: center"><code>x == y</code></td><td style="text-align: center"><code>PartialEq</code></td><td style="text-align: left">Marker trait</td></tr>
<tr><td style="text-align: left"><a name="a071"></a><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></td><td style="text-align: center"><code>x &lt; y</code>, <div><code>x &lt;= y</code>,</div>…</td><td style="text-align: center"><code>PartialEq</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialOrd.html#tymethod.partial_cmp"><code>partial_cmp</code></a></td></tr>
<tr><td style="text-align: left"><a name="a072"></a><a href="https://doc.rust-lang.org/beta/std/cmp/trait.PartialOrd.html"><code>Ord</code></a></td><td style="text-align: center"><code>x &lt; y</code>, <div><code>x &lt;= y</code>,</div>…</td><td style="text-align: center"><code>Eq + PartialOrd</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/beta/std/cmp/trait.Ord.html#tymethod.cmp"><code>cmp</code></a></td></tr>
<tr><td style="text-align: left"><a name="a073"></a><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html#tymethod.hash"><code>hash</code></a></td></tr>
<tr><td style="text-align: left"><a name="a074"></a><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a></td><td style="text-align: center"><code>format!(&quot;{:?}&quot;, x)</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html#tymethod.fmt"><code>fmt</code></a></td></tr>
<tr><td style="text-align: left"><a name="a075"></a><a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a></td><td style="text-align: center"><code>format!(&quot;{}&quot;, x)</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Display.html#tymethod.fmt"><code>fmt</code></a></td></tr>
</tbody></table>
</div>
<p>The operator overloads are in the next table. None of these can be <a name="a076"></a><code>derive</code>d.</p>
<!--- NOTE: The entries for bitwise OR use U+23AE rather than vertical bar to avoid confusing the columns --->
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Trait</th><th style="text-align: center">Compiler Use</th><th style="text-align: center">Bound</th><th style="text-align: left">Methods</th></tr></thead><tbody>
<tr><td style="text-align: left"><a name="a077"></a><a href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a></td><td style="text-align: center"><code>x + y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Add.html#tymethod.add"><code>add</code></a></td></tr>
<tr><td style="text-align: left"><a name="a078"></a><a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html"><code>AddAssign</code></a></td><td style="text-align: center"><code>x += y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html#tymethod.add_assign"><code>add_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a079"></a><a href="https://doc.rust-lang.org/std/ops/trait.BitAnd.html"><code>BitAnd</code></a></td><td style="text-align: center"><code>x &amp; y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitAnd.html#tymethod.bitand"><code>bitand</code></a></td></tr>
<tr><td style="text-align: left"><a name="a080"></a><a href="https://doc.rust-lang.org/std/ops/trait.BitAndAssign.html"><code>BitAndAssign</code></a></td><td style="text-align: center"><code>x &amp;= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitAndAssign.html#tymethod.bitand_assign"><code>bitand_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a081"></a><a href="https://doc.rust-lang.org/std/ops/trait.BitOr.html"><code>BitOr</code></a></td><td style="text-align: center"><code>x ⎮ y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitOr.html#tymethod.bitor"><code>bitor</code></a></td></tr>
<tr><td style="text-align: left"><a name="a082"></a><a href="https://doc.rust-lang.org/std/ops/trait.BitOrAssign.html"><code>BitOrAssign</code></a></td><td style="text-align: center"><code>x ⎮= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitOrAssign.html#tymethod.bitor_assign"><code>bitor_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a083"></a><a href="https://doc.rust-lang.org/std/ops/trait.BitXor.html"><code>BitXor</code></a></td><td style="text-align: center"><code>x ^ y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitXor.html#tymethod.bitxor"><code>bitxor</code></a></td></tr>
<tr><td style="text-align: left"><a name="a084"></a><a href="https://doc.rust-lang.org/std/ops/trait.BitXorAssign.html"><code>BitXorAssign</code></a></td><td style="text-align: center"><code>x ^= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.BitXorAssign.html#tymethod.bitxor_assign"><code>bitxor_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a085"></a><a href="https://doc.rust-lang.org/std/ops/trait.Div.html"><code>Div</code></a></td><td style="text-align: center"><code>x / y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Div.html#tymethod.div"><code>div</code></a></td></tr>
<tr><td style="text-align: left"><a name="a086"></a><a href="https://doc.rust-lang.org/std/ops/trait.DivAssign.html"><code>DivAssign</code></a></td><td style="text-align: center"><code>x /= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.DivAssign.html#tymethod.div_assign"><code>div_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a087"></a><a href="https://doc.rust-lang.org/std/ops/trait.Mul.html"><code>Mul</code></a></td><td style="text-align: center"><code>x * y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Mul.html#tymethod.mul"><code>mul</code></a></td></tr>
<tr><td style="text-align: left"><a name="a088"></a><a href="https://doc.rust-lang.org/std/ops/trait.MulAssign.html"><code>MulAssign</code></a></td><td style="text-align: center"><code>x *= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.MulAssign.html#tymethod.mul_assign"><code>mul_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a089"></a><a href="https://doc.rust-lang.org/std/ops/trait.Neg.html"><code>Neg</code></a></td><td style="text-align: center"><code>-x</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Neg.html#tymethod.neg"><code>neg</code></a></td></tr>
<tr><td style="text-align: left"><a name="a090"></a><a href="https://doc.rust-lang.org/std/ops/trait.Not.html"><code>Not</code></a></td><td style="text-align: center"><code>!x</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Not.html#tymethod.not"><code>not</code></a></td></tr>
<tr><td style="text-align: left"><a name="a091"></a><a href="https://doc.rust-lang.org/std/ops/trait.Rem.html"><code>Rem</code></a></td><td style="text-align: center"><code>x % y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Rem.html#tymethod.rem"><code>rem</code></a></td></tr>
<tr><td style="text-align: left"><a name="a092"></a><a href="https://doc.rust-lang.org/std/ops/trait.RemAssign.html"><code>RemAssign</code></a></td><td style="text-align: center"><code>x %= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.RemAssign.html#tymethod.rem_assign"><code>rem_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a093"></a><a href="https://doc.rust-lang.org/std/ops/trait.Shl.html"><code>Shl</code></a></td><td style="text-align: center"><code>x &lt;&lt; y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Shl.html#tymethod.shl"><code>shl</code></a></td></tr>
<tr><td style="text-align: left"><a name="a094"></a><a href="https://doc.rust-lang.org/std/ops/trait.ShlAssign.html"><code>ShlAssign</code></a></td><td style="text-align: center"><code>x &lt;&lt;= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.ShlAssign.html#tymethod.shl_assign"><code>shl_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a095"></a><a href="https://doc.rust-lang.org/std/ops/trait.Shr.html"><code>Shr</code></a></td><td style="text-align: center"><code>x &gt;&gt; y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Shr.html#tymethod.shr"><code>shr</code></a></td></tr>
<tr><td style="text-align: left"><a name="a096"></a><a href="https://doc.rust-lang.org/std/ops/trait.ShrAssign.html"><code>ShrAssign</code></a></td><td style="text-align: center"><code>x &gt;&gt;= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.ShrAssign.html#tymethod.shr_assign"><code>shr_assign</code></a></td></tr>
<tr><td style="text-align: left"><a name="a097"></a><a href="https://doc.rust-lang.org/std/ops/trait.Sub.html"><code>Sub</code></a></td><td style="text-align: center"><code>x - y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Sub.html#tymethod.sub"><code>sub</code></a></td></tr>
<tr><td style="text-align: left"><a name="a098"></a><a href="https://doc.rust-lang.org/std/ops/trait.SubAssign.html"><code>SubAssign</code></a></td><td style="text-align: center"><code>x -= y</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.SubAssign.html#tymethod.sub_assign"><code>sub_assign</code></a></td></tr>
</tbody></table>
</div>
<p>For completeness, the standard traits that are covered in other items are included in the following table; none of these
traits are <a name="a099"></a><code>derive</code>able (but <a name="a100"></a><code>Send</code> and <a name="a101"></a><code>Sync</code> may be automatically implemented by the compiler).</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Trait</th><th style="text-align: center">Item</th><th style="text-align: center">Compiler Use</th><th style="text-align: center">Bound</th><th style="text-align: left">Methods</th></tr></thead><tbody>
<tr><td style="text-align: left"><a name="a102"></a><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a></td><td style="text-align: center"><a href="use-types-2.html">Item 2</a></td><td style="text-align: center"><code>x(a)</code></td><td style="text-align: center"><code>FnMut</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html#tymethod.call"><code>call</code></a></td></tr>
<tr><td style="text-align: left"><a name="a103"></a><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a></td><td style="text-align: center"><a href="use-types-2.html">Item 2</a></td><td style="text-align: center"><code>x(a)</code></td><td style="text-align: center"><code>FnOnce</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html#tymethod.call_mut"><code>call_mut</code></a></td></tr>
<tr><td style="text-align: left"><a name="a104"></a><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></td><td style="text-align: center"><a href="use-types-2.html">Item 2</a></td><td style="text-align: center"><code>x(a)</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html#tymethod.call_once"><code>call_once</code></a></td></tr>
<tr><td style="text-align: left"><a name="a105"></a><a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a></td><td style="text-align: center"><a href="errors.html">Item 4</a></td><td style="text-align: center"></td><td style="text-align: center"><code>Display + Debug</code></td><td style="text-align: left">[<a href="https://doc.rust-lang.org/std/error/trait.Error.html#method.source"><code>source</code></a>]</td></tr>
<tr><td style="text-align: left"><a name="a106"></a><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a></td><td style="text-align: center"><a href="casts.html">Item 6</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.From.html#tymethod.from"><code>from</code></a></td></tr>
<tr><td style="text-align: left"><a name="a107"></a><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a></td><td style="text-align: center"><a href="casts.html">Item 6</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html#tymethod.try_from"><code>try_from</code></a></td></tr>
<tr><td style="text-align: left"><a name="a108"></a><a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a></td><td style="text-align: center"><a href="casts.html">Item 6</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.Into.html#tymethod.into"><code>into</code></a></td></tr>
<tr><td style="text-align: left"><a name="a109"></a><a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a></td><td style="text-align: center"><a href="casts.html">Item 6</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html#tymethod.try_into"><code>try_into</code></a></td></tr>
<tr><td style="text-align: left"><a name="a110"></a><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html#tymethod.as_ref"><code>as_ref</code></a></td></tr>
<tr><td style="text-align: left"><a name="a111"></a><a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html"><code>AsMut</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html#tymethod.as_mut"><code>as_mut</code></a></td></tr>
<tr><td style="text-align: left"><a name="a112"></a><a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html#tymethod.borrow"><code>borrow</code></a></td></tr>
<tr><td style="text-align: left"><a name="a113"></a><a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html"><code>BorrowMut</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"></td><td style="text-align: center"><code>Borrow</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html#tymethod.borrow_mut"><code>borrow_mut</code></a></td></tr>
<tr><td style="text-align: left"><a name="a114"></a><a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html"><code>ToOwned</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned"> <code>to_owned</code></a></td></tr>
<tr><td style="text-align: left"><a name="a115"></a><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"><code>*x</code>, <code>&amp;x</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#tymethod.deref"><code>deref</code></a></td></tr>
<tr><td style="text-align: left"><a name="a116"></a><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"><code>*x</code>, <code>&amp;mut x</code></td><td style="text-align: center"><code>Deref</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html#tymethod.deref_mut"><code>deref_mut</code></a></td></tr>
<tr><td style="text-align: left"><a name="a117"></a><a href="https://doc.rust-lang.org/std/ops/trait.Index.html"><code>Index</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"><code>x[idx]</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Index.html#tymethod.index"><code>index</code></a></td></tr>
<tr><td style="text-align: left"><a name="a118"></a><a href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html"><code>IndexMut</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"><code>x[idx] = ...</code></td><td style="text-align: center"><code>Index</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html#tymethod.index_mut"><code>index_mut</code></a></td></tr>
<tr><td style="text-align: left"><a name="a119"></a><a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html"><code>Pointer</code></a></td><td style="text-align: center"><a href="references.html">Item 9</a></td><td style="text-align: center"><code>format(&quot;{:p}&quot;, x)</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html#tymethod.fmt"><code>fmt</code></a></td></tr>
<tr><td style="text-align: left"><a name="a120"></a><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a></td><td style="text-align: center"><a href="iterators.html">Item 10</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#tymethod.next"><code>next</code></a></td></tr>
<tr><td style="text-align: left"><a name="a121"></a><a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html"><code>IntoIterator</code></a></td><td style="text-align: center"><a href="iterators.html">Item 10</a></td><td style="text-align: center"><code>for y in x</code></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.IntoIterator.html#tymethod.into_iter"><code>into_iter</code></a></td></tr>
<tr><td style="text-align: left"><a name="a122"></a><a href="https://doc.rust-lang.org/core/iter/trait.FromIterator.html"><code>FromIterator</code></a></td><td style="text-align: center"><a href="iterators.html">Item 10</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.FromIterator.html#tymethod.from_iter"><code>from_iter</code></a></td></tr>
<tr><td style="text-align: left"><a name="a123"></a><a href="https://doc.rust-lang.org/core/iter/trait.ExactSizeIterator.html"><code>ExactSizeIterator</code></a></td><td style="text-align: center"><a href="iterators.html">Item 10</a></td><td style="text-align: center"></td><td style="text-align: center"><code>Iterator</code></td><td style="text-align: left">(<a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.size_hint"><code>size_hint</code></a>)</td></tr>
<tr><td style="text-align: left"><a name="a124"></a><a href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a></td><td style="text-align: center"><a href="iterators.html">Item 10</a></td><td style="text-align: center"></td><td style="text-align: center"><code>Iterator</code></td><td style="text-align: left"><a href="https://doc.rust-lang.org/core/iter/trait.DoubleEndedIterator.html#tymethod.next_back"><code>next_back</code></a></td></tr>
<tr><td style="text-align: left"><a name="a125"></a><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a></td><td style="text-align: center"><a href="raii.html">Item 11</a></td><td style="text-align: center"><code>}</code> (end of scope)</td><td style="text-align: center"></td><td style="text-align: left"><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a></td></tr>
<tr><td style="text-align: left"><a name="a126"></a><a href="https://doc.rust-lang.org/std/marker/trait.Sized.html"><code>Sized</code></a></td><td style="text-align: center"><a href="borrows.html">Item 15</a></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: left">Marker trait</td></tr>
<tr><td style="text-align: left"><a name="a127"></a><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a></td><td style="text-align: center"><a href="deadlock.html">Item 17</a></td><td style="text-align: center">cross-thread transfer</td><td style="text-align: center"></td><td style="text-align: left">Marker trait</td></tr>
<tr><td style="text-align: left"><a name="a128"></a><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a></td><td style="text-align: center"><a href="deadlock.html">Item 17</a></td><td style="text-align: center">cross-thread use</td><td style="text-align: center"></td><td style="text-align: left">Marker trait</td></tr>
</tbody></table>
</div><p><hr/>
<p><a name="footnote-1"><a href="#to-footnote-1">1</a></a>: As do
several of the other marker traits in <code>std::marker</code>.</p>
<p><a name="footnote-2"><a href="#to-footnote-2">2</a></a>: Of course, comparing floats
for equality is always a dangerous game, as there is typically no guarantee that rounded calculations will produce a
result that is bit-for-bit identical to the number you first thought of.</p>
<p><a name="footnote-3"><a href="#to-footnote-3">3</a></a>: More generally, any <a name="a054"></a><a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice
structure</a> also has a partial order.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="errors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="casts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="errors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="casts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/third_party/ferris/ferris.js"></script>


    </div>
    </body>
</html>
