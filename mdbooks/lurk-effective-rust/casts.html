<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Item 6: Understand type conversions - Effective Rust</title>


        <!-- Custom HTML head -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-23228806-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
        <meta name="description" content="A collection of specific ways to improve your use of Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/third_party/ferris/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cover.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="use-types.html"><strong aria-hidden="true">3.1.</strong> Item 1: Use the type system to express your data structures</a></li><li class="chapter-item expanded "><a href="use-types-2.html"><strong aria-hidden="true">3.2.</strong> Item 2: Use the type system to express common behaviour</a></li><li class="chapter-item expanded "><a href="transform.html"><strong aria-hidden="true">3.3.</strong> Item 3: Avoid matching Option and Result</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">3.4.</strong> Item 4: Prefer idiomatic Error variants</a></li><li class="chapter-item expanded "><a href="std-traits.html"><strong aria-hidden="true">3.5.</strong> Item 5: Familiarize yourself with standard traits</a></li><li class="chapter-item expanded "><a href="casts.html" class="active"><strong aria-hidden="true">3.6.</strong> Item 6: Understand type conversions</a></li><li class="chapter-item expanded "><a href="newtype.html"><strong aria-hidden="true">3.7.</strong> Item 7: Embrace the newtype pattern</a></li><li class="chapter-item expanded "><a href="builders.html"><strong aria-hidden="true">3.8.</strong> Item 8: Use builders for complex types</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.9.</strong> Item 9: Familiarize yourself with reference and pointer types</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">3.10.</strong> Item 10: Consider using iterator transforms instead of explicit loops</a></li><li class="chapter-item expanded "><a href="raii.html"><strong aria-hidden="true">3.11.</strong> Item 11: Implement the Drop trait for RAII patterns</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">3.12.</strong> Item 12: Prefer generics to trait objects</a></li><li class="chapter-item expanded "><a href="default-impl.html"><strong aria-hidden="true">3.13.</strong> Item 13: Use default implementations to minimize required trait methods</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">4.1.</strong> Item 14: Understand lifetimes</a></li><li class="chapter-item expanded "><a href="borrows.html"><strong aria-hidden="true">4.2.</strong> Item 15: Understand the borrow checker</a></li><li class="chapter-item expanded "><a href="unsafe.html"><strong aria-hidden="true">4.3.</strong> Item 16: Avoid writing unsafe code</a></li><li class="chapter-item expanded "><a href="deadlock.html"><strong aria-hidden="true">4.4.</strong> Item 17: Be wary of shared-state parallelism</a></li><li class="chapter-item expanded "><a href="panic.html"><strong aria-hidden="true">4.5.</strong> Item 18: Don't panic</a></li><li class="chapter-item expanded "><a href="reflection.html"><strong aria-hidden="true">4.6.</strong> Item 19: Avoid reflection</a></li><li class="chapter-item expanded "><a href="optimize.html"><strong aria-hidden="true">4.7.</strong> Item 20: Avoid the temptation to over-optimize</a></li></ol></li><li class="chapter-item expanded "><a href="deps.html"><strong aria-hidden="true">5.</strong> Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="semver.html"><strong aria-hidden="true">5.1.</strong> Item 21: Understand what semantic versioning promises</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.2.</strong> Item 22: Minimize visibility</a></li><li class="chapter-item expanded "><a href="wildcard.html"><strong aria-hidden="true">5.3.</strong> Item 23: Avoid wildcard imports</a></li><li class="chapter-item expanded "><a href="re-export.html"><strong aria-hidden="true">5.4.</strong> Item 24: Re-export dependencies whose types appear in your API</a></li><li class="chapter-item expanded "><a href="dep-graph.html"><strong aria-hidden="true">5.5.</strong> Item 25: Manage your dependency graph</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">5.6.</strong> Item 26: Be wary of feature creep</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">6.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">6.1.</strong> Item 27: Document public interfaces</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">6.2.</strong> Item 28: Use macros judiciously</a></li><li class="chapter-item expanded "><a href="clippy.html"><strong aria-hidden="true">6.3.</strong> Item 29: Listen to Clippy</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.4.</strong> Item 30: Write more than unit tests</a></li><li class="chapter-item expanded "><a href="use-tools.html"><strong aria-hidden="true">6.5.</strong> Item 31: Take advantage of the tooling ecosystem</a></li><li class="chapter-item expanded "><a href="ci.html"><strong aria-hidden="true">6.6.</strong> Item 32: Set up a continuous integration (CI) system</a></li></ol></li><li class="chapter-item expanded "><a href="beyond-std.html"><strong aria-hidden="true">7.</strong> Beyond Standard Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="no-std.html"><strong aria-hidden="true">7.1.</strong> Item 33: Consider making library code no_std compatible</a></li><li class="chapter-item expanded "><a href="ffi.html"><strong aria-hidden="true">7.2.</strong> Item 34: Control what crosses FFI boundaries</a></li><li class="chapter-item expanded "><a href="bindgen.html"><strong aria-hidden="true">7.3.</strong> Item 35: Prefer bindgen to manual FFI mappings</a></li></ol></li><li class="chapter-item expanded "><a href="indexing.html"><strong aria-hidden="true">8.</strong> Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="item-6-understand-type-conversions"><a class="header" href="#item-6-understand-type-conversions">Item 6: Understand type conversions</a></h1>
<p>In general, Rust does not perform automatic conversion between types. This includes integral types, even when the
transformation is &quot;safe&quot;:</p>
<pre><code class="language-rust ignore does_not_compile">        let x: u32 = 2;
        let y: u64 = x;</code></pre>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; casts/src/main.rs:69:22
   |
69 |         let y: u64 = x;
   |                ---   ^ expected `u64`, found `u32`
   |                |
   |                expected due to this
   |
help: you can convert a `u32` to a `u64`
   |
69 |         let y: u64 = x.into();
   |                       +++++++
</code></pre>
<p>Rust type conversions fall into three categories:</p>
<ul>
<li><em>manual</em>: user-defined type conversions provided by implementing the <a name="a001"></a><code>From</code> and <a name="a002"></a><code>Into</code> traits</li>
<li><em>semi-automatic</em>: explicit <strong><a name="a003"></a>casts</strong> between values using the <a name="a004"></a><code>as</code> keyword</li>
<li><em>automatic</em>: implicit <strong><a name="a005"></a>coercion</strong> into a new type.</li>
</ul>
<p>The latter two don't apply to conversions of user defined types (with a couple of exceptions), so the majority of this
Item will focus on manual conversion – which the compiler error message also pointed towards.</p>
<p>However, sections at the end of the Item discuss casting and coercion – including
the exceptions where they can apply to a user-defined type.</p>
<h2 id="user-defined-type-conversions"><a class="header" href="#user-defined-type-conversions">User-Defined Type Conversions</a></h2>
<p>As with other features of the language (<a href="std-traits.html">Item 5</a>) the ability to perform conversions between values of different
user-defined types is encapsulated as a standard trait – or rather, as a set of related <a name="a006"></a>generic traits.</p>
<p>The four relevant traits that express the ability to convert values of a type are:</p>
<ul>
<li><a name="a007"></a><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From&lt;T&gt;</code></a>: Items of this type can be built from
items of type <code>T</code>.</li>
<li><a name="a008"></a><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom&lt;T&gt;</code></a>: Items of this type can
<em>sometimes</em> be built from items of type <code>T</code>.</li>
<li><a name="a009"></a><a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into&lt;T&gt;</code></a>: Items of this type can converted
into items of type <code>T</code>.</li>
<li><a name="a010"></a><a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto&lt;T&gt;</code></a>: Items of this type can
<em>sometimes</em> be converted into items of type <code>T</code>.</li>
</ul>
<p>Given the discussion in <a href="use-types.html">Item 1</a> about expressing things in the type system, it's no surprise to discover that the
difference with the <code>Try...</code> variants is that the sole trait method returns a <a name="a011"></a><code>Result</code> rather than a guaranteed
new item.  The <code>Try...</code> trait definitions also require an <a name="a012"></a>associated type that gives the type of the error <code>E</code>
emitted for failure situations.</p>
<p>The first piece of advice is therefore to <strong>implement (just) the <code>Try...</code> trait if it's possible for a conversion to
fail</strong>, in line with <a href="errors.html">Item 4</a>.  The alternative is to ignore the possibility of error (e.g. with <code>.unwrap()</code>), but that
needs to be a deliberate choice and in most cases it's best to leave that choice to the caller.</p>
<p>The type conversion traits have an obvious symmetry: if a type <code>T</code> can be transmuted <code>into</code> a type <code>U</code>, isn't that the
same as it being possible to create an item of type <code>U</code> by transmutation <code>from</code> an item of type <code>T</code>?</p>
<p>This is indeed the case, and it leads to the second piece of advice: <strong>implement the <code>From</code> trait for conversions</strong>.
The Rust standard library had to pick just one of the two possibilities, in order to prevent the system from spiralling
around in dizzy circles<sup><a name="to-footnote-1"><a href="#footnote-1">1</a></a></sup>, and it came down on the
side of automatically providing <code>Into</code> from a <code>From</code> implementation.</p>
<p>If you're consuming one of these two traits, as a trait bound on a new generic of your own, then the advice is reversed:
<strong>use the <code>Into</code> trait for <a name="a014"></a>trait bounds</strong>.  That way, the bound will be satisfied both by things that directly
implement <code>Into</code>, <em>and</em> by things that only directly implement <code>From</code>.</p>
<p>This automatic conversion is highlighted by the documentation for <code>From</code> and <code>Into</code>, but it's worth reading the relevant
part of the standard library code too, which is a <a name="a015"></a><em>blanket trait implementation</em>:</p>
<pre><code class="language-rust ignore">impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt;,
{
    fn into(self) -&gt; U {
        U::from(self)
    }
}</code></pre>
<p>Translating a trait specification into words can help with understanding more complex trait bounds; in this case, it's
fairly simple: &quot;I can implement <code>Into&lt;U&gt;</code> for a type <code>T</code> whenever <code>U</code> already implements <code>From&lt;T&gt;</code>&quot;.</p>
<p>The standard library also includes various implementations of these conversion traits for standard library types.  As
you'd expect, there are <code>From</code> implementations for safe integral conversions (<code>From&lt;u32&gt; for u64</code>) and <code>TryFrom</code>
implementations when the conversion isn't safe (<code>TryFrom&lt;u64&gt; for u32</code>).</p>
<p>There are also various other blanket trait implementations in addition to the <code>Into</code> version shown above, which
you can find by searching for <code>impl&lt;T&gt; From&lt;T&gt; for ...</code>. These are almost all for <em><a name="a016"></a>smart pointer</em> types,
allowing the smart pointer to be automatically constructed from an instance of the type that it holds, so that methods
that accept smart pointer parameters can also be called with plain old items; more on this below and in <a href="references.html">Item 9</a>.</p>
<p>The <code>TryFrom</code> trait also has a blanket implementation for any type that already implements the <code>Into</code> trait in the
opposite direction – which automatically includes (as above) any type that implements <code>From</code> in the same
direction. In other words, if you can infallibly convert a <code>T</code> into a <code>U</code>, you can also fallibly obtain a <code>U</code> from a
<code>T</code>; as this conversion will always succeed, the associated error type is <sup><a name="to-footnote-2"><a href="#footnote-2">2</a></a></sup>  the helpfully named <a href="https://doc.rust-lang.org/std/convert/enum.Infallible.html"><code>Infallible</code></a>.</p>
<p>There's also one very specific generic implementation of <code>From</code> that sticks out, the <em><a name="a017"></a>reflexive implementation</em>:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; From&lt;T&gt; for T {
    fn from(t: T) -&gt; T {
        t
    }
}</code></pre>
<p>Translating into words, this just says that &quot;given a <code>T</code> I can get a <code>T</code>&quot;. That's such an obvious &quot;well, duh&quot; that it's
worth stopping to understand why this is useful.</p>
<p>Consider a simple newtype <code>struct</code> (<a href="newtype.html">Item 7</a>) and a function that operates on it (ignoring that this function would be
better expressed as a method):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Integer value from an IANA-controlled range.
#[derive(Clone, Copy, Debug)]
pub struct IanaAllocated(pub u64);

/// Indicate whether value is reserved.
pub fn is_iana_reserved(s: IanaAllocated) -&gt; bool {
    s.0 == 0 || s.0 == 65535
}
<span class="boring">}</span></code></pre></pre>
<p>This function can be invoked with instances of the <code>struct</code></p>
<pre><code class="language-rust ignore">    let s = IanaAllocated(1);
    println!(&quot;{:?} reserved? {}&quot;, s, is_iana_reserved(s));
    // output: &quot;IanaAllocated(1) reserved? false&quot;</code></pre>
<p>but even if <code>From&lt;u64&gt;</code> is implemented for the newtype wrapper</p>
<pre><code class="language-rust ignore">impl From&lt;u64&gt; for IanaAllocated {
    fn from(v: u64) -&gt; Self {
        Self(v)
    }
}</code></pre>
<p>the function can't be directly invoked for <code>u64</code> values</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; casts/src/main.rs:82:29
   |
82 |         if is_iana_reserved(42) {
   |                             ^^ expected struct `IanaAllocated`, found integer
</code></pre>
<p>However, a <a name="a018"></a>generic version of the function that accepts (and explicitly converts) anything
satisfying <code>Into&lt;IanaAllocated&gt;</code>:</p>
<pre><code class="language-rust ignore">    pub fn is_iana_reserved&lt;T&gt;(s: T) -&gt; bool
    where
        T: Into&lt;IanaAllocated&gt;,
    {
        let s = s.into();
        s.0 == 0 || s.0 == 65535
    }</code></pre>
<p>allows this use:</p>
<pre><code class="language-rust ignore">        if is_iana_reserved(42) {</code></pre>
<p>With this trait bound in place, the reflexive trait implementation of <code>From&lt;T&gt;</code> makes more sense: it means that the
generic function copes with items which are already <code>IanaAllocated</code> instances, no conversion needed.</p>
<p>This pattern also explains why (and how) Rust code sometimes <em>appears</em> to be doing implicit casts between types: the
combination of <code>From&lt;T&gt;</code> implementations and <code>Into&lt;T&gt;</code> trait bounds leads to code that appears to magically convert at
the call site (but which is still doing safe, explicit, conversions under the covers), This pattern becomes even more
powerful when combined with reference types and their related conversion traits; more in <a href="references.html">Item 9</a>.</p>
<h2 id="casts"><a class="header" href="#casts">Casts</a></h2>
<p>Rust includes the <a name="a019"></a><code>as</code> keyword to perform explicit
<a name="a020"></a><a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions"><strong>casts</strong></a> between
some pairs of types.</p>
<p>The pairs of types that can be converted in this way is a fairly limited set, and the only user-defined types it
includes are &quot;C-like&quot; <a name="a021"></a><code>enum</code>s (those that have just an associated integer value). General integral conversions are
included though, giving an alternative to <code>into()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x: u32 = 9;
    let y = x as u64;
    let z: u64 = x.into();
<span class="boring">}</span></code></pre></pre>
<p>The <code>as</code> version also allows lossy conversions<sup><a name="to-footnote-3"><a href="#footnote-3">3</a></a></sup>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x: u32 = 9;
    let y = x as u16;
<span class="boring">}</span></code></pre></pre>
<p>which would be rejected by the <code>from</code> / <code>into</code> versions:</p>
<pre><code class="language-text">error[E0277]: the trait bound `u16: From&lt;u32&gt;` is not satisfied
   --&gt; casts/src/main.rs:124:20
    |
124 |     let y: u16 = x.into();
    |                    ^^^^ the trait `From&lt;u32&gt;` is not implemented for `u16`
    |
    = help: the following implementations were found:
              &lt;u16 as From&lt;NonZeroU16&gt;&gt;
              &lt;u16 as From&lt;bool&gt;&gt;
              &lt;u16 as From&lt;u8&gt;&gt;
              &lt;f32 as From&lt;i16&gt;&gt;
            and 71 others
    = note: required because of the requirements on the impl of `Into&lt;u16&gt;` for `u32`
</code></pre>
<p>For consistency and safety you should <strong>prefer <code>from</code> / <code>into</code> conversions to <code>as</code> casts</strong>, unless you understand and
need the precise <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#semantics">casting semantics</a> (e.g
for C interoperability).</p>
<h2 id="coercion"><a class="header" href="#coercion">Coercion</a></h2>
<p>The explicit <code>as</code> casts described in the previous section are a superset of the implicit
<a href="https://doc.rust-lang.org/reference/type-coercions.html"><strong>coercions</strong></a> that the compiler will silently perform:
any <a name="a022"></a>coercion can be forced with an explicit <code>as</code>, but the converse is not true.  In particular, the integral
conversions performed in the previous section are not coercions, and so will always require <code>as</code>.</p>
<p>Most of the coercions involve silent conversions of pointer and reference types in ways that are sensible and convenient
for the programmer, such as:</p>
<ul>
<li>converting a mutable reference to a non-mutable references (so you can use a <code>&amp;mut T</code> as the argument to a function
that takes a <code>&amp;T</code>)</li>
<li>converting a reference to a raw pointer (this isn't <code>unsafe</code> – the unsafety happens at the point where you're
foolish enough to <em>use</em> a raw pointer)</li>
<li>converting a closure that happens not to capture any variables into a bare function pointer (<a href="use-types-2.html">Item 2</a>)</li>
<li>converting an <a href="https://doc.rust-lang.org/std/primitive.array.html">array</a> to a
<a href="https://doc.rust-lang.org/std/primitive.slice.html">slice</a></li>
<li>converting a concrete item to a <a href="https://doc.rust-lang.org/reference/types/trait-object.html">trait object</a>, for a
trait that the concrete item implements</li>
<li>converting<sup><a name="to-footnote-4"><a href="#footnote-4">4</a></a></sup> an item lifetime to a &quot;shorter&quot; one (<a href="lifetimes.html">Item 14</a>).</li>
</ul>
<p>There are only two coercions whose behaviour can be affected by user-defined types. The first of these is when a
user-defined type implements the <a name="a023"></a><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> or the
<a name="a024"></a><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a> trait.  These traits indicate that the user defined
type is acting as a <em>smart pointer</em> of some sort (<a href="references.html">Item 9</a>), and in this case the compiler will coerce a reference to
the smart pointer item into being a reference to an item of the type that the smart pointer contains (indicated by
its <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#associatedtype.Target"><code>Target</code></a>).</p>
<p>The second coercion of a user-defined type happens when a concrete item is converted to a <em><a name="a025"></a>trait object</em>. This
operation builds a <a name="a026"></a>fat pointer to the item; this pointer is fat because it includes both a pointer to the item's
location in memory, together with a pointer to the <em><a name="a027"></a>vtable</em> for the concrete type's implementation of the trait
– see <a href="references.html">Item 9</a>.</p>
<p><hr/>
<p><a name="footnote-1"><a href="#to-footnote-1">1</a></a>: More properly known as the <em><a name="a013"></a>trait coherence rules</em>.</p>
<p><a name="footnote-2"><a href="#to-footnote-2">2</a></a>: For now – this is
likely to be replaced with the <a href="https://doc.rust-lang.org/std/primitive.never.html"><code>!</code> &quot;never&quot; type</a> in a future
version of Rust.</p>
<p><a name="footnote-3"><a href="#to-footnote-3">3</a></a>: Allowing lossy conversions in Rust was probably a mistake, and
there have been <a href="https://internals.rust-lang.org/t/lets-deprecate-as-for-lossy-numeric-casts/16283">discussions</a> around
trying to remove this behaviour.</p>
<p><a name="footnote-4"><a href="#to-footnote-4">4</a></a>: Rust refers to these conversions as
<a href="https://doc.rust-lang.org/reference/subtyping.html">&quot;subtyping&quot;</a>, but it's quite different that the definition of
&quot;subtyping&quot; used in object-oriented languages.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="std-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="newtype.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="std-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="newtype.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/third_party/ferris/ferris.js"></script>


    </div>
    </body>
</html>
