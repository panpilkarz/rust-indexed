<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Item 21: Understand what semantic versioning promises - Effective Rust</title>


        <!-- Custom HTML head -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-23228806-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
        <meta name="description" content="A collection of specific ways to improve your use of Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/third_party/ferris/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cover.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="use-types.html"><strong aria-hidden="true">3.1.</strong> Item 1: Use the type system to express your data structures</a></li><li class="chapter-item expanded "><a href="use-types-2.html"><strong aria-hidden="true">3.2.</strong> Item 2: Use the type system to express common behaviour</a></li><li class="chapter-item expanded "><a href="transform.html"><strong aria-hidden="true">3.3.</strong> Item 3: Avoid matching Option and Result</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">3.4.</strong> Item 4: Prefer idiomatic Error variants</a></li><li class="chapter-item expanded "><a href="std-traits.html"><strong aria-hidden="true">3.5.</strong> Item 5: Familiarize yourself with standard traits</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">3.6.</strong> Item 6: Understand type conversions</a></li><li class="chapter-item expanded "><a href="newtype.html"><strong aria-hidden="true">3.7.</strong> Item 7: Embrace the newtype pattern</a></li><li class="chapter-item expanded "><a href="builders.html"><strong aria-hidden="true">3.8.</strong> Item 8: Use builders for complex types</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.9.</strong> Item 9: Familiarize yourself with reference and pointer types</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">3.10.</strong> Item 10: Consider using iterator transforms instead of explicit loops</a></li><li class="chapter-item expanded "><a href="raii.html"><strong aria-hidden="true">3.11.</strong> Item 11: Implement the Drop trait for RAII patterns</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">3.12.</strong> Item 12: Prefer generics to trait objects</a></li><li class="chapter-item expanded "><a href="default-impl.html"><strong aria-hidden="true">3.13.</strong> Item 13: Use default implementations to minimize required trait methods</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">4.1.</strong> Item 14: Understand lifetimes</a></li><li class="chapter-item expanded "><a href="borrows.html"><strong aria-hidden="true">4.2.</strong> Item 15: Understand the borrow checker</a></li><li class="chapter-item expanded "><a href="unsafe.html"><strong aria-hidden="true">4.3.</strong> Item 16: Avoid writing unsafe code</a></li><li class="chapter-item expanded "><a href="deadlock.html"><strong aria-hidden="true">4.4.</strong> Item 17: Be wary of shared-state parallelism</a></li><li class="chapter-item expanded "><a href="panic.html"><strong aria-hidden="true">4.5.</strong> Item 18: Don't panic</a></li><li class="chapter-item expanded "><a href="reflection.html"><strong aria-hidden="true">4.6.</strong> Item 19: Avoid reflection</a></li><li class="chapter-item expanded "><a href="optimize.html"><strong aria-hidden="true">4.7.</strong> Item 20: Avoid the temptation to over-optimize</a></li></ol></li><li class="chapter-item expanded "><a href="deps.html"><strong aria-hidden="true">5.</strong> Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="semver.html" class="active"><strong aria-hidden="true">5.1.</strong> Item 21: Understand what semantic versioning promises</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.2.</strong> Item 22: Minimize visibility</a></li><li class="chapter-item expanded "><a href="wildcard.html"><strong aria-hidden="true">5.3.</strong> Item 23: Avoid wildcard imports</a></li><li class="chapter-item expanded "><a href="re-export.html"><strong aria-hidden="true">5.4.</strong> Item 24: Re-export dependencies whose types appear in your API</a></li><li class="chapter-item expanded "><a href="dep-graph.html"><strong aria-hidden="true">5.5.</strong> Item 25: Manage your dependency graph</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">5.6.</strong> Item 26: Be wary of feature creep</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">6.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">6.1.</strong> Item 27: Document public interfaces</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">6.2.</strong> Item 28: Use macros judiciously</a></li><li class="chapter-item expanded "><a href="clippy.html"><strong aria-hidden="true">6.3.</strong> Item 29: Listen to Clippy</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.4.</strong> Item 30: Write more than unit tests</a></li><li class="chapter-item expanded "><a href="use-tools.html"><strong aria-hidden="true">6.5.</strong> Item 31: Take advantage of the tooling ecosystem</a></li><li class="chapter-item expanded "><a href="ci.html"><strong aria-hidden="true">6.6.</strong> Item 32: Set up a continuous integration (CI) system</a></li></ol></li><li class="chapter-item expanded "><a href="beyond-std.html"><strong aria-hidden="true">7.</strong> Beyond Standard Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="no-std.html"><strong aria-hidden="true">7.1.</strong> Item 33: Consider making library code no_std compatible</a></li><li class="chapter-item expanded "><a href="ffi.html"><strong aria-hidden="true">7.2.</strong> Item 34: Control what crosses FFI boundaries</a></li><li class="chapter-item expanded "><a href="bindgen.html"><strong aria-hidden="true">7.3.</strong> Item 35: Prefer bindgen to manual FFI mappings</a></li></ol></li><li class="chapter-item expanded "><a href="indexing.html"><strong aria-hidden="true">8.</strong> Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="item-21-understand-what-semantic-versioning-promises"><a class="header" href="#item-21-understand-what-semantic-versioning-promises">Item 21: Understand what semantic versioning promises</a></h1>
<blockquote>
<p>&quot;If we acknowledge that SemVer is a lossy estimate and represents only a subset of the possible scope of changes, we
can begin to see it as a blunt instrument.&quot; – <a name="a001"></a>Titus Winters, &quot;<a href="https://abseil.io/resources/swe-book/html/ch21.html#the_limitations_of_semver">Software Engineering at
Google</a>&quot;</p>
</blockquote>
<p><a name="a002"></a>Cargo, Rust's package manager, allows automatic selection of dependencies (<a href="dep-graph.html">Item 25</a>) for Rust code according to
<em><a name="a003"></a>semantic versioning</em> (semver).  A <a name="a004"></a><code>Cargo.toml</code> stanza like</p>
<pre><code class="language-toml">[dependencies]
serde = &quot;1.0.*&quot;
</code></pre>
<p>indicates to <code>cargo</code> what ranges of semver versions are acceptable for this dependency (see the <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">official
docs</a> for more detail on specifying precise
ranges of acceptable versions).</p>
<p>When choosing dependency versions, Cargo will then generally pick the most recent version that's within the combination
of all of these semver ranges.  However, if the <a name="a005"></a><a href="https://doc.rust-lang.org/cargo/reference/unstable.html#minimal-versions"><code>-Z minimal-versions</code>
flag</a> is passed to Cargo, it will instead pick
the <em>oldest</em> version of each dependency that satisfies the semver ranges; <strong>consider including a <code>-Z minimal-versions</code>
build</strong> in your CI system (<a href="ci.html">Item 32</a>) to confirm that the lower bounds of the semver ranges are accurate.</p>
<p>Because semantic versioning is at the heart of <code>cargo</code>'s dependency resolution process, this Item explores more
details about what that means.</p>
<p>The essentials of semantic versioning are given by its <a href="https://semver.org/#summary">summary</a></p>
<blockquote>
<p>Given a version number MAJOR.MINOR.PATCH, increment the:</p>
<ul>
<li>MAJOR version when you make incompatible API changes,</li>
<li>MINOR version when you add functionality in a backwards compatible manner, and</li>
<li>PATCH version when you make backwards compatible bug fixes.</li>
</ul>
</blockquote>
<p>An important detail lurks in the <a href="https://semver.org/#spec-item-3">details</a>:</p>
<blockquote>
<ol start="3">
<li>Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications
MUST be released as a new version.</li>
</ol>
</blockquote>
<p>Putting this in different words:</p>
<ul>
<li>Changing <em>anything</em> requires a new PATCH version.</li>
<li><em>Adding</em> things to the API in a way that means existing users of the crate still compile and work requires a MINOR
version upgrade.</li>
<li><em>Removing</em> or <em>changing</em> things in the API requires a MAJOR version upgrade.</li>
</ul>
<p>There is one more important <a href="https://semver.org/#spec-item-3">codicil</a> to the semver rules:</p>
<blockquote>
<ol start="4">
<li>Major version zero (0.y.z) is for initial development. Anything MAY change at any time. The public API SHOULD NOT
be considered stable.</li>
</ol>
</blockquote>
<p>Cargo adapts these rules slightly, &quot;left-shifting&quot; the rules so that changes in the left-most non-zero component
indicate incompatible changes.  This means that 0.2.3 to 0.3.0 can include an incompatible API change, as can 0.0.4 to
0.0.5.</p>
<h2 id="semver-for-crate-authors"><a class="header" href="#semver-for-crate-authors">Semver for Crate Authors</a></h2>
<blockquote>
<p>&quot;In theory, theory is the same as practice. In practice, it's not.&quot;</p>
</blockquote>
<p>As a crate author, the first of these rules is easy to comply with, in theory: if you touch anything, you need a new
release. Using <a name="a006"></a>Git <a href="https://git-scm.com/docs/git-tag"><em>tags</em></a> to match releases can help with this
– by default, a tag is fixed to a particular commit and can only be moved with a manual <code>--force</code> option. Crates
published to <a name="a007"></a><a href="https://crates.io"><code>crates.io</code></a> also get automatic policing of this, as the registry will reject a
second attempt to publish the same crate version. The main danger for non-compliance is when you notice a mistake <em>just
after</em> a release has gone out, and you have to resist the temptation to just nip in a fix.</p>
<p>However, if your crate is widely depended on, then in practice you may need to be aware of <a name="a008"></a><a href="https://www.hyrumslaw.com/">Hyrum's
Law</a>: regardless of how minor a change you make to the code, someone out there is likely
to depend on the old behaviour.</p>
<p>The difficult part for crate authors is the later rules, which require an accurate determination of whether a change is
back compatible or not.  Some changes are obviously incompatible – removing public entrypoints or types, changing
method signatures – and some changes are obviously backwards compatible (e.g. adding a new method to a <code>struct</code>,
or adding a new constant), but there's a lot of gray area left in between.</p>
<p>To help with this, the Cargo book goes into <a href="https://doc.rust-lang.org/cargo/reference/semver.html#change-categories">considerable
detail</a> as to what is and is not
<a name="a009"></a>back-compatible. Most of these details are unsurprising, but there are a few areas worth
highlighting.</p>
<ul>
<li>Adding new items is <em>usually</em> safe, but may cause clashes if code using the crate already makes use of something that
happens to have the same name as the new item.
<ul>
<li>This is a particular danger if the user does a <a name="a010"></a><a href="https://doc.rust-lang.org/cargo/reference/semver.html#minor-adding-new-public-items">wildcard import from the
crate</a>, because all of the
crate's items are then automatically in the user's main namespace. <a href="wildcard.html">Item 23</a> advises against doing this.</li>
<li>Even without a wildcard import, a <a href="https://doc.rust-lang.org/cargo/reference/semver.html#possibly-breaking-adding-a-defaulted-trait-item">new trait
method</a> (with
a <a name="a011"></a>default implementation, <a href="default-impl.html">Item 13</a>) or a <a href="https://doc.rust-lang.org/cargo/reference/semver.html#possibly-breaking-change-adding-any-inherent-items">new inherent
method</a>
has a chance of clashing with an existing name.</li>
</ul>
</li>
<li>Rust's insistence on covering all possibilities means that changing the set of available possibilities can be a
breaking change.
<ul>
<li>Performing a <a name="a012"></a><code>match</code> on an <a name="a013"></a><code>enum</code> must cover all possibilities, so if a <a href="https://doc.rust-lang.org/cargo/reference/semver.html#major-adding-new-enum-variants-without-non_exhaustive">crate adds a new <code>enum</code>
variant</a>,
that's a breaking change (unless the enum is marked as
<a name="a014"></a><a href="https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a>).</li>
<li>Explicitly creating an instance of a <a name="a015"></a><code>struct</code> requires an initial value for all fields, so <a href="https://doc.rust-lang.org/cargo/reference/semver.html#major-adding-a-public-field-when-no-private-field-exists">adding a field to a
structure that can be publically
instantiated</a>
is a breaking change.  Structures that have private fields are OK, because crate users can't explicitly construct
them anyway; a <code>struct</code> can also be marked as <code>non_exhaustive</code> to prevent external users performing explicit
construction.</li>
</ul>
</li>
<li>Changing a trait so it is <a name="a016"></a><a href="https://doc.rust-lang.org/cargo/reference/semver.html#trait-object-safety">no longer <em>object
safe</em></a> (<a href="use-types-2.html">Item 2</a>) is a breaking change; any
users that build trait objects for the trait will stop being able to compile their code.</li>
<li>Adding a new <a name="a017"></a>blanket implementation for a trait is a breaking change; any users that already implement the trait
will now have two conflicting implementations.</li>
<li>Changing the <em><a name="a018"></a>license</em> of an open-source crate is an incompatible change: users of your crate who have strict
restrictions on what licenses are acceptable may be broken by the change. <strong>Consider the license to be part of your
API</strong>.</li>
<li>Changing the <a name="a019"></a>default features (<a href="features.html">Item 26</a>) of a crate is potentially a breaking change. Removing a default
<a name="a020"></a>feature is almost certain to break things (unless the feature was already a no-op); adding a default feature may
break things depending on what it enables.  <strong>Consider the default feature set to be part of your API</strong>.</li>
<li>Changing library code so that it uses a new feature of Rust <em>might</em> be an incompatible change, because users of your
crate who have not yet upgraded their compiler to a version that includes the feature will be broken by the change.
However, most Rust crates treat a MSRV increase as a <a href="https://github.com/rust-lang/api-guidelines/discussions/231"><em>non</em>-breaking
change</a>, so <strong>consider whether the <a name="a021"></a>minimum supported
Rust version (MSRV) forms part of your API</strong>.</li>
</ul>
<p>An obvious corollary of the rules is this: the fewer public items a crate has, the fewer things there are that can
induce an incompatible change (<a href="visibility.html">Item 22</a>).</p>
<p>However, there's no escaping the fact that comparing all public API items for compatibility from one release to the next
is a time-consuming process that is only likely to yield an <em>approximate</em> (major/minor/patch) assessment of the level of
change, at best. Given that this comparison is a somewhat mechanical process, hopefully tooling (<a href="use-tools.html">Item 31</a>) will arrive to
make the process easier<sup><a name="to-footnote-1"><a href="#footnote-1">1</a></a></sup>.</p>
<p>If you do need to make an incompatible MAJOR version change, it's nice to make life easier for your users by ensuring
that the same overall functionality is available after the change, even if the API has radically changed.  If possible,
the most helpful sequence for your crate users is to:</p>
<ul>
<li>Release a MINOR version update that includes the new version of the API, and which marks the older variant as
<a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a>, including an
indication of how to migrate.</li>
<li>Subsequently release a MAJOR version update that removes the deprecated parts of the API.</li>
</ul>
<p>A more subtle point is: <strong>make breaking changes breaking</strong>. If your crate is changing its behaviour in a
way that's actually incompatible for existing users, but which <em>could</em> re-use the same API: don't.  Force a change in
types (and a MAJOR version bump) to ensure that users can't inadvertantly use the new version incorrectly.</p>
<p>For the less tangible parts of your API – such as the <a name="a023"></a><a href="https://github.com/rust-lang/rust/issues/65262">MSRV</a>
or the license – consider setting up a <a name="a024"></a>continuous integration check (<a href="ci.html">Item 32</a>) that detects changes, using tooling
(e.g. <a name="a025"></a><code>cargo-deny</code>, see <a href="use-tools.html">Item 31</a>) as needed.</p>
<p>Finally, don't be afraid of version 1.0.0 because it's a commitment that your API is now fixed. Lots of crates fall into
the trap of staying at version 0.x forever, but that reduces the already-limited expressivity of semver from three
categories (major/minor/patch) to two (effective-major/effective-minor).</p>
<h2 id="semver-for-crate-users"><a class="header" href="#semver-for-crate-users">Semver for Crate Users</a></h2>
<p>As a user of a crate, the <em>theoretical</em> expectations for a new version of a dependency are:</p>
<ul>
<li>A new PATCH version of a dependency crate Should Just Work™.</li>
<li>A new MINOR version of a dependency crate Should Just Work™, but the new parts of the API might be worth
exploring to see if there are cleaner/better ways of using the crate now.  However, if you do use the new parts you
won't be able to revert the dependency back to the old version.</li>
<li>All bets are off for a new MAJOR version of a dependency; chances are that your code will no longer compile and you'll
need to re-write parts of your code to comply with the new API.  Even if your code does still compile, you should
<strong>check that your use of the API is still valid after a MAJOR version change</strong>, because the constraints and
preconditions of the library may have changed.</li>
</ul>
<p>In practice, even the first two types of change <em>may</em> cause unexpected behaviour changes, even in code that still
compiles fine, due to <a name="a026"></a>Hyrum's Law.</p>
<p>As a consequence of these expectations, your dependency specifications will commonly take a form like <code>&quot;1.4.*&quot;</code> or
<code>&quot;0.7.*&quot;</code>; <strong>avoid specifying a completely <a name="a027"></a>wildcard dependency</strong> like <code>&quot;*&quot;</code> or <code>&quot;0.*&quot;</code>. A completely wildcard
dependency says that <em>any</em> version of the dependency, with <em>any</em> API, can be used by your crate – which is
unlikely to be what you really want.</p>
<p>However, in the longer term it's not safe to just ignore major version changes in dependencies.  Once a library has had
a major version change, the chances are that no further <a name="a028"></a>bug fixes – and more importantly, security updates
– will be made to the previous major version.  A version specification like <code>&quot;1.4.*&quot;</code> will then fall further and
further behind, with any security problems left unaddressed.</p>
<p>As a result, you either need to accept the risks of being stuck on an old version, or you need to <strong>eventually follow
major version upgrades to your dependencies</strong>.  Tools such as <code>cargo update</code> or
<a name="a029"></a><a href="https://dependabot.com/">Dependabot</a> (<a href="use-tools.html">Item 31</a>), can let you know when updates are available; you can then
schedule the upgrade for a time that's convenient for you.</p>
<h2 id="discussion"><a class="header" href="#discussion">Discussion</a></h2>
<p>Semantic versioning has a cost: every change to a crate has to be assessed against its criteria, to decide the
appropriate type of version bump.  Semantic versioning is also a blunt tool: at best, it reflects a crate owner's guess
as to which of three categories the current release falls into.  Not everyone gets it right, not everything is
clear-cut about exactly what &quot;right&quot; means, and even if you get it right, there's always a chance you may fall foul of
Hyrum's Law.</p>
<p>However, semver is the only game in town for anyone who doesn't have the luxury of working in a <a href="https://dl.acm.org/doi/pdf/10.1145/2854146">highly-tested monorepo
that contains all the code in the world</a>.  As such, understanding its
concepts and limitations is necessary for managing dependencies.</p>
<p><hr/>
<p><a name="footnote-1"><a href="#to-footnote-1">1</a></a>: <a name="a022"></a><a href="https://github.com/rust-lang/rust-semverver"><code>rust-semverver</code></a> is a tool
that attempts to do something along these lines.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="deps.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="visibility.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="deps.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="visibility.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/third_party/ferris/ferris.js"></script>


    </div>
    </body>
</html>
