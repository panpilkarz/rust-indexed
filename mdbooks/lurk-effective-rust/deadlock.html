<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Item 17: Be wary of shared-state parallelism - Effective Rust</title>


        <!-- Custom HTML head -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-23228806-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
        <meta name="description" content="A collection of specific ways to improve your use of Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/third_party/ferris/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cover.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="use-types.html"><strong aria-hidden="true">3.1.</strong> Item 1: Use the type system to express your data structures</a></li><li class="chapter-item expanded "><a href="use-types-2.html"><strong aria-hidden="true">3.2.</strong> Item 2: Use the type system to express common behaviour</a></li><li class="chapter-item expanded "><a href="transform.html"><strong aria-hidden="true">3.3.</strong> Item 3: Avoid matching Option and Result</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">3.4.</strong> Item 4: Prefer idiomatic Error variants</a></li><li class="chapter-item expanded "><a href="std-traits.html"><strong aria-hidden="true">3.5.</strong> Item 5: Familiarize yourself with standard traits</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">3.6.</strong> Item 6: Understand type conversions</a></li><li class="chapter-item expanded "><a href="newtype.html"><strong aria-hidden="true">3.7.</strong> Item 7: Embrace the newtype pattern</a></li><li class="chapter-item expanded "><a href="builders.html"><strong aria-hidden="true">3.8.</strong> Item 8: Use builders for complex types</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.9.</strong> Item 9: Familiarize yourself with reference and pointer types</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">3.10.</strong> Item 10: Consider using iterator transforms instead of explicit loops</a></li><li class="chapter-item expanded "><a href="raii.html"><strong aria-hidden="true">3.11.</strong> Item 11: Implement the Drop trait for RAII patterns</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">3.12.</strong> Item 12: Prefer generics to trait objects</a></li><li class="chapter-item expanded "><a href="default-impl.html"><strong aria-hidden="true">3.13.</strong> Item 13: Use default implementations to minimize required trait methods</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">4.1.</strong> Item 14: Understand lifetimes</a></li><li class="chapter-item expanded "><a href="borrows.html"><strong aria-hidden="true">4.2.</strong> Item 15: Understand the borrow checker</a></li><li class="chapter-item expanded "><a href="unsafe.html"><strong aria-hidden="true">4.3.</strong> Item 16: Avoid writing unsafe code</a></li><li class="chapter-item expanded "><a href="deadlock.html" class="active"><strong aria-hidden="true">4.4.</strong> Item 17: Be wary of shared-state parallelism</a></li><li class="chapter-item expanded "><a href="panic.html"><strong aria-hidden="true">4.5.</strong> Item 18: Don't panic</a></li><li class="chapter-item expanded "><a href="reflection.html"><strong aria-hidden="true">4.6.</strong> Item 19: Avoid reflection</a></li><li class="chapter-item expanded "><a href="optimize.html"><strong aria-hidden="true">4.7.</strong> Item 20: Avoid the temptation to over-optimize</a></li></ol></li><li class="chapter-item expanded "><a href="deps.html"><strong aria-hidden="true">5.</strong> Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="semver.html"><strong aria-hidden="true">5.1.</strong> Item 21: Understand what semantic versioning promises</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.2.</strong> Item 22: Minimize visibility</a></li><li class="chapter-item expanded "><a href="wildcard.html"><strong aria-hidden="true">5.3.</strong> Item 23: Avoid wildcard imports</a></li><li class="chapter-item expanded "><a href="re-export.html"><strong aria-hidden="true">5.4.</strong> Item 24: Re-export dependencies whose types appear in your API</a></li><li class="chapter-item expanded "><a href="dep-graph.html"><strong aria-hidden="true">5.5.</strong> Item 25: Manage your dependency graph</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">5.6.</strong> Item 26: Be wary of feature creep</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">6.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">6.1.</strong> Item 27: Document public interfaces</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">6.2.</strong> Item 28: Use macros judiciously</a></li><li class="chapter-item expanded "><a href="clippy.html"><strong aria-hidden="true">6.3.</strong> Item 29: Listen to Clippy</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.4.</strong> Item 30: Write more than unit tests</a></li><li class="chapter-item expanded "><a href="use-tools.html"><strong aria-hidden="true">6.5.</strong> Item 31: Take advantage of the tooling ecosystem</a></li><li class="chapter-item expanded "><a href="ci.html"><strong aria-hidden="true">6.6.</strong> Item 32: Set up a continuous integration (CI) system</a></li></ol></li><li class="chapter-item expanded "><a href="beyond-std.html"><strong aria-hidden="true">7.</strong> Beyond Standard Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="no-std.html"><strong aria-hidden="true">7.1.</strong> Item 33: Consider making library code no_std compatible</a></li><li class="chapter-item expanded "><a href="ffi.html"><strong aria-hidden="true">7.2.</strong> Item 34: Control what crosses FFI boundaries</a></li><li class="chapter-item expanded "><a href="bindgen.html"><strong aria-hidden="true">7.3.</strong> Item 35: Prefer bindgen to manual FFI mappings</a></li></ol></li><li class="chapter-item expanded "><a href="indexing.html"><strong aria-hidden="true">8.</strong> Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="item-17-be-wary-of-shared-state-parallelism"><a class="header" href="#item-17-be-wary-of-shared-state-parallelism">Item 17: Be wary of shared-state parallelism</a></h1>
<blockquote>
<p>&quot;Even the most daring forms of sharing are guaranteed safe in Rust.&quot; – <a name="a001"></a><a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Aaron
Turon</a></p>
</blockquote>
<p>The official documentation describes Rust as enabling <a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">&quot;fearless
concurrency&quot;</a> but this Item will explore why (sadly) there are
still some <a name="a002"></a>reasons to be afraid.</p>
<p>This Item is specific to <em><a name="a003"></a>shared-state</em> parallelism: where different threads of execution communicate with each
other by sharing memory.</p>
<h2 id="data-races"><a class="header" href="#data-races">Data Races</a></h2>
<p>Let's start with the good news, by exploring <em><a name="a004"></a>data races</em> and Rust. The definition is roughly:</p>
<blockquote>
<p>A data race is defined to occur when two distinct threads access the same memory location, where</p>
<ul>
<li>at least one of them is a write, and</li>
<li>there is no synchronization mechanism that enforces an ordering on the accesses.</li>
</ul>
</blockquote>
<p>The basics of this are best illustrated with an example:</p>
<pre><code class="language-c++">// C++ code.
class BankAccount {
 public:
  BankAccount() : balance_(0) {}

  int64_t balance() const {
    return balance_;
  }
  void deposit(uint32_t amount) {
    balance_ += amount;
  }
  bool withdraw(uint32_t amount) {
    if (balance_ &lt; amount) {
      return false;
    }
    // What if another thread changes `balance_` at this point?
    std::this_thread::sleep_for(std::chrono::milliseconds(500));

    balance_ -= amount;
    return true;
  }

 private:
  int64_t balance_;
};
</code></pre>
<p>This example is in <a name="a005"></a>C++, not Rust, for reasons which will become clear shortly.  However, the same general concepts apply
in lots of other languages (that aren't Rust) – <a name="a006"></a>Java, or <a name="a007"></a>Go, or <a name="a008"></a>Python …</p>
<p>This class works fine in a single-threaded setting, but in a multi-threaded setting:</p>
<pre><code class="language-c++">  std::thread taker(take_out, &amp;account, 100);
  std::thread taker2(take_out, &amp;account, 100);
  std::thread taker3(take_out, &amp;account, 100);
  std::thread payer(pay_in, &amp;account, 300);
</code></pre>
<p>where several threads are repeatedly trying to withdraw from the account:</p>
<pre><code class="language-c++">int64_t check_balance(const BankAccount* account) {
    int64_t bal = account-&gt;balance();
    if (bal &lt; 0) {
      std::cerr &lt;&lt; &quot;** Oh no, gone overdrawn: &quot; &lt;&lt; bal &lt;&lt; &quot; **!\n&quot;;
      abort();
    }
    std::cout &lt;&lt; &quot;Balance now &quot; &lt;&lt; bal &lt;&lt; &quot;\n&quot;;
    return bal;
}
</code></pre>
<pre><code class="language-c++">void take_out(BankAccount* account, int count) {
  for (int ii = 0; ii &lt; count; ii++) {
    if (account-&gt;withdraw(100)) {
      log(&quot;Withdrew 100&quot;);
    } else {
      log(&quot;Failed to withdraw 100&quot;);
    }
    check_balance(account);
    std::this_thread::sleep_for(std::chrono::milliseconds(6));
  }
}
</code></pre>
<p>then eventually things will go wrong.</p>
<pre><code class="language-text">** Oh no, gone overdrawn: -100 **!
</code></pre>
<p>The problem isn't hard to spot, particularly with the helpful comment in the <code>withdraw()</code> method: when multiple threads
are involved, the value of the balance can change between the check and the modification. However, real-world <a name="a009"></a>bugs
of this sort are much harder to spot – particularly if the compiler is allowed to perform all kinds of tricks and
re-orderings of code under the covers (as is the case for C++).</p>
<p>The <a name="a010"></a><code>sleep</code> call also artificially raises the chances of this bug being hit and thus detected early; when these problems
are encountered in the wild they're likely to occur rarely and intermittently – making them very hard to debug.</p>
<p>The <code>BankAccount</code> class is <em><a name="a011"></a>thread-compatible</em>, which means that it can be used in a multithreaded environment as long
as the users of class ensure that access to it is governed by some kind of external synchronization mechanism.</p>
<p>The class can be converted to a <em><a name="a012"></a>thread-safe</em> class<sup><a name="to-footnote-1"><a href="#footnote-1">1</a></a></sup> – meaning that it is safe to use from multiple threads – by adding internal synchronization
operations:</p>
<pre><code class="language-c++">// C++ code.
class BankAccount {
 public:
  BankAccount() : balance_(0) {}

  int64_t balance() const {
    const std::lock_guard&lt;std::mutex&gt; with_lock(mu_);
    return balance_;
  }
  void deposit(uint32_t amount) {
    const std::lock_guard&lt;std::mutex&gt; with_lock(mu_);
    balance_ += amount;
  }
  bool withdraw(uint32_t amount) {
    const std::lock_guard&lt;std::mutex&gt; with_lock(mu_);
    if (balance_ &lt; amount) {
      return false;
    }
    // What if another thread changes `balance_` at this point?
    balance_ -= amount;
    return true;
  }

 private:
  mutable std::mutex mu_;
  int64_t balance_;
};
</code></pre>
<p>The internal <code>balance_</code> field is now protected by a <em>mutex</em> <code>mu_</code>: a synchronization object that ensures that only one
thread can successfully <code>lock()</code> at a time. The second and subsequent callers will block until <code>unlock()</code> is called
– and even then, only <em>one</em> of the blocked threads will unblock and proceed through <code>lock()</code>.</p>
<p>All access to the balance now takes place with the mutex held, ensuring that its value is consistent between check and
modification. The <a name="a014"></a><a href="https://en.cppreference.com/w/cpp/thread/lock_guard"><code>std::lock_guard</code></a> is
also worth highlighting: it's an <a name="a015"></a>RAII class (cf. <a href="raii.html">Item 11</a>) that ensures that the mutex is unlocked when the scope
exits, reducing the chances of making a mistake around balancing manual <code>lock()</code> and <code>unlock()</code> calls.</p>
<p>However, the thread-safety here is still fragile; all it takes is one erroneous modification to the class:</p>
<pre><code class="language-c++">  bool transfer(BankAccount* destination, uint32_t amount) {
    // oops, forgot about mu_
    if (balance_ &lt; amount) {
      return false;
    }
    balance_ -= amount;
    destination-&gt;balance_ += amount;
    return true;
  }
</code></pre>
<p>and the thread-safety has been destroyed<sup><a name="to-footnote-2"><a href="#footnote-2">2</a></a></sup>.</p>
<p>For a book about Rust, this Item has covered a lot of C++, so consider a straightforward translation of this class into
Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub struct BankAccount {
        balance: i64,
    }

    impl BankAccount {
        pub fn new() -&gt; Self {
            BankAccount { balance: 0 }
        }
        pub fn balance(&amp;self) -&gt; i64 {
            self.balance
        }
        pub fn deposit(&amp;mut self, amount: i64) {
            self.balance += amount
        }
        pub fn withdraw(&amp;mut self, amount: i64) -&gt; bool {
            if self.balance &lt; amount {
                return false;
            }
            self.balance -= amount;
            true
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>This works fine in a single-threaded context – even if that thread is not the main thread:</p>
<pre><code class="language-rust ignore">        let mut account = BankAccount::new();
        let payer = std::thread::spawn(move || pay_in(&amp;mut account, 30));
        // Wait for thread completion
        payer.join().unwrap();</code></pre>
<p>but a naïve attempt to use the <code>BankAccount</code> across multiple threads:</p>
<pre><code class="language-rust ignore does_not_compile">        let mut account = BankAccount::new();
        let taker = std::thread::spawn(move || take_out(&amp;mut account, 100));
        let payer = std::thread::spawn(move || pay_in(&amp;mut account, 300));
        payer.join().unwrap();
        taker.join().unwrap();</code></pre>
<p>immediately falls foul of the compiler:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `account`
  --&gt; deadlock/src/main.rs:76:40
   |
74 |         let mut account = BankAccount::new();
   |             ----------- move occurs because `account` has type `broken::BankAccount`, which does not implement the `Copy` trait
75 |         let taker = std::thread::spawn(move || take_out(&amp;mut account, 100));
   |                                        -------               ------- variable moved due to use in closure
   |                                        |
   |                                        value moved into closure here
76 |         let payer = std::thread::spawn(move || pay_in(&amp;mut account, 300));
   |                                        ^^^^^^^             ------- use occurs due to use in closure
   |                                        |
   |                                        value used here after move
</code></pre>
<p>With experience of the <a name="a017"></a>borrow checker (<a href="borrows.html">Item 15</a>), the problem sticks out clearly: there are two mutable references
to the same item, one more than is allowed.  The rules of the borrow checker are that you can have a single mutable
reference to an item, or multiple (immutable) references, but not both at the same time.</p>
<p>This has a curious resonance with the definition of a data race at the start of this Item: enforcing that there is a
single writer, or multiple readers (but never both) means that there can be no data races.  By enforcing memory safety,
<a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Rust gets thead safety &quot;for free&quot;</a>.</p>
<p>As with C++, some kind of <a name="a018"></a>synchronization is needed to make this <code>struct</code> <a name="a019"></a>thread-safe. The most common
mechanism is also called <a name="a020"></a><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>, but the Rust version
&quot;wraps&quot; the protected data rather than being a standalone object (as in C++):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub struct BankAccount {
        balance: std::sync::Mutex&lt;i64&gt;,
    }
<span class="boring">}</span></code></pre></pre>
<p>The <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#method.lock"><code>lock()</code></a> method on this <code>Mutex</code> generic returns
a <a name="a021"></a><a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a> object with an RAII behaviour, like
C++'s <code>std::lock_guard</code>: the mutex is automatically released at the end of the scope when the guard is <code>drop</code>ped.
(Rust's <code>Mutex</code> has no manual lock/unlock methods, as they would expose developers to the danger of forgetting to keep
<code>lock()</code> and <code>unlock()</code> calls exactly in sync.)</p>
<p>The <code>MutexGuard</code> object also acts as a proxy for the data that is enclosed by the <code>Mutex</code>, by implementing the
<a name="a022"></a><code>Deref</code> and <a name="a023"></a><code>DerefMut</code> traits (<a href="references.html">Item 9</a>), allowing it to be used for both read operations:</p>
<pre><code class="language-rust ignore">        pub fn balance(&amp;self) -&gt; i64 {
            *self.balance.lock().unwrap()
        }</code></pre>
<p>and write operations:</p>
<pre><code class="language-rust ignore">        // Note: no longer needs `&amp;mut self`.
        pub fn deposit(&amp;self, amount: i64) {
            *self.balance.lock().unwrap() += amount
        }</code></pre>
<p>There's an interesting detail lurking in the signature of this method: although it is modifying the balance of the
<code>BankAccount</code>, this method now takes <code>&amp;self</code> rather than <code>&amp;mut self</code>.  This is inevitable: if multiple threads are going
to hold references to the same <code>BankAccount</code>, by the rules of the borrow checker those references had better not be
mutable.  It's also another instance of the <em><a name="a024"></a>interior mutability</em> pattern described in <a href="references.html">Item 9</a>: borrow checks are
effectively moved from compile-time to run-time, but now with a specific concern for cross-thread synchronization.</p>
<p>Wrapping up shared state in a <code>Mutex</code> mollifies the borrow checker, but there are still lifetime issues (<a href="lifetimes.html">Item 14</a>) to fix.</p>
<pre><code class="language-rust ignore does_not_compile">        {
            let account = BankAccount::new();
            let taker = std::thread::spawn(|| take_out(&amp;account, 100));
            let payer = std::thread::spawn(|| pay_in(&amp;account, 300));
        }</code></pre>
<pre><code class="language-text">error[E0373]: closure may outlive the current function, but it borrows `account`, which is owned by the current function
   --&gt; deadlock/src/main.rs:190:44
    |
190 |             let taker = std::thread::spawn(|| take_out(&amp;account, 100));
    |                                            ^^           ------- `account` is borrowed here
    |                                            |
    |                                            may outlive borrowed value `account`
    |
note: function requires argument type to outlive `'static`
   --&gt; deadlock/src/main.rs:190:25
    |
190 |             let taker = std::thread::spawn(|| take_out(&amp;account, 100));
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `account` (and any other referenced variables), use the `move` keyword
    |
190 |             let taker = std::thread::spawn(move || take_out(&amp;account, 100));
    |                                            ++++
error[E0373]: closure may outlive the current function, but it borrows `account`, which is owned by the current function
   --&gt; deadlock/src/main.rs:191:44
    |
191 |             let payer = std::thread::spawn(|| pay_in(&amp;account, 300));
    |                                            ^^         ------- `account` is borrowed here
    |                                            |
    |                                            may outlive borrowed value `account`
    |
note: function requires argument type to outlive `'static`
   --&gt; deadlock/src/main.rs:191:25
    |
191 |             let payer = std::thread::spawn(|| pay_in(&amp;account, 300));
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `account` (and any other referenced variables), use the `move` keyword
    |
191 |             let payer = std::thread::spawn(move || pay_in(&amp;account, 300));
    |                                            ++++
</code></pre>
<p>The error message makes the problem clear: the <code>BankAccount</code> is going to be <a name="a025"></a><code>drop</code>ped at the end of the
block, but there are two new threads which have a reference to it, and which will carry on running afterwards.</p>
<p>The standard tool for ensuring that an object remains active until all references to it are gone is a reference counted
pointer, and Rust's variant of this for multi-threaded use is
<a name="a026"></a><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>std::sync::Arc</code></a>:</p>
<pre><code class="language-rust ignore">        let account = std::sync::Arc::new(BankAccount::new());

        let account2 = account.clone();
        let taker = std::thread::spawn(move || take_out(&amp;account2, 100));

        let account3 = account.clone();
        let payer = std::thread::spawn(move || pay_in(&amp;account3, 300));</code></pre>
<p>Each thread gets its own (moved) copy of the reference counting pointer, and the underlying <code>BankAccount</code> will only be
<code>drop</code>ped when the refcount drops to zero. This combination of <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> is common in Rust programs that use
<a name="a027"></a>shared-state parallelism.</p>
<p>Stepping back from the technical details, observe that Rust has entirely avoided the problem of data races that plagues
multi-threaded programming in other languages.  Of course, this good news is restricted to <em>safe</em> Rust –
<a name="a028"></a><code>unsafe</code> code (<a href="unsafe.html">Item 16</a>) and FFI boundaries in particular (<a href="ffi.html">Item 34</a>) may not be data race free – but it's
still a remarkable phenomenon.</p>
<h3 id="standard-marker-traits"><a class="header" href="#standard-marker-traits">Standard Marker Traits</a></h3>
<p>There are two standard traits that affect the use of Rust objects between threads.  Both of these traits are <em><a name="a029"></a>marker
traits</em> (<a href="std-traits.html">Item 5</a>) that have no associated methods, but they have special significance to the compiler in multi-threaded
scenarios.</p>
<ul>
<li>The <a name="a030"></a><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> trait indicates that items of a type are safe
to transfer between threads; ownership of an item of this type can be passed from one thread to another.</li>
<li>The <a name="a031"></a><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> trait indicates that items of a type can be
safely accessed by multiple threads, subject to the rules of the borrow checker.</li>
</ul>
<p>Another way of saying this is to observe that <code>Send</code> means <code>T</code> can be transferred between threads,
and <code>Sync</code> means that <code>&amp;T</code> can be transferred between threads.</p>
<p>Both of these traits are <a name="a032"></a><a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits"><strong>auto
traits</strong></a>: the compiler automatically
derives them for new types, as long as the constituent parts of the type are also <code>Send</code>/<code>Sync</code>.</p>
<p>The majority of safe types are <code>Send</code> and <code>Sync</code>, so much so that it's clearer to understand what types <em>don't</em>
implement these traits (written in the form <code>impl !Sync for Type</code>).</p>
<p>A non-<code>Send</code> type is one that can only be used in a single thread. The canonical example of this is the unsynchronized
reference counting pointer <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> (<a href="references.html">Item 9</a>).  The implementation of
this type explicitly assumes single-threaded use (for speed); there is no attempt at synchronizing the internal refcount
for multi-threaded use. As such, transferring an <code>Rc&lt;T&gt;</code> between threads is not allowed; use <code>Arc&lt;T&gt;</code> (with its
additional synchronization overhead) for this case.</p>
<p>A non-<code>Sync</code> type is one that's not safe to use from multiple threads via <strong>non-<code>mut</code></strong> references (as the borrow
checker will ensure there are never multiple <code>mut</code> references).  The canonical examples of this are the types that
provide <em>interior mutability</em> in an unsynchronized way, such as
<a name="a033"></a><a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a> and
<a name="a034"></a><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a>.  Use <code>Mutex&lt;T&gt;</code> or
<a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock&lt;T&gt;</code></a> to provide interior mutability in a multi-threaded
environment.</p>
<p>(Raw<a name="a035"></a> pointer types like <code>*const T</code> and <code>*mut T</code> are also neither <code>Send</code> nor <code>Sync</code>; see <a href="unsafe.html">Item 16</a> and
<a href="ffi.html">Item 34</a>.)</p>
<h2 id="deadlocks"><a class="header" href="#deadlocks">Deadlocks</a></h2>
<p>Now for the bad news.  Multi-threaded code comes with <em>two</em> terrible problems:</p>
<ul>
<li><strong><a name="a036"></a>data races</strong>, which can lead to corrupted data, and</li>
<li><strong><a name="a037"></a>deadlocks</strong>, which can lead to your program grinding to a halt.</li>
</ul>
<p>Both of these problems are terrible because they can be very hard to debug in practice: the failures occur
non-deterministically and are often more likely to happen under load – which means that they don't show up in
<a name="a038"></a>unit tests, <a name="a039"></a>integration tests, or any other sort of test (<a href="testing.html">Item 30</a>), but they
do show up in production.</p>
<p>Rust has solved the problem of data races (as described above), but the problem of deadlocks applies to Rust as much as
it does to any other language that supports multi-threading.</p>
<p>Consider a simplified multiple player game server, implemented as a multithreaded application in order to service many
players in parallel.  Two core data structures might be a collection of players, indexed by username:</p>
<pre><code class="language-rust ignore">    players: Mutex&lt;HashMap&lt;String, Player&gt;&gt;,</code></pre>
<p>and a collection of games in progress indexed by some unique identifier:</p>
<pre><code class="language-rust ignore">    games: Mutex&lt;HashMap&lt;GameID, Game&gt;&gt;,</code></pre>
<p>Both of these data structures are <code>Mutex</code>-protected and so safe from data races; however, code that manipulates <em>both</em>
data structures opens up potential problems.  A single interaction between the two might work fine:</p>
<pre><code class="language-rust ignore">    fn add_and_join(&amp;self, username: &amp;str, info: Player) -&gt; Option&lt;GameID&gt; {
        // Add the new player.
        let mut players = self.players.lock().unwrap();
        players.insert(username.to_owned(), info);

        // Find a game with available space for them to join.
        let mut games = self.games.lock().unwrap();
        for (id, game) in games.iter_mut() {
            if game.add_player(username) {
                return Some(*id);
            }
        }
        None
    }</code></pre>
<p>However, a second interaction between the two independently locked data structures is where problems start:</p>
<pre><code class="language-rust ignore">    fn ban_player(&amp;self, username: &amp;str) {
        // Find all games that the user is in and remove them.
        let mut games = self.games.lock().unwrap();
        games
            .iter_mut()
            .filter(|(_id, g)| g.has_player(username))
            .for_each(|(_id, g)| g.remove_player(username));

        // Wipe them from the user list.
        let mut players = self.players.lock().unwrap();
        players.remove(username);
    }</code></pre>
<p>To understand the problem, imagine two separate threads using these two methods:</p>
<ul>
<li>Thread 1 enters <code>add_and_join()</code> and immediately acquires the <code>players</code> lock.</li>
<li>   Thread 2 enters <code>ban_player()</code> and immediately acquires the <code>games</code> lock.</li>
<li>Thread 1 now tries to acquire the <code>games</code> lock; this is held by thread 2, so thread 1 blocks.</li>
<li>   Thread 2 tries to acquire the <code>players</code> lock; this is held by thread 1, so thread 2 blocks.</li>
</ul>
<p>At this point the program is <strong><a name="a040"></a>deadlocked</strong>: neither thread will ever progress, and nor will any other thread that
does anything with either of the two <code>Mutex</code>-protected data structures.</p>
<p>The root cause of this is a <strong><a name="a041"></a>lock inversion</strong>: one function acquires the locks in the order <code>players</code> then <code>games</code>,
whereas the other uses the opposite order (<code>games</code> then <code>players</code>).  This is the simplest example of a more general
description of the problem:</p>
<ul>
<li>Build a <a name="a042"></a><a href="https://en.wikipedia.org/wiki/Directed_graph">directed graph</a> where:
<ul>
<li>Each <code>Mutex</code> instance is a vertex.</li>
<li>Each edge indicates a situation where one <code>Mutex</code> gets acquired while another <code>Mutex</code> is already held.</li>
</ul>
</li>
<li>If there are any cycles in the graph, a deadlock can occur.</li>
</ul>
<p>A simplistic attempt to solve this problem involves reducing the scope of the locks, so there is no point where both
locks are held at the same time:</p>
<pre><code class="language-rust ignore">    fn add_and_join(&amp;self, username: &amp;str, info: Player) -&gt; Option&lt;GameID&gt; {
        // Add the new player.
        {
            let mut players = self.players.lock().unwrap();
            players.insert(username.to_owned(), info);
        }

        // Find a game with available space for them to join.
        {
            let mut games = self.games.lock().unwrap();
            for (id, game) in games.iter_mut() {
                if game.add_player(username) {
                    return Some(*id);
                }
            }
        }
        None
    }
    fn ban_player(&amp;self, username: &amp;str) {
        // Find all games that the user is in and remove them.
        {
            let mut games = self.games.lock().unwrap();
            games
                .iter_mut()
                .filter(|(_id, g)| g.has_player(username))
                .for_each(|(_id, g)| g.remove_player(username));
        }

        // Wipe them from the user list.
        {
            let mut players = self.players.lock().unwrap();
            players.remove(username);
        }
    }</code></pre>
<p>(A better version of this would be to encapsulate the manipulation of the <code>players</code> data structure into <code>add_player()</code>
and <code>remove_player()</code> helper methods, to reduce the chances of forgetting to close out a scope.)</p>
<p>This solves the deadlock problem, but leaves behind a data consistency problem: the <code>players</code> and <code>games</code> data
structures can get out of sync with each other.</p>
<ul>
<li>Thread 1 enters <code>add_and_join(&quot;Alice&quot;)</code> and adds Alice to the <code>players</code> data structure (then releases the <code>players</code> lock).</li>
<li>   Thread 2 enters <code>ban_player(&quot;Alice&quot;)</code> and removes Alice from all <code>games</code> (then releases the <code>games</code> lock).</li>
<li>   Thread 2 now removes Alice from the <code>players</code> data structure; thread 1 has already released the lock so
this does not block.</li>
<li>Thread 1 now carries on and acquires the <code>games</code> lock (already released by thread 2). With the lock held, thread 1
adds &quot;Alice&quot; to a game in progress.</li>
</ul>
<p>At this point, there is a game that includes a player that doesn't exist, according to the <code>players</code> data structure!</p>
<p>The heart of the problem is that there are two data structures that need to be kept in sync with each other; the
best way to do this is to have a single sychronization primitive that covers both of them.</p>
<pre><code class="language-rust ignore">    struct GameState {
        players: HashMap&lt;String, Player&gt;,
        games: HashMap&lt;GameID, Game&gt;,
    }

    struct GameServer {
        state: Mutex&lt;GameState&gt;,
        // ...
    }</code></pre>
<h3 id="advice"><a class="header" href="#advice">Advice</a></h3>
<p>The most obvious advice for how to avoid the problems that come with <a name="a043"></a>shared-state parallelism is simply to avoid
shared-state parallelism.  The <a href="https://doc.rust-lang.org/book/ch16-02-message-passing.html">Rust book</a> quotes from the
<a href="https://golang.org/doc/effective_go.html#concurrency"><a name="a044"></a>Go language documentation</a>: &quot;Do not communicate by sharing
memory; instead, share memory by communicating&quot;.</p>
<p>The Go language has <a name="a045"></a><em>channels</em> that are suitable for this <a href="https://go.dev/ref/spec#Channel_types">built into the
language</a>; for Rust, equivalent functionality is included in the standard library
in the <a name="a046"></a><a href="https://doc.rust-lang.org/std/sync/mpsc/index.html"><code>std::sync::mpsc</code> module</a>: the <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html"><code>channel()</code>
function</a> returns a <code>(Sender, Receiver)</code> pair that allows
values of a particular type to be communicated between threads.</p>
<p>If shared-state concurrency can't be avoided, then there are some ways to reduce the chances of writing deadlock-prone
code:</p>
<ul>
<li><strong>Put data structures that must be kept consistent with each other under a single lock</strong>.</li>
<li><strong>Keep lock scopes small and obvious</strong>; wherever possible, use helper methods that get and set things under the
relevant lock.</li>
<li><strong>Avoid invoking closures with locks held</strong>; this puts the code at the mercy of whatever closure gets added to the
codebase in the future.</li>
<li>Similarly, <strong>avoid returning a <code>MutexGuard</code> to a caller</strong>: it's like handing out a loaded gun from a deadlock
perspective.</li>
<li><strong>Include deadlock detection tools</strong> in your CI system (<a href="ci.html">Item 32</a>), such as
<a name="a047"></a><a href="https://docs.rs/no_deadlocks"><code>no_deadlocks</code></a>,
<a name="a048"></a><a href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a>, or
<a name="a049"></a><a href="https://amanieu.github.io/parking_lot/parking_lot/deadlock/index.html"><code>parking_lot::deadlock</code></a>.</li>
<li>As a last resort: design, document, test and police a <em><a name="a050"></a>locking hierarchy</em> that describes what lock orderings are
allowed/required. This should be a last resort because any strategy that relies on engineers never making a mistake is
obviously doomed to failure in the long term.</li>
</ul>
<p>More abstractly, multi-threaded code is an ideal place to apply the general advice: prefer code that's so simple that
it is obviously not wrong, rather than code that's so complex that it's not obviously wrong.</p>
<p><hr/>
<p><a name="footnote-1"><a href="#to-footnote-1">1</a></a>: The third category of behaviour is
<em><a name="a013"></a>thread-hostile</em>: code that's dangerous in a multithreaded environment <em>even if</em> all access to it is externally
synchronized.</p>
<p><a name="footnote-2"><a href="#to-footnote-2">2</a></a>: The <a name="a016"></a>Clang C++ compiler includes a
<a href="https://clang.llvm.org/docs/ThreadSafetyAnalysis.html"><code>-Wthread-safety</code></a> option, sometimes known as <em>annotalysis</em>,
that allows data to be annotated with information about which mutexes protect which data, and functions to be annotated
with information about the locks they acquire. This gives <em>compile-time</em> errors when these invariants are broken, like
Rust; however, there is nothing to enforce the use of these annotations in the first place – for example, when a
thread-compatible library is used in a multi-threaded environment for the first time.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="unsafe.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="panic.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="unsafe.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="panic.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/third_party/ferris/ferris.js"></script>


    </div>
    </body>
</html>
