<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Item 15: Understand the borrow checker - Effective Rust</title>


        <!-- Custom HTML head -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-23228806-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
        <meta name="description" content="A collection of specific ways to improve your use of Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/third_party/ferris/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cover.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="use-types.html"><strong aria-hidden="true">3.1.</strong> Item 1: Use the type system to express your data structures</a></li><li class="chapter-item expanded "><a href="use-types-2.html"><strong aria-hidden="true">3.2.</strong> Item 2: Use the type system to express common behaviour</a></li><li class="chapter-item expanded "><a href="transform.html"><strong aria-hidden="true">3.3.</strong> Item 3: Avoid matching Option and Result</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">3.4.</strong> Item 4: Prefer idiomatic Error variants</a></li><li class="chapter-item expanded "><a href="std-traits.html"><strong aria-hidden="true">3.5.</strong> Item 5: Familiarize yourself with standard traits</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">3.6.</strong> Item 6: Understand type conversions</a></li><li class="chapter-item expanded "><a href="newtype.html"><strong aria-hidden="true">3.7.</strong> Item 7: Embrace the newtype pattern</a></li><li class="chapter-item expanded "><a href="builders.html"><strong aria-hidden="true">3.8.</strong> Item 8: Use builders for complex types</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.9.</strong> Item 9: Familiarize yourself with reference and pointer types</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">3.10.</strong> Item 10: Consider using iterator transforms instead of explicit loops</a></li><li class="chapter-item expanded "><a href="raii.html"><strong aria-hidden="true">3.11.</strong> Item 11: Implement the Drop trait for RAII patterns</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">3.12.</strong> Item 12: Prefer generics to trait objects</a></li><li class="chapter-item expanded "><a href="default-impl.html"><strong aria-hidden="true">3.13.</strong> Item 13: Use default implementations to minimize required trait methods</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">4.1.</strong> Item 14: Understand lifetimes</a></li><li class="chapter-item expanded "><a href="borrows.html" class="active"><strong aria-hidden="true">4.2.</strong> Item 15: Understand the borrow checker</a></li><li class="chapter-item expanded "><a href="unsafe.html"><strong aria-hidden="true">4.3.</strong> Item 16: Avoid writing unsafe code</a></li><li class="chapter-item expanded "><a href="deadlock.html"><strong aria-hidden="true">4.4.</strong> Item 17: Be wary of shared-state parallelism</a></li><li class="chapter-item expanded "><a href="panic.html"><strong aria-hidden="true">4.5.</strong> Item 18: Don't panic</a></li><li class="chapter-item expanded "><a href="reflection.html"><strong aria-hidden="true">4.6.</strong> Item 19: Avoid reflection</a></li><li class="chapter-item expanded "><a href="optimize.html"><strong aria-hidden="true">4.7.</strong> Item 20: Avoid the temptation to over-optimize</a></li></ol></li><li class="chapter-item expanded "><a href="deps.html"><strong aria-hidden="true">5.</strong> Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="semver.html"><strong aria-hidden="true">5.1.</strong> Item 21: Understand what semantic versioning promises</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.2.</strong> Item 22: Minimize visibility</a></li><li class="chapter-item expanded "><a href="wildcard.html"><strong aria-hidden="true">5.3.</strong> Item 23: Avoid wildcard imports</a></li><li class="chapter-item expanded "><a href="re-export.html"><strong aria-hidden="true">5.4.</strong> Item 24: Re-export dependencies whose types appear in your API</a></li><li class="chapter-item expanded "><a href="dep-graph.html"><strong aria-hidden="true">5.5.</strong> Item 25: Manage your dependency graph</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">5.6.</strong> Item 26: Be wary of feature creep</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">6.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">6.1.</strong> Item 27: Document public interfaces</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">6.2.</strong> Item 28: Use macros judiciously</a></li><li class="chapter-item expanded "><a href="clippy.html"><strong aria-hidden="true">6.3.</strong> Item 29: Listen to Clippy</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.4.</strong> Item 30: Write more than unit tests</a></li><li class="chapter-item expanded "><a href="use-tools.html"><strong aria-hidden="true">6.5.</strong> Item 31: Take advantage of the tooling ecosystem</a></li><li class="chapter-item expanded "><a href="ci.html"><strong aria-hidden="true">6.6.</strong> Item 32: Set up a continuous integration (CI) system</a></li></ol></li><li class="chapter-item expanded "><a href="beyond-std.html"><strong aria-hidden="true">7.</strong> Beyond Standard Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="no-std.html"><strong aria-hidden="true">7.1.</strong> Item 33: Consider making library code no_std compatible</a></li><li class="chapter-item expanded "><a href="ffi.html"><strong aria-hidden="true">7.2.</strong> Item 34: Control what crosses FFI boundaries</a></li><li class="chapter-item expanded "><a href="bindgen.html"><strong aria-hidden="true">7.3.</strong> Item 35: Prefer bindgen to manual FFI mappings</a></li></ol></li><li class="chapter-item expanded "><a href="indexing.html"><strong aria-hidden="true">8.</strong> Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="item-15-understand-the-borrow-checker"><a class="header" href="#item-15-understand-the-borrow-checker">Item 15: Understand the borrow checker</a></h1>
<blockquote>
<p>&quot;The power to destroy a thing is the absolute control over it.&quot; – Frank Herbert</p>
</blockquote>
<p>Values in Rust have an owner, but that owner can lend the values out to other places in the code. This <em>borrowing</em>
mechanism involves the creation and use of <a name="a001"></a><em>references</em>, subject to rules policed by the <em><a name="a002"></a>borrow
checker</em>.</p>
<p>Under the covers this uses the same kind of <em>pointer</em> values (<a href="references.html">Item 9</a>) that are so prevalent in <a name="a003"></a>C or <a name="a004"></a>C++
code, but girded with rules and restrictions to make sure that the sins of C/C++ are avoided. As a quick comparison:</p>
<ul>
<li>Like a C/C++ pointer, a Rust reference is created with an ampersand: <code>&amp;value</code>.</li>
<li>Like a C++ reference, a Rust reference can never be <a name="a005"></a><code>nullptr</code>.</li>
<li>Like a C/C++ pointer or reference, a Rust reference can be modified after creation to refer to something different.</li>
<li>Unlike C++, producing a reference from a value always involves an explicit (<strong><code>&amp;</code></strong>) conversion – if you see
code like <code>f(value)</code>, you know that <code>f</code> is receiving ownership of the value<sup><a name="to-footnote-1"><a href="#footnote-1">1</a></a></sup>.</li>
<li>Unlike C/C++, the mutability of a newly-created reference is always explicit (<strong><code>&amp; mut</code></strong>); if you see code like
<code>f(&amp;value)</code>, you know that <code>value</code> won't modified (i.e. is <code>const</code> in C/C++ terminology).  Only expressions<sup><a name="to-footnote-2"><a href="#footnote-2">2</a></a></sup> like <code>f(&amp;mut value)</code> have the possibility of changing the contents of <code>value</code>.</li>
</ul>
<p>The most important difference between a C/C++ pointer and a Rust reference is indicated by the term <em><a name="a008"></a>borrow</em>: you
can take a reference (pointer) to an item, <em>but you have to give it back</em>.  In particular, you have to give it back
<em>before</em> the lifetime of the underlying item expires, as tracked by the compiler and explored in <a href="lifetimes.html">Item 14</a>.</p>
<p>These restrictions on the use of references are at the heart of Rust's memory safety guarantees, but they do mean you
have to accept the cognitive costs of the borrow rules – accept that it will change how you design your software,
particularly its data structures.</p>
<h2 id="access-control"><a class="header" href="#access-control">Access Control</a></h2>
<p>There are three different ways that a Rust item can be accessed: via the item's <em>owner</em> (<code>item</code>), via a <em>reference</em>
(<code>&amp;item</code>), or via a <em>mutable reference</em> (<code>&amp;mut item</code>).</p>
<p>Each of these different ways of accessing the item comes with different powers over the item.  Putting things in
<a name="a009"></a><a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a>e terms:</p>
<ul>
<li>The owner of an item gets to <strong>c</strong>reate it, <strong>r</strong>ead from it, <strong>u</strong>pdate it, and <strong>d</strong>rop it (CRUD).</li>
<li>A mutable reference can be used to <strong>r</strong>ead from the underlying item, and to <strong>u</strong>pdate it (_RU_).</li>
<li>A (normal) reference can only be used to <strong>r</strong>ead from the underlying item (_R__).</li>
</ul>
<p>There's an important Rust-specific extension to these data access rules: only the item's owner can <a name="a010"></a><em>move</em> the item.  This makes sense if you think of a move as being some combination of <strong>c</strong>reating (in the
new location) and <strong>d</strong>ropping the item's memory (at the old location).</p>
<p>This can lead to some oddities for code that has a mutable reference to an item.  For example, it's OK to overwrite an
<code>Option</code>:</p>
<pre><code class="language-rust ignore">fn overwrite(item: &amp;mut Option&lt;Item&gt;, val: Item) {
    *item = Some(val);
}</code></pre>
<p>but a modification to return the previous value falls foul of the move restriction:</p>
<pre><code class="language-rust ignore does_not_compile">    pub fn replace(item: &amp;mut Option&lt;Item&gt;, val: Item) -&gt; Option&lt;Item&gt; {
        let previous = *item; // move out
        *item = Some(val); // replace
        previous
    }</code></pre>
<pre><code class="language-text">error[E0507]: cannot move out of `*item` which is behind a mutable reference
  --&gt; borrows/src/main.rs:27:24
   |
27 |         let previous = *item; // move out
   |                        ^^^^^ move occurs because `*item` has type `Option&lt;Item&gt;`, which does not implement the `Copy` trait
   |
help: consider borrowing the `Option`'s content
   |
27 |         let previous = *item.as_ref(); // move out
   |                             +++++++++
help: consider borrowing here
   |
27 |         let previous = &amp;*item; // move out
   |                        ~~~~~~
</code></pre>
<p>It's valid to read from a mutable reference, and it's valid to write to a mutable reference, and so the ability to do
both at once is provided by the <a name="a011"></a><a href="https://doc.rust-lang.org/std/mem/fn.replace.html"><code>std::mem::replace</code></a>
function in the standard library.  This uses <a name="a012"></a><code>unsafe</code> code under the covers (as per <a href="unsafe.html">Item 16</a>) to perform the swap
in one go:</p>
<pre><code class="language-rust ignore">    pub fn replace(item: &amp;mut Option&lt;Item&gt;, val: Item) -&gt; Option&lt;Item&gt; {
        std::mem::replace(item, Some(val)) // returns previous value
    }</code></pre>
<p>For <a name="a013"></a><code>Option</code> types in particular, this is a sufficiently common pattern that there is also a
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.replace"><code>replace</code></a> method on <code>Option</code> itself:</p>
<pre><code class="language-rust ignore">    pub fn replace(item: &amp;mut Option&lt;Item&gt;, val: Item) -&gt; Option&lt;Item&gt; {
        item.replace(val)
    }</code></pre>
<h2 id="borrow-rules"><a class="header" href="#borrow-rules">Borrow Rules</a></h2>
<p>The first rule for borrowing references in Rust is that the scope of any reference must be smaller than the lifetime of
the item that it refers to. However, the compiler is smarter than just assuming that a reference lasts until it is
dropped – the <em><a name="a014"></a>non-lexical lifetimes</em> feature allows reference lifetimes to be shrunk so they end at the
point of last use, rather than the enclosing block (as described in <a href="lifetimes.html">Item 14</a>).</p>
<p>The second rule for borrowing references is that, in addition to the owner of an item, there can be</p>
<ul>
<li>any number of immutable references to the item, <em>or</em></li>
<li>a single mutable reference to the item</li>
</ul>
<p>but not both.</p>
<p>So a method that takes multiple immutable references can be fed references to the same item:</p>
<pre><code class="language-rust ignore">    fn both_zero(left: &amp;Item, right: &amp;Item) -&gt; bool {
        left.contents == 0 &amp;&amp; right.contents == 0
    }

    let item = Item { contents: 0 };
    assert!(both_zero(&amp;item, &amp;item));</code></pre>
<p>but one that takes <em>mutable</em> references cannot:</p>
<pre><code class="language-rust ignore does_not_compile">    fn zero_both(left: &amp;mut Item, right: &amp;mut Item) {
        left.contents = 0;
        right.contents = 0;
    }

    let mut item = Item { contents: 42 };
    zero_both(&amp;mut item, &amp;mut item);</code></pre>
<pre><code class="language-text">error[E0499]: cannot borrow `item` as mutable more than once at a time
   --&gt; borrows/src/main.rs:115:26
    |
115 |     zero_both(&amp;mut item, &amp;mut item);
    |     --------- ---------  ^^^^^^^^^ second mutable borrow occurs here
    |     |         |
    |     |         first mutable borrow occurs here
    |     first borrow later used by call
</code></pre>
<p>and similarly for a mixture of the two:</p>
<pre><code class="language-rust ignore does_not_compile">    fn copy_contents(left: &amp;mut Item, right: &amp;Item) {
        left.contents = right.contents;
    }

    let mut item = Item { contents: 42 };
    copy_contents(&amp;mut item, &amp;item);</code></pre>
<pre><code class="language-text">error[E0502]: cannot borrow `item` as immutable because it is also borrowed as mutable
   --&gt; borrows/src/main.rs:140:30
    |
140 |     copy_contents(&amp;mut item, &amp;item);
    |     ------------- ---------  ^^^^^ immutable borrow occurs here
    |     |             |
    |     |             mutable borrow occurs here
    |     mutable borrow later used by call
</code></pre>
<p>The borrowing rules allow the compiler to make better decisions around
<a name="a015"></a><a href="https://en.wikipedia.org/wiki/Aliasing_(computing)"><em>aliasing</em></a>: tracking when two different pointers
may or may not refer to the same underlying item in memory.  If the compiler can be sure (as in Rust) that the memory
location pointed to by a collection of immutable references cannot be altered via an aliased <em>mutable</em> reference, then
it can generate code that is:</p>
<ul>
<li>better optimized: values can be (e.g.) cached in registers, secure in the knowledge that the underlying memory
contents will not change in the meanwhile</li>
<li>safer: data races arising from unsynchronized access to memory between threads (<a href="deadlock.html">Item 17</a>) are not possible.</li>
</ul>
<h3 id="owner-operations"><a class="header" href="#owner-operations">Owner Operations</a></h3>
<p>One important consequence of the rules around the existence of references is that they also affect what operations can
be performed by the owner of the item.  To help understand this, consider operations involving the owner as though they
make use of references along the way.</p>
<p>For example, an attempt to update the item via its owner while a reference exists fails, because of this transient
second mutable reference:</p>
<pre><code class="language-rust ignore does_not_compile">    let mut item = Item { contents: 42 };
    let r = &amp;item;
    item.contents = 0;
    // ^^^ Changing the item is roughly equivalent to:
    //   (&amp;mut item).contents = 0;
    println!(&quot;reference to item is {:?}&quot;, r);</code></pre>
<pre><code class="language-text">error[E0506]: cannot assign to `item.contents` because it is borrowed
   --&gt; borrows/src/main.rs:164:5
    |
163 |     let r = &amp;item;
    |             ----- borrow of `item.contents` occurs here
164 |     item.contents = 0;
    |     ^^^^^^^^^^^^^^^^^ assignment to borrowed `item.contents` occurs here
...
167 |     println!(&quot;reference to item is {:?}&quot;, r);
    |                                           - borrow later used here
</code></pre>
<p>On the other hand, because multiple <em>immutable</em> references are allowed, it's OK for the owner to read from the item
while there are immutable references in existence:</p>
<pre><code class="language-rust ignore">    let item = Item { contents: 42 };
    let r = &amp;item;
    let contents = item.contents;
    // ^^^ Reading from the item is roughly equivalent to:
    //   let contents = (&amp;item).contents;
    println!(&quot;reference to item is {:?}&quot;, r);</code></pre>
<p>but not if there is a <em>mutable</em> reference:</p>
<pre><code class="language-rust ignore does_not_compile">    let mut item = Item { contents: 42 };
    let r = &amp;mut item;
    let contents = item.contents; // i64 is `Copy`
    r.contents = 0;</code></pre>
<pre><code class="language-text">error[E0503]: cannot use `item.contents` because it was mutably borrowed
   --&gt; borrows/src/main.rs:194:20
    |
193 |     let r = &amp;mut item;
    |             --------- borrow of `item` occurs here
194 |     let contents = item.contents; // i64 is `Copy`
    |                    ^^^^^^^^^^^^^ use of borrowed `item`
195 |     r.contents = 0;
    |     -------------- borrow later used here
</code></pre>
<p>Finally, the existence of any sort of reference prevents the owner of the item from moving or <a name="a016"></a>dropping the
item, exactly because this mean that the reference now refers to an invalid item.</p>
<pre><code class="language-rust ignore does_not_compile">    let item = Item { contents: 42 };
    let r = &amp;item;
    let new_item = item; // move
    println!(&quot;reference to item is {:?}&quot;, r);</code></pre>
<pre><code class="language-text">error[E0505]: cannot move out of `item` because it is borrowed
   --&gt; borrows/src/main.rs:151:20
    |
150 |     let r = &amp;item;
    |             ----- borrow of `item` occurs here
151 |     let new_item = item; // move
    |                    ^^^^ move out of `item` occurs here
152 |     println!(&quot;reference to item is {:?}&quot;, r);
    |                                           - borrow later used here
</code></pre>
<h2 id="winning-fights-against-the-borrow-checker"><a class="header" href="#winning-fights-against-the-borrow-checker">Winning Fights against the Borrow Checker</a></h2>
<p>Newcomers to Rust (and even more experienced folk!) can often feel that they are spending time fighting against the
borrow checker. What kinds of things can help you win these battles?</p>
<h3 id="local-code-refactoring"><a class="header" href="#local-code-refactoring">Local Code Refactoring</a></h3>
<p>The first tactic is to pay attention to the compiler's error messages, because the Rust developers have put a lot of
effort into making them as helpful as possible.</p>
<pre><code class="language-rust ignore does_not_compile">/// If `needle` is present in `haystack`, return a slice containing it.
pub fn find&lt;'a, 'b&gt;(a: &amp;'a str, b: &amp;'b str) -&gt; Option&lt;&amp;'a str&gt; {
    a.find(b).map(|i| &amp;a[i..i + b.len()])
}

// ...

    let found = find(&amp;format!(&quot;{} to search&quot;, &quot;Text&quot;), &quot;ex&quot;);
    if let Some(text) = found {
        println!(&quot;Found '{}'!&quot;, text);
    }</code></pre>
<pre><code class="language-text">error[E0716]: temporary value dropped while borrowed
   --&gt; borrows/src/main.rs:312:23
    |
312 |     let found = find(&amp;format!(&quot;{} to search&quot;, &quot;Text&quot;), &quot;ex&quot;);
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^       - temporary value is freed at the end of this statement
    |                       |
    |                       creates a temporary which is freed while still in use
313 |     if let Some(text) = found {
    |                         ----- borrow later used here
    |
    = note: consider using a `let` binding to create a longer lived value
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<p>The first part of the error message is the important part, because it describes what borrowing rule the compiler thinks
you have broken, and why.  As you encounter enough of these errors – which you will – you can build up an
intuition about the borrow checker that matches the more theoretical version encapsulated in the rules above.</p>
<p>The second part of the error message includes the compiler's suggestions for how to fix the problem, which in this
case is simple:</p>
<pre><code class="language-rust ignore">    let haystack = format!(&quot;{} to search&quot;, &quot;Text&quot;);
    let found = find(&amp;haystack, &quot;ex&quot;);
    if let Some(text) = found {
        println!(&quot;Found '{}'!&quot;, text);
    }
    // `found` now references `haystack`, which out-lives it</code></pre>
<p>This is an instance of one of the two simple code tweaks that can help mollify the borrow checker:</p>
<ul>
<li><em>Lifetime extension</em>: convert a temporary (whose lifetime only extends to the end of the expression) to be a new named
local variable (whose lifetime extends to the end of the block) with a <a name="a017"></a><code>let</code> binding.</li>
<li><em>Lifetime reduction</em>: add an additional block <code>{ ... }</code> around the use of a reference so that its lifetime ends at the
end of the new block.</li>
</ul>
<p>The latter is less common, because of the existence of <a name="a018"></a>non-lexical lifetimes: the compiler can often figure out
that a reference is no longer used, ahead of its official drop point at the end of the block. However, if you do find
yourself repeatedly introducing an artificial block around similar small chunks of code, consider whether that code
should be encapsulated into a method of its own.</p>
<p>The compiler's suggested fixes are helpful for simpler problems, but as you write more sophisticated code you're likely
to find that the suggestions are no longer useful, and that the explanation of the broken borrowing rule is harder to
follow.</p>
<pre><code class="language-rust ignore does_not_compile">    let x = Some(Rc::new(RefCell::new(Item { contents: 42 })));

    // Call function with signature: `check_item(item: Option&lt;&amp;Item&gt;)`
    check_item(x.as_ref().map(|r| r.borrow().deref()));</code></pre>
<pre><code class="language-text">error[E0515]: cannot return reference to temporary value
   --&gt; borrows/src/main.rs:257:35
    |
257 |     check_item(x.as_ref().map(|r| r.borrow().deref()));
    |                                   ----------^^^^^^^^
    |                                   |
    |                                   returns a reference to data owned by the current function
    |                                   temporary value created here
</code></pre>
<p>In this situation it can be helpful to temporarily introduce a sequence of local variables, one for each step of a
complicated transformation, and each with an explicit type annotation.</p>
<pre><code class="language-rust ignore does_not_compile">    let x: Option&lt;Rc&lt;RefCell&lt;Item&gt;&gt;&gt; =
        Some(Rc::new(RefCell::new(Item { contents: 42 })));

    let x1: Option&lt;&amp;Rc&lt;RefCell&lt;Item&gt;&gt;&gt; = x.as_ref();
    let x2: Option&lt;std::cell::Ref&lt;Item&gt;&gt; = x1.map(|r| r.borrow());
    let x3: Option&lt;&amp;Item&gt; = x2.map(|r| r.deref());
    check_item(x3);</code></pre>
<pre><code class="language-text">error[E0515]: cannot return reference to function parameter `r`
   --&gt; borrows/src/main.rs:269:40
    |
269 |     let x3: Option&lt;&amp;Item&gt; = x2.map(|r| r.deref());
    |                                        ^^^^^^^^^ returns a reference to data owned by the current function
</code></pre>
<p>This narrows down the precise conversion that the compiler is complaining about, which in turn allows the code to be
restructured:</p>
<pre><code class="language-rust ignore">    let x: Option&lt;Rc&lt;RefCell&lt;Item&gt;&gt;&gt; =
        Some(Rc::new(RefCell::new(Item { contents: 42 })));

    let x1: Option&lt;&amp;Rc&lt;RefCell&lt;Item&gt;&gt;&gt; = x.as_ref();
    let x2: Option&lt;std::cell::Ref&lt;Item&gt;&gt; = x1.map(|r| r.borrow());
    match x2 {
        None =&gt; check_item(None),
        Some(r) =&gt; {
            let x3: &amp;Item = r.deref();
            check_item(Some(x3));
        }
    }</code></pre>
<p>Once the underlying problem is clear and has been fixed, you're then free to re-coalesce the local variables back
together, so that you can pretend that you got it right all along:</p>
<pre><code class="language-rust ignore">    let x = Some(Rc::new(RefCell::new(Item { contents: 42 })));

    match x.as_ref().map(|r| r.borrow()) {
        None =&gt; check_item(None),
        Some(r) =&gt; check_item(Some(r.deref())),
    };</code></pre>
<h3 id="data-structure-design"><a class="header" href="#data-structure-design">Data Structure Design</a></h3>
<p>The next tactic that helps for battles against the borrow checker is to design your data structures with the borrow
checker in mind.  The panacea is if your data structures can own all of the data that they use, avoiding any use of
references and the consequent propagation of <a name="a019"></a>lifetime annotations described in <a href="lifetimes.html">Item 14</a>.</p>
<p>However, that's not always possible for real-world data structures; any time the internal connections of the data
structure form a graph that's more inter-connected than a tree pattern (a <code>Root</code> that owns multiple <code>Branch</code>es, each of
which owns multiple <code>Leaf</code>s etc.), then simple single-ownership isn't possible.</p>
<p>To take a simple example, imagine a simple register of guest details recorded in the order in which they arrive.</p>
<pre><code class="language-rust ignore">#[derive(Clone)]
struct Guest {
    name: String,
    phone: PhoneNumber,
    address: String,
    // ... many other fields
}

#[derive(Default, Debug)]
struct GuestRegister(Vec&lt;Guest&gt;);

impl GuestRegister {
    fn register(&amp;mut self, guest: Guest) {
        self.0.push(guest)
    }
    fn nth(&amp;self, idx: usize) -&gt; Option&lt;&amp;Guest&gt; {
        if idx &lt; self.0.len() {
            Some(&amp;self.0[idx])
        } else {
            None
        }
    }
}</code></pre>
<p>If this code <em>also</em> needs to be able to efficiently look up guests by arrival and alphabetically by name, then there are
fundamentally two distinct data structures involved, and only one of them can own the data.</p>
<p>If the data involved is both small and immutable, then just taking a copy can give a quick solution.</p>
<pre><code class="language-rust ignore">#[derive(Default, Debug)]
struct ClonedGuestRegister {
    by_arrival: Vec&lt;Guest&gt;,
    by_name: BTreeMap&lt;String, Guest&gt;,
}

impl ClonedGuestRegister {
    fn register(&amp;mut self, guest: Guest) {
        self.by_arrival.push(guest.clone()); // requires `Guest` to be `Clone`
        self.by_name.insert(guest.name.clone(), guest);
    }
    fn named(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Guest&gt; {
        self.by_name.get(name)
    }
    fn nth(&amp;self, idx: usize) -&gt; Option&lt;&amp;Guest&gt; {
        // snip
    }
}</code></pre>
<p>This approach of taking copies copes poorly if the data can be modified – if the telephone number for a <code>Guest</code>
needs to be updated, you have to find both versions and ensure they stay in sync.</p>
<p>Another possible approach is to add another layer of indirection, treating the <code>Vec&lt;Guest&gt;</code> as the owner and using an
index into that vector for the name lookups.</p>
<p>This approach copes fine with a changing phone number – the (single) <code>Guest</code> is owned by the <code>Vec</code>, and will
always be reached that way under the covers:</p>
<pre><code class="language-rust ignore">    let new_number = PhoneNumber::new(123456);
    ledger.named_mut(&quot;Bob&quot;).unwrap().phone = new_number;
    assert_eq!(ledger.named(&quot;Bob&quot;).unwrap().phone, new_number);</code></pre>
<p>However, it copes less well with a different kind of modification: what happens if guests can de-register:</p>
<pre><code class="language-rust ignore not_desired_behaviour">    // Deregister the `Guest` at position `idx`, moving up all subsequent guests.
    fn deregister(&amp;mut self, idx: usize) -&gt; Result&lt;(), Error&gt; {
        if idx &gt;= self.by_arrival.len() {
            return Err(Error::new(&quot;out of bounds&quot;));
        }
        self.by_arrival.remove(idx);
        // Oops, forgot to update `by_name`.
        Ok(())
    }</code></pre>
<p>Now that the <code>Vec</code> can be shuffled, the <code>by_name</code> indexes into it are effectively acting like pointers, and we've
re-introduced a world where those &quot;pointers&quot; can point to nothing (beyond the <code>Vec</code> bounds) or can point to incorrect
data.</p>
<pre><code class="language-rust ignore not_desired_behaviour">    ledger.register(alice);
    ledger.register(bob);
    ledger.register(charlie);
    println!(&quot;Register starts as: {:?}&quot;, ledger);

    ledger.deregister(0).unwrap();
    println!(&quot;Register after deregister(0): {:?}&quot;, ledger);

    let also_alice = ledger.named(&quot;Alice&quot;);
    // Alice still has index 0, which is now Bob
    println!(&quot;Alice is {:?}&quot;, also_alice);

    let also_bob = ledger.named(&quot;Bob&quot;);
    // Bob still has index 1, which is now Charlie
    println!(&quot;Bob is {:?}&quot;, also_bob);

    let also_charlie = ledger.named(&quot;Charlie&quot;);
    // Charlie still has index 2, which is now beyond the Vec
    println!(&quot;Charlie is {:?}&quot;, also_charlie);</code></pre>
<pre><code class="language-text">Register starts as: {
  by_arrival: [{n: 'Alice', ...}, {n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: {&quot;Alice&quot;: 0, &quot;Bob&quot;: 1, &quot;Charlie&quot;: 2}
}
Register after deregister(0): {
  by_arrival: [{n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: {&quot;Alice&quot;: 0, &quot;Bob&quot;: 1, &quot;Charlie&quot;: 2}
}
Alice is Some({n: 'Bob', ...})
Bob is Some({n: 'Charlie', ...})
Charlie is None
</code></pre>
<p>Regardless of approach, the code needs to be fixed to ensure the data structures stay in sync.  However, a better
approach to the underlying data structure would be to use Rust's smart pointers instead (<a href="references.html">Item 9</a>).  Shifting to a
combination of <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> and
<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> avoids the invalidation problems of using indices as
pseudo-pointers:</p>
<pre><code class="language-rust ignore">#[derive(Default)]
struct RcGuestRegister {
    by_arrival: Vec&lt;Rc&lt;RefCell&lt;Guest&gt;&gt;&gt;,
    by_name: BTreeMap&lt;String, Rc&lt;RefCell&lt;Guest&gt;&gt;&gt;,
}

impl RcGuestRegister {
    fn register(&amp;mut self, guest: Guest) {
        let name = guest.name.clone();
        let guest = Rc::new(RefCell::new(guest));
        self.by_arrival.push(guest.clone());
        self.by_name.insert(name, guest);
    }
    fn deregister(&amp;mut self, idx: usize) -&gt; Result&lt;(), Error&gt; {
        if idx &gt;= self.by_arrival.len() {
            return Err(Error::new(&quot;out of bounds&quot;));
        }
        self.by_arrival.remove(idx);
        // Oops, still forgot to update `by_name`.
        Ok(())
    }
    // snip
}</code></pre>
<pre><code class="language-text">Register starts as: {
  by_arrival: [{n: 'Alice', ...}, {n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: [(&quot;Alice&quot;, {n: 'Alice', ...}), (&quot;Bob&quot;, {n: 'Bob', ...}), (&quot;Charlie&quot;, {n: 'Charlie', ...})]
}
Register after deregister(0): {
  by_arrival: [{n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: [(&quot;Alice&quot;, {n: 'Alice', ...}), (&quot;Bob&quot;, {n: 'Bob', ...}), (&quot;Charlie&quot;, {n: 'Charlie', ...})]
}
Alice is Some(RefCell { value: {n: 'Alice', ...} })
Bob is Some(RefCell { value: {n: 'Bob', ...} })
Charlie is Some(RefCell { value: {n: 'Charlie', ...} })
</code></pre>
<p>The output is now valid, but there's a lingering entry for Alice that remains until we ensure that the two collections
stay in sync:</p>
<pre><code class="language-rust ignore">    fn deregister_fixed(&amp;mut self, idx: usize) -&gt; Result&lt;(), Error&gt; {
        if idx &gt;= self.by_arrival.len() {
            return Err(Error::new(&quot;out of bounds&quot;));
        }
        let guest: Rc&lt;RefCell&lt;Guest&gt;&gt; = self.by_arrival.remove(idx);
        self.by_name.remove(&amp;guest.borrow().name);
        Ok(())
    }</code></pre>
<pre><code class="language-text">Register after deregister(0): {
  by_arrival: [{n: 'Bob', ...}, {n: 'Charlie', ...}]
  by_name: [(&quot;Bob&quot;, {n: 'Bob', ...}), (&quot;Charlie&quot;, {n: 'Charlie', ...})]
}
Alice is None
Bob is Some(RefCell { value: {n: 'Bob', ...} })
Charlie is Some(RefCell { value: {n: 'Charlie', ...} })
</code></pre>
<h3 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h3>
<p>The final variation of the previous section is an example of a more general approach: <strong>use Rust's smart pointers for
interconnected data structures</strong>.</p>
<p><a href="references.html">Item 9</a> described the most common <a name="a020"></a>smart pointer types provided by Rust's standard library.</p>
<ul>
<li><a name="a021"></a><code>Rc</code> allows shared ownership, with multiple things referring to the same item. Often combined with…</li>
<li><a name="a022"></a><code>RefCell</code> allows interior mutability, so that internal state can be modified without needing a mutable
reference.  This comes at the cost of moving borrow checks from compile-time to run-time.</li>
<li><a name="a023"></a><code>Arc</code> is the multi-threading equivalent to <code>Rc</code>.</li>
<li><a name="a024"></a><code>Mutex</code> (and <a name="a025"></a><code>RwLock</code>) allows interior mutability in a multi-threading environment, roughly equivalent to
<code>RefCell</code>.</li>
<li><a name="a026"></a><code>Cell</code> allows interior mutability for <code>Copy</code> types.</li>
</ul>
<p>For programmers and designs that are adapting from C++ to Rust, the most common tool to reach for is <code>Rc&lt;T&gt;</code> (and its
thread-safe cousin <code>Arc&lt;T&gt;</code>), often combined with <code>RefCell</code> (or the thread-safe alternative <code>Mutex</code>).  A naïve
translation of shared pointers (or even <a name="a027"></a><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a>s) to <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> instances will
generally give something that works in Rust without too much complaint from the borrow checker.  However, this approach
means that you miss out on some of the protections that Rust gives you; in particular, situations where the same item is
mutably borrowed (via <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.borrow_mut"><code>borrow_mut()</code></a>) while
another reference exists result in a run-time <a name="a028"></a><code>panic!</code> rather than a compile-time error.</p>
<p>For example, one pattern that breaks the one-way flow of ownership in tree-like data structures is when there's an
&quot;owner&quot; pointer back from an item to the thing that owns it:</p>
<pre><code class="language-c++">// C++ code (with lackadaisical pointer use)
struct Tree {
  std::string id() const;

  std::string tree_id_;
  std::vector&lt;Branch*&gt; branches_; // `Tree` owns `Branch` objects
};

struct Branch {
  std::string id() const;  // hierarchical identifier for `Branch`

  std::string branch_id_;
  std::vector&lt;Leaf*&gt; leaves_; // `Branch` owns `Leaf` objects
  Tree* owner_; // back-reference to owning `Tree`
};

struct Leaf {
  std::string id() const;  // hierarchical identifier for `Leaf`

  std::string leaf_id_;
  Branch* owner_; // back-reference to owning `Branch`
};

std::string Branch::id() const {
  if (owner_ == nullptr) {
    return &quot;&lt;unowned&gt;.&quot; + branch_id_;
  } else {
    return owner_-&gt;id()+ &quot;.&quot; + branch_id_;
  }
}
</code></pre>
<p>Implementing the equivalent pattern in Rust can make use of <code>Rc&lt;T&gt;</code>'s more tentative partner,
<a name="a029"></a><a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak&lt;T&gt;</code></a>:</p>
<pre><code class="language-rust ignore">struct Tree {
    tree_id: String,
    branches: Vec&lt;Rc&lt;RefCell&lt;Branch&gt;&gt;&gt;,
}

struct Branch {
    branch_id: String,
    leaves: Vec&lt;Rc&lt;RefCell&lt;Leaf&gt;&gt;&gt;,
    owner: Option&lt;Weak&lt;RefCell&lt;Tree&gt;&gt;&gt;,
}

struct Leaf {
    leaf_id: String,
    owner: Option&lt;Weak&lt;RefCell&lt;Branch&gt;&gt;&gt;,
}</code></pre>
<p>The <code>Weak</code> reference doesn't increment the refcount, and so has to explicitly check whether the underlying item
has gone away:</p>
<pre><code class="language-rust ignore">impl Branch {
    fn add_leaf(branch: Rc&lt;RefCell&lt;Branch&gt;&gt;, mut leaf: Leaf) {
        leaf.owner = Some(Rc::downgrade(&amp;branch));
        branch.borrow_mut().leaves.push(Rc::new(RefCell::new(leaf)));
    }
    fn id(&amp;self) -&gt; String {
        match &amp;self.owner {
            None =&gt; format!(&quot;&lt;unowned&gt;.{}&quot;, self.branch_id),
            Some(t) =&gt; {
                let tree = t.upgrade().expect(&quot;internal error: owner gone!&quot;);
                format!(&quot;{}.{}&quot;, tree.borrow().id(), self.branch_id)
            }
        }
    }
}</code></pre>
<p>If Rust's smart pointer don't seem to cover what's needed for your data structures, there's always the final fallback of
writing <a name="a030"></a><code>unsafe</code> code that uses raw (and decidedly un-smart) pointers.  However, as per <a href="unsafe.html">Item 16</a> this should very
much be a last resort – someone else might already have implemented the semantics you want, inside a safe
interface, and if you search the standard library and <a name="a031"></a><code>crates.io</code> you might find it.</p>
<p>For example, imagine that you have a function that sometimes returns a reference to one of its inputs, but sometimes
needs to return some freshly allocated data. In line with <a href="use-types.html">Item 1</a>, an <a name="a032"></a><code>enum</code> that encodes these two possibilities
is the natural way to express this in the type system, and you could then implement various of the pointer traits
described in <a href="references.html">Item 9</a>.  But you don't have to: the standard library already includes the
<a name="a033"></a><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>std::borrow::Cow</code></a> type<sup><a name="to-footnote-3"><a href="#footnote-3">3</a></a></sup> that covers
exactly this scenario once you know it exists.</p>
<h3 id="self-referential-data-structures"><a class="header" href="#self-referential-data-structures">Self-Referential Data Structures</a></h3>
<p>One particular style of data structure always stymies programmers arriving at Rust from other languages:
attempting to create self-referential data structures, which contain a mixture of owned data together with references to
within that owned data.</p>
<pre><code class="language-rust ignore does_not_compile">struct SelfRef {
    text: String,
    // The slice of `text` that holds the title text.
    title: Option&lt;&amp;str&gt;,
}</code></pre>
<p>At a syntactic level, this code won't compile because it doesn't comply with the lifetime rules described in <a href="references.html">Item 9</a>:
the reference needs a lifetime annotation, but we wouldn't want that lifetime annotation to be propagated to the
containing data structure, because the intent is not to refer to anything external.</p>
<p>It's worth thinking about the reason for this restriction at a more semantic level.  Data structures in Rust can <em>move</em>:
from the stack to the heap, from the heap to the stack, and from one place to another.  If that happens, the &quot;interior&quot;
<code>title</code> pointer would no longer be valid, and there's no way to keep it in sync.</p>
<p>A simple alternative for this case is to use the indexing approach explored earlier; a range of offsets into the <code>text</code>
is not invalidated by a move, and is invisible to the borrow checker because it doesn't involve references:</p>
<pre><code class="language-rust ignore">struct SelfRefIdx {
    text: String,
    // Indices into `text` where the title text is.
    title: Option&lt;Range&lt;usize&gt;&gt;,
}</code></pre>
<p>However, this indexing approach only works for simple examples. A more general version of the self-reference problem
turns up when the compiler deals with <a name="a034"></a><code>async</code> code<sup><a name="to-footnote-4"><a href="#footnote-4">4</a></a></sup>.  Roughly speaking, the compiler
bundles up a pending chunk of <code>async</code> code into a lambda, and the data for that lambda can include both values and
references to those values.</p>
<p>That's inherently a self-referential data structure, and so <code>async</code> support was a prime motivation for the
<a name="a037"></a><a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin</code></a> type in the standard library.  This pointer type &quot;pins&quot;
its value in place, forcing the value to remain at the same location in memory, thus ensuring that internal
self-references remain valid.</p>
<p>So <code>Pin</code> is available as a possibility for self-referential types, but it's tricky to use correctly (as its <a href="https://doc.rust-lang.org/std/pin/index.html">official
docs</a> make clear):</p>
<ul>
<li>The internal reference fields need to use raw pointers, or near relatives
(e.g. <a name="a038"></a><a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html"><code>NonNull</code></a>) thereof.</li>
<li>The type being pinned needs to <em>not</em> implement the
<a name="a039"></a><a href="https://doc.rust-lang.org/std/marker/trait.Unpin.html"><code>Unpin</code></a> <a name="a040"></a>marker trait.  This trait is
automatically implemented for almost every type, so this typically involves adding a (zero-sized) field of type
<a name="a041"></a><a href="https://doc.rust-lang.org/std/marker/struct.PhantomPinned.html"><code>PhantomPinned</code></a> to the <a name="a042"></a><code>struct</code>
definition<sup><a name="to-footnote-5"><a href="#footnote-5">5</a></a></sup>.</li>
<li>The item is only pinned once it's on the <a name="a043"></a>heap and held via <code>Pin</code>; in other words, only the contents of something
like <code>Pin&lt;Box&lt;MyType&gt;&gt;</code> is pinned. This means that the internal reference fields can only be safely filled in after
this point, but as they are raw pointers the compiler will give you no warning if you incorrectly set them <em>before</em>
calling <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.pin"><code>Box::pin</code></a>.</li>
</ul>
<p>Where possible, <strong>avoid self-referential data structures</strong> or try to find library crates that encapsulate the
difficulties for you (e.g. <a name="a044"></a><a href="https://crates.io/crates/ouroboros"><code>ouroborous</code></a>).</p>
<p><hr/>
<p><a name="footnote-1"><a href="#to-footnote-1">1</a></a>: However, it may be ownership of
a <em>copy</em> of the item, if the <code>value</code>'s type is <a name="a006"></a><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>;
see <a href="std-traits.html">Item 5</a>.</p>
<p><a name="footnote-2"><a href="#to-footnote-2">2</a></a>: Note that all bets are off with expressions like <code>m!(value)</code> that involve a <a name="a007"></a>macro (<a href="macros.html">Item 28</a>), because it can
expand to arbitrary code.</p>
<p><a name="footnote-3"><a href="#to-footnote-3">3</a></a>: <code>Cow</code> stands for
copy-on-write; a copy of the underlying data is only made if a change (write) needs to be made to it.</p>
<p><a name="footnote-4"><a href="#to-footnote-4">4</a></a>: Dealing with <code>async</code> code is beyond the scope of
this book; to understand more about its need for self-referential data structures, see chapter 8 of <a name="a035"></a><a href="https://rust-for-rustaceans.com/"><em>Rust for
Rustaceans</em></a> by <a name="a036"></a>Jon Gjengset.</p>
<p><a name="footnote-5"><a href="#to-footnote-5">5</a></a>: In <a href="https://github.com/rust-lang/rust/issues/68318">future</a> it may be possible to just declare
<code>impl !Unpin for MyType {}</code></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="lifetimes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="unsafe.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="lifetimes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="unsafe.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/third_party/ferris/ferris.js"></script>


    </div>
    </body>
</html>
