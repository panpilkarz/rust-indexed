<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Item 28: Use macros judiciously - Effective Rust</title>


        <!-- Custom HTML head -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-23228806-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
        <meta name="description" content="A collection of specific ways to improve your use of Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/third_party/ferris/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cover.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="use-types.html"><strong aria-hidden="true">3.1.</strong> Item 1: Use the type system to express your data structures</a></li><li class="chapter-item expanded "><a href="use-types-2.html"><strong aria-hidden="true">3.2.</strong> Item 2: Use the type system to express common behaviour</a></li><li class="chapter-item expanded "><a href="transform.html"><strong aria-hidden="true">3.3.</strong> Item 3: Avoid matching Option and Result</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">3.4.</strong> Item 4: Prefer idiomatic Error variants</a></li><li class="chapter-item expanded "><a href="std-traits.html"><strong aria-hidden="true">3.5.</strong> Item 5: Familiarize yourself with standard traits</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">3.6.</strong> Item 6: Understand type conversions</a></li><li class="chapter-item expanded "><a href="newtype.html"><strong aria-hidden="true">3.7.</strong> Item 7: Embrace the newtype pattern</a></li><li class="chapter-item expanded "><a href="builders.html"><strong aria-hidden="true">3.8.</strong> Item 8: Use builders for complex types</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.9.</strong> Item 9: Familiarize yourself with reference and pointer types</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">3.10.</strong> Item 10: Consider using iterator transforms instead of explicit loops</a></li><li class="chapter-item expanded "><a href="raii.html"><strong aria-hidden="true">3.11.</strong> Item 11: Implement the Drop trait for RAII patterns</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">3.12.</strong> Item 12: Prefer generics to trait objects</a></li><li class="chapter-item expanded "><a href="default-impl.html"><strong aria-hidden="true">3.13.</strong> Item 13: Use default implementations to minimize required trait methods</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">4.1.</strong> Item 14: Understand lifetimes</a></li><li class="chapter-item expanded "><a href="borrows.html"><strong aria-hidden="true">4.2.</strong> Item 15: Understand the borrow checker</a></li><li class="chapter-item expanded "><a href="unsafe.html"><strong aria-hidden="true">4.3.</strong> Item 16: Avoid writing unsafe code</a></li><li class="chapter-item expanded "><a href="deadlock.html"><strong aria-hidden="true">4.4.</strong> Item 17: Be wary of shared-state parallelism</a></li><li class="chapter-item expanded "><a href="panic.html"><strong aria-hidden="true">4.5.</strong> Item 18: Don't panic</a></li><li class="chapter-item expanded "><a href="reflection.html"><strong aria-hidden="true">4.6.</strong> Item 19: Avoid reflection</a></li><li class="chapter-item expanded "><a href="optimize.html"><strong aria-hidden="true">4.7.</strong> Item 20: Avoid the temptation to over-optimize</a></li></ol></li><li class="chapter-item expanded "><a href="deps.html"><strong aria-hidden="true">5.</strong> Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="semver.html"><strong aria-hidden="true">5.1.</strong> Item 21: Understand what semantic versioning promises</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.2.</strong> Item 22: Minimize visibility</a></li><li class="chapter-item expanded "><a href="wildcard.html"><strong aria-hidden="true">5.3.</strong> Item 23: Avoid wildcard imports</a></li><li class="chapter-item expanded "><a href="re-export.html"><strong aria-hidden="true">5.4.</strong> Item 24: Re-export dependencies whose types appear in your API</a></li><li class="chapter-item expanded "><a href="dep-graph.html"><strong aria-hidden="true">5.5.</strong> Item 25: Manage your dependency graph</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">5.6.</strong> Item 26: Be wary of feature creep</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">6.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">6.1.</strong> Item 27: Document public interfaces</a></li><li class="chapter-item expanded "><a href="macros.html" class="active"><strong aria-hidden="true">6.2.</strong> Item 28: Use macros judiciously</a></li><li class="chapter-item expanded "><a href="clippy.html"><strong aria-hidden="true">6.3.</strong> Item 29: Listen to Clippy</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.4.</strong> Item 30: Write more than unit tests</a></li><li class="chapter-item expanded "><a href="use-tools.html"><strong aria-hidden="true">6.5.</strong> Item 31: Take advantage of the tooling ecosystem</a></li><li class="chapter-item expanded "><a href="ci.html"><strong aria-hidden="true">6.6.</strong> Item 32: Set up a continuous integration (CI) system</a></li></ol></li><li class="chapter-item expanded "><a href="beyond-std.html"><strong aria-hidden="true">7.</strong> Beyond Standard Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="no-std.html"><strong aria-hidden="true">7.1.</strong> Item 33: Consider making library code no_std compatible</a></li><li class="chapter-item expanded "><a href="ffi.html"><strong aria-hidden="true">7.2.</strong> Item 34: Control what crosses FFI boundaries</a></li><li class="chapter-item expanded "><a href="bindgen.html"><strong aria-hidden="true">7.3.</strong> Item 35: Prefer bindgen to manual FFI mappings</a></li></ol></li><li class="chapter-item expanded "><a href="indexing.html"><strong aria-hidden="true">8.</strong> Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="item-28-use-macros-judiciously"><a class="header" href="#item-28-use-macros-judiciously">Item 28: Use macros judiciously</a></h1>
<blockquote>
<p>&quot;In some cases it's easy to decide to write a macro instead of a function, because only a macro can do what's needed&quot;
– <a name="a001"></a>Paul Graham, <a name="a002"></a><a href="http://www.paulgraham.com/onlisp.html">&quot;On Lisp&quot;</a></p>
</blockquote>
<p>Rust's <a name="a003"></a>macro systems allow you perform <em><a name="a004"></a>metaprogramming</em>: to write code that emits code into your project.
This is most valuable when there are chunks of &quot;boilerplate&quot; code that are deterministic and repetitive, and which would
otherwise need to be kept in sync manually.</p>
<p>The macros that programmers coming to Rust are most likely to have previously encountered are those provided by
<a name="a005"></a>C/<a name="a006"></a>C++'s <a name="a007"></a>preprocessor.  However, the Rust approach is a completely different beast
– where the C preprocessor performs textual substitution on the tokens of the input text, Rust macros instead
operate on the <em>abstract syntax tree</em> (<a name="a008"></a>AST) of the program.</p>
<p>This means that Rust macros can be aware of code structure and can consequently avoid entire classes of macro-related
footguns. In particular, Rust macros are <a name="a009"></a><a href="https://en.wikipedia.org/wiki/Hygienic_macro"><em>hygienic</em></a>
– they cannot accidentally refer to (&quot;capture&quot;) local variables in the surrounding code.</p>
<p>One way to think about macros is see it as a different level of abstraction in the code.  A simple form of abstraction
is a function: it abstracts away the differences between different values of the same <em>type</em>, with implementation code
that can use any of the features and methods of that type, regardless of the current value being operated on.  A
<a name="a010"></a>generic is a different level of abstraction : it abstracts away the difference between different <em>types</em> that
satisfy a <a name="a011"></a>trait bound, with implementation code that can use any of the methods provided by the trait bounds,
regardless of the current type being operated on.</p>
<p>A macro abstracts away the difference between different chunks of the <a name="a012"></a>AST that play the same role (type,
identifier, expression, etc.); the implementation can then include any code that makes use of those chunks in the same
AST role.</p>
<h2 id="macro-basics"><a class="header" href="#macro-basics">Macro Basics</a></h2>
<p>Although this Item isn't the place to reproduce the <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">documentation for
macros</a>, a few reminders of details to watch out for are in order.</p>
<p>First, be aware that the scoping rules for using a macro are different than for other Rust items.  If a <a name="a013"></a>declarative macro is defined in a source code file, only the code <em>after</em> the macro definition can make use
of it:</p>
<pre><code class="language-rust ignore does_not_compile">fn before() {
    println!(&quot;double {} is {}&quot;, 2, double!(2));
}

macro_rules! double {
    { $e:expr } =&gt; { $e * $e }
}

fn after() {
    println!(&quot;double {} is {}&quot;, 2, double!(2));
}</code></pre>
<pre><code class="language-text">error: cannot find macro `double` in this scope
 --&gt; macros/src/main.rs:4:36
  |
4 |     println!(&quot;double {} is {}&quot;, 2, double!(2));
  |                                    ^^^^^^
  |
  = help: have you added the `#[macro_use]` on the module/import?
</code></pre>
<p>The <a name="a014"></a><code>#[macro_export]</code> attribute makes a macro more widely visible, but this also has an oddity: a
macro appears at the top level of a crate, even if it defined in a module:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod defn {
    #[macro_export]
    macro_rules! treble {
        { $e:expr } =&gt; { $e * $e * $e }
    }
}

mod user {
    pub fn use_macro() {
        // Note: *not* `crate::defn::treble!`
        let cubed = crate::treble!(3);
        println!(&quot;treble {} is {}&quot;, 3, cubed);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a name="a015"></a>Procedural macros (which are macros that get access to the program's syntax tree at compile
time), also have a limitation around code location, in that they must be defined in a separate crate from where they are
used.</p>
<p>Even though Rust's macros are safer than C preprocessor macros, there are still a couple of minor gotchas to be aware
of in their use.</p>
<p>The first is to realize that even if a macro invocation <em>looks</em> like a function invocation, it's not.  In particular,
the normal intuition about whether parameters are moved or <code>&amp;</code>referred to doesn't apply:</p>
<pre><code class="language-rust ignore">    let mut x = Item { contents: 42 }; // type is not `Copy`
    inc!(x); // Item is *not* moved, despite the (x) syntax, and *can* be modified
    println!(&quot;x is {:?}&quot;, x);</code></pre>
<p>The <a name="a016"></a>exclamation mark serves as a warning: the expanded code for the macro may do arbitrary things to/with its
arguments.</p>
<p>The expanded code can also include control flow operations that aren't visible in the calling code, whether they be
loops, conditionals, <a name="a017"></a><code>return</code> statements, or use of the <a name="a018"></a><code>?</code> operator.  Obviously, this is likely to violate
the <a name="a019"></a><a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">principle of least astonishment</a>, so <strong>prefer
macros whose behaviour aligns with normal Rust</strong> where possible.</p>
<p>For example, a macro that silently includes a <code>return</code> in its body:</p>
<pre><code class="language-rust ignore">/// Check that an HTTP status is successful; exit function if not.
macro_rules! check_successful {
    { $e:expr } =&gt; {
        if $e.group() != Group::Successful {
            return Err(MyError(&quot;HTTP operation failed&quot;));
        }
    }
}</code></pre>
<p>makes the control flow of the calling code somewhat obscure:</p>
<pre><code class="language-rust ignore">    let rc = perform_http_operation();
    check_successful!(rc); // may silently exit the function

    // ...</code></pre>
<p>An alternative version of the macro that generates code which emits a
<code>Result</code>:</p>
<pre><code class="language-rust ignore">/// Convert an HTTP status into a `Result&lt;(), MyError&gt;` indicating success.
macro_rules! check_success {
    { $e:expr } =&gt; {
        match $e.group() {
            Group::Successful =&gt; Ok(()),
            _ =&gt; Err(MyError(&quot;HTTP operation failed&quot;)),
        }
    }
}</code></pre>
<p>gives calling code that's easier to follow:</p>
<pre><code class="language-rust ignore">    let rc = perform_http_operation();
    check_success!(rc)?; // error flow is visible via `?`

    // ...</code></pre>
<p>The second thing to watch out for with <a name="a020"></a>declarative macros is a problem shared with the
<a name="a021"></a>C preprocessor: if the argument to a macro is an expression with side effects, watch out for
repeated use of the argument in the macro:</p>
<pre><code class="language-rust ignore not_desired_behaviour">    let mut x = 1;
    let y = double!({
        x += 1;
        x
    });
    println!(&quot;x = {}, y = {}&quot;, x, y);
    // output: x = 3, y = 6</code></pre>
<p>Assuming that this behaviour isn't intended, the solution is simply to evaluate the expression once, and assign the
result to a local variable:</p>
<pre><code class="language-rust ignore">macro_rules! double_once {
    { $e:expr } =&gt; { { let x = $e; x*x } }
}
// output now: x = 2, y = 4</code></pre>
<h2 id="when-to-use-macros"><a class="header" href="#when-to-use-macros">When to use Macros</a></h2>
<p>The primary reason to use macros is to avoid repetitive code.  In this respect, writing a macro is just an extension of
the same kind of generalization process that normally forms part of programming:</p>
<ul>
<li>If you repeat exactly the same code for multiple instances a specific type, encapsulate that code into a common
function and call the function from all of the repeated places.</li>
<li>If you repeat exactly the same code for multiple different types, encapsulate that code into a <a name="a022"></a>generic
and trait bound, and use the generic from all of the repeated places.</li>
<li>If you repeat the same structure of code in multiple different places, encapsulate that code into a <a name="a023"></a>macro, and
use the macro from all of the repeated places.</li>
</ul>
<p>For example, avoiding repetition for code that works on different <a name="a024"></a><code>enum</code> variants can only be done by a macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Multi {
    Byte(u8),
    Int(i32),
    Str(String),
}

#[macro_export]
macro_rules! values_of_type {
    { $values:expr, $variant:ident } =&gt; {
        {
            let mut result = Vec::new();  // explicit use of Vec allows type deduction
            for val in $values {
                if let Multi::$variant(v) = val {
                    result.push(v.clone());
                }
            }
            result
        }
    }
}

fn use_multi() {
    let values = vec![
        Multi::Byte(1),
        Multi::Int(1000),
        Multi::Str(&quot;a string&quot;.to_string()),
        Multi::Byte(2),
    ];
    let ints = values_of_type!(&amp;values, Int);
    assert_eq!(ints, vec![1000]);
    let bytes = values_of_type!(&amp;values, Byte);
    assert_eq!(bytes, vec![1u8, 2u8]);
}
<span class="boring">}</span></code></pre></pre>
<p>Macros also allow for grouping all of the key information about a collection of data values together:</p>
<pre><code class="language-rust ignore">http_codes! {
    Continue =&gt; (100, Informational, &quot;Continue&quot;),
    SwitchingProtocols =&gt; (101, Informational, &quot;Switching Protocols&quot;),
    // ...
    Ok =&gt; (200, Successful, &quot;Ok&quot;),
    Created =&gt; (201, Successful, &quot;Created&quot;),
    // ...
}</code></pre>
<p>Only the information that changes between different values is encoded, in a compact form that acts as a kind of
<a name="a025"></a>domain-specific language (DSL) holding the source-of-truth for the data.  The macro definition then takes care of
generating all of the code that derives from these values:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! http_codes {
    { $( $name:ident =&gt; ($val:literal, $group:ident, $text:literal), )+ } =&gt; {
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[repr(i32)]
        enum Status {
            $( $name = $val, )+
        }
        impl Status {
            fn group(&amp;self) -&gt; Group {
                match self {
                    $( Self::$name =&gt; Group::$group, )+
                }
            }
            fn text(&amp;self) -&gt; &amp;'static str {
                match self {
                    $( Self::$name =&gt; $text, )+
                }
            }
        }
        impl TryFrom&lt;i32&gt; for Status {
            type Error = ();
            fn try_from(v: i32) -&gt; Result&lt;Self, Self::Error&gt; {
                match v {
                    $( $val =&gt; Ok(Self::$name), )+
                    _ =&gt; Err(())
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If an extra value needs to be added later, rather than having to manually adjust four different places, all that's
needed is a single additional line:</p>
<pre><code class="language-rust ignore">    ImATeapot =&gt; (418, ClientError, &quot;I'm a teapot&quot;),</code></pre>
<p>Because macros are expanded in-place in the invoking code, they can also be used to automatically emit additional
diagnostic information – in particular, by using the
<a name="a026"></a><a href="https://doc.rust-lang.org/core/macro.file.html"><code>file!()</code></a> and
<a name="a027"></a><a href="https://doc.rust-lang.org/core/macro.line.html"><code>line!()</code></a> macros from the standard library that emit source code
information:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! diags {
    { $e:expr } =&gt; {
        {
            let result = $e;
            if let Err(err) = &amp;result {
                log::error!(&quot;{}:{}: operation '{}' failed: {:?}&quot;,
                            file!(),
                            line!(),
                            stringify!($e),
                            err);
            }
            result
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>When failures occur, the log file then automatically includes details of what failed and where:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x: Result&lt;u8, _&gt; = diags!(512.try_into());
    let y = diags!(std::str::from_utf8(b&quot;\xc3\x28&quot;)); // invalid UTF-8
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-text">[2023-04-16T08:54:14Z ERROR macros] macros/src/main.rs:239: operation '512.try_into()' failed: TryFromIntError(())
[2023-04-16T08:54:14Z ERROR macros] macros/src/main.rs:240: operation 'std::str::from_utf8(b&quot;\xc3\x28&quot;)' failed: Utf8Error { valid_up_to: 0, error_len: Some(1) }
</code></pre>
<h2 id="disadvantages-of-macros"><a class="header" href="#disadvantages-of-macros">Disadvantages of Macros</a></h2>
<p>The primary disadvantage of using a macro is the impact that it has on code readability and maintainability.  The
previous section explained that macros allow you to create a <a name="a028"></a>domain-specific language to concisely express key
features of your code and data. However, this means that anyone reading or maintaining the code now has to understand
this DSL – and its implementation in macro definitions – in addition to understanding Rust.</p>
<p>This potential impenetrability of macro-based code extends beyond other engineers: various of the tools that analyze and
interact with Rust code may treat the code as opaque, because it no longer necessarily follows the syntactical
conventions of Rust code.  Even the compiler itself is less helpful: its error messages don't always follow the chain
of macro use and definition.</p>
<p>Another possible downside for macro use is the possibility of code bloat – a single line of macro invocation can result
in hundreds of lines of generated code, which will be invisible to a cursory survey of the code.  This is rarely a
problem when the code is first written, because at that point the code is needed and saves the humans involved from
having to write it themselves; however, if the code subsequently stops being necessary, it's not so obvious that there
are large amounts of code that could be deleted.</p>
<h2 id="advice"><a class="header" href="#advice">Advice</a></h2>
<p>Although the previous section listed some downsides of macros, they are still fundamentally the right tool for the job
when there are different chunks of code that need to be kept consistent, but which cannot be coalesced any other way:
<strong>use a macro whenever it's the only way to ensure that disparate code stays in sync</strong>.</p>
<p>Macros are also the tool to reach for when there's boilerplate code to be squashed: <strong>use a macro for repeated
boilerplate code</strong> that can't be coalesced into a function or a generic.</p>
<p>To reduce the impact on readability, try to avoid syntax in your macros that clashes with Rust's normal syntax rules;
either make the macro invocation look like normal code, or make it look sufficiently <em>different</em> that no-one could
confuse the two.  In particular:</p>
<ul>
<li><strong>Avoid macro expansions that insert references</strong> where possible – a macro invocation like <code>my_macro!(&amp;list)</code>
aligns better with normal Rust code than <code>my_macro!(list)</code> would.</li>
<li><strong>Prefer to avoid non-local control flow operations in macros</strong>, so that anyone reading the code is able to follow the
flow without needing to know the details of the macro.</li>
</ul>
<p>This preference for Rust-like readability sometimes affects the choice between declarative macros and procedural macros.
If you need to emit code for each field of a structure, or each variant of an enum, <strong>prefer a <a name="a029"></a>derive macro to a procedural macro that emits a type</strong> (despite the example shown in an earlier section); it's
more idiomatic and makes the code easier to read.</p>
<p>However, if you're adding a derive macro with functionality that's not specific to your project, check whether an
external crate already provides what you need (cf. <a href="dep-graph.html">Item 25</a>).  For example, the problem of converting integer values
into the appropriate variant of a C-like <a name="a030"></a><code>enum</code> is well-covered: all of
<a href="https://docs.rs/enumn/latest/enumn/derive.N.html"><code>enumn::N</code></a>,
<a href="https://docs.rs/num_enum/latest/num_enum/derive.TryFromPrimitive.html"><code>num_enum::ITryFromPrimitive</code></a>,
<a href="https://docs.rs/num-derive/latest/num_derive/derive.FromPrimitive.html"><code>num_derive::FromPrimitive</code></a>, and
<a href="https://docs.rs/strum/latest/strum/derive.FromRepr.html"><code>strum::FromRepr</code></a> cover some aspect of this problem.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="documentation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="clippy.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="documentation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="clippy.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/third_party/ferris/ferris.js"></script>


    </div>
    </body>
</html>
