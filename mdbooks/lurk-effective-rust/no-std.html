<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Item 33: Consider making library code no_std compatible - Effective Rust</title>


        <!-- Custom HTML head -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-23228806-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
        <meta name="description" content="A collection of specific ways to improve your use of Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/third_party/ferris/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cover.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="use-types.html"><strong aria-hidden="true">3.1.</strong> Item 1: Use the type system to express your data structures</a></li><li class="chapter-item expanded "><a href="use-types-2.html"><strong aria-hidden="true">3.2.</strong> Item 2: Use the type system to express common behaviour</a></li><li class="chapter-item expanded "><a href="transform.html"><strong aria-hidden="true">3.3.</strong> Item 3: Avoid matching Option and Result</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">3.4.</strong> Item 4: Prefer idiomatic Error variants</a></li><li class="chapter-item expanded "><a href="std-traits.html"><strong aria-hidden="true">3.5.</strong> Item 5: Familiarize yourself with standard traits</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">3.6.</strong> Item 6: Understand type conversions</a></li><li class="chapter-item expanded "><a href="newtype.html"><strong aria-hidden="true">3.7.</strong> Item 7: Embrace the newtype pattern</a></li><li class="chapter-item expanded "><a href="builders.html"><strong aria-hidden="true">3.8.</strong> Item 8: Use builders for complex types</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.9.</strong> Item 9: Familiarize yourself with reference and pointer types</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">3.10.</strong> Item 10: Consider using iterator transforms instead of explicit loops</a></li><li class="chapter-item expanded "><a href="raii.html"><strong aria-hidden="true">3.11.</strong> Item 11: Implement the Drop trait for RAII patterns</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">3.12.</strong> Item 12: Prefer generics to trait objects</a></li><li class="chapter-item expanded "><a href="default-impl.html"><strong aria-hidden="true">3.13.</strong> Item 13: Use default implementations to minimize required trait methods</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">4.1.</strong> Item 14: Understand lifetimes</a></li><li class="chapter-item expanded "><a href="borrows.html"><strong aria-hidden="true">4.2.</strong> Item 15: Understand the borrow checker</a></li><li class="chapter-item expanded "><a href="unsafe.html"><strong aria-hidden="true">4.3.</strong> Item 16: Avoid writing unsafe code</a></li><li class="chapter-item expanded "><a href="deadlock.html"><strong aria-hidden="true">4.4.</strong> Item 17: Be wary of shared-state parallelism</a></li><li class="chapter-item expanded "><a href="panic.html"><strong aria-hidden="true">4.5.</strong> Item 18: Don't panic</a></li><li class="chapter-item expanded "><a href="reflection.html"><strong aria-hidden="true">4.6.</strong> Item 19: Avoid reflection</a></li><li class="chapter-item expanded "><a href="optimize.html"><strong aria-hidden="true">4.7.</strong> Item 20: Avoid the temptation to over-optimize</a></li></ol></li><li class="chapter-item expanded "><a href="deps.html"><strong aria-hidden="true">5.</strong> Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="semver.html"><strong aria-hidden="true">5.1.</strong> Item 21: Understand what semantic versioning promises</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.2.</strong> Item 22: Minimize visibility</a></li><li class="chapter-item expanded "><a href="wildcard.html"><strong aria-hidden="true">5.3.</strong> Item 23: Avoid wildcard imports</a></li><li class="chapter-item expanded "><a href="re-export.html"><strong aria-hidden="true">5.4.</strong> Item 24: Re-export dependencies whose types appear in your API</a></li><li class="chapter-item expanded "><a href="dep-graph.html"><strong aria-hidden="true">5.5.</strong> Item 25: Manage your dependency graph</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">5.6.</strong> Item 26: Be wary of feature creep</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">6.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">6.1.</strong> Item 27: Document public interfaces</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">6.2.</strong> Item 28: Use macros judiciously</a></li><li class="chapter-item expanded "><a href="clippy.html"><strong aria-hidden="true">6.3.</strong> Item 29: Listen to Clippy</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.4.</strong> Item 30: Write more than unit tests</a></li><li class="chapter-item expanded "><a href="use-tools.html"><strong aria-hidden="true">6.5.</strong> Item 31: Take advantage of the tooling ecosystem</a></li><li class="chapter-item expanded "><a href="ci.html"><strong aria-hidden="true">6.6.</strong> Item 32: Set up a continuous integration (CI) system</a></li></ol></li><li class="chapter-item expanded "><a href="beyond-std.html"><strong aria-hidden="true">7.</strong> Beyond Standard Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="no-std.html" class="active"><strong aria-hidden="true">7.1.</strong> Item 33: Consider making library code no_std compatible</a></li><li class="chapter-item expanded "><a href="ffi.html"><strong aria-hidden="true">7.2.</strong> Item 34: Control what crosses FFI boundaries</a></li><li class="chapter-item expanded "><a href="bindgen.html"><strong aria-hidden="true">7.3.</strong> Item 35: Prefer bindgen to manual FFI mappings</a></li></ol></li><li class="chapter-item expanded "><a href="indexing.html"><strong aria-hidden="true">8.</strong> Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="item-33-consider-making-library-code-no_std-compatible"><a class="header" href="#item-33-consider-making-library-code-no_std-compatible">Item 33: Consider making library code <code>no_std</code> compatible</a></h1>
<p>Rust comes with a standard library called <a name="a001"></a><code>std</code>, which includes code for a wide variety of common tasks, from standard
data structures to networking, from multi-threading support to file I/O.  For convenience, many of the items from <code>std</code>
are automatically imported into your program, via the
<a name="a002"></a><a href="https://doc.rust-lang.org/std/prelude/index.html"><em>prelude</em></a>: a set of common <a name="a003"></a><code>use</code> statements.</p>
<p>Rust also supports building code for environments where it's not possible to provide this full standard library, such as
bootloaders, firmware, or embedded platforms in general.  Crates indicate that they should be built in this way by
including the <a name="a004"></a><code>#![no_std]</code> crate-level attribute at the top of <code>src/lib.rs</code>.</p>
<p>This Item explores what's lost when building for <code>no_std</code>, and what library functions you can still rely on –
which turns out to be quite a lot.</p>
<p>However, this Item is specifically about <code>no_std</code> support in <em>library</em> code.  The difficulties of making a <code>no_std</code>
<em>binary</em> are beyond this text, so the focus here is how to make sure that library code is available for those poor souls
who work in such a minimal environment.</p>
<h2 id="core"><a class="header" href="#core"><code>core</code></a></h2>
<p>Even when building for the most restricted of platforms, many of the fundamental types from the standard library are
still available.  For example, <a name="a005"></a><a href="https://doc.rust-lang.org/core/option/enum.Option.html"><code>Option</code></a> and
<a name="a006"></a><a href="https://doc.rust-lang.org/core/result/enum.Result.html"><code>Result</code></a> are still available, albeit under a different
name, as are various flavours of <a name="a007"></a><a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a>.</p>
<p>The different names for these fundamental types starts with <code>core::</code>, indicating that they come from the <a name="a008"></a><code>core</code>
library, a standard library that's available even in the most <code>no_std</code> of environments. These <code>core::</code> types behave
exactly the same as the equivalent <code>std::</code> types, because they're actually the same types – in each case, the
<code>std::</code> version is just a <a name="a009"></a>re-export of the underlying <code>core::</code> type.</p>
<p>This means that there's an easy way to tell if a <code>std::</code> item is available in <code>no_std</code> environment: visit the
<a href="https://doc.rust-lang.org"><code>doc.rust-lang.org</code></a> page for the <code>std</code> item you're interested in, and follow the &quot;source&quot;
link (at the top-right).  If that takes you to a <code>src/core/...</code> location, then the item is available under <code>no_std</code> via
<code>core::</code>.</p>
<p>The types from <code>core</code> are available for all Rust programs automatically; however, they typically need to be
explicitly <code>use</code>d in a <code>no_std</code> environment, because the <code>std</code> <a name="a010"></a>prelude is absent.</p>
<p>In practice, relying purely on <code>core</code> is too limiting for many environments, even <code>no_std</code> ones.  This is because a
core<sup><a name="to-footnote-1"><a href="#footnote-1">1</a></a></sup> constraint of <code>core</code> is that it performs <strong>no heap allocation</strong>.</p>
<p>Although Rust excels at putting items on the stack, and safely tracking the corresponding lifetimes (<a href="lifetimes.html">Item 14</a>), this
restriction still means that that standard data structures – vectors, maps, sets – can't be provided,
because they need to allocate <a name="a011"></a>heap space for their contents.  In turn, this also drastically reduces the number of
available crates that work in this environment.</p>
<h2 id="alloc"><a class="header" href="#alloc"><code>alloc</code></a></h2>
<p>However, if a <code>no_std</code> environment <em>does</em> support heap allocation, then many of the standard data structures from <code>std</code> can
still be supported.  These data structures, along with other allocation-using functionality, is grouped into Rust's
<a name="a012"></a><a href="https://doc.rust-lang.org/stable/alloc/"><code>alloc</code></a> library.</p>
<p>As with <code>core</code>, these <code>alloc</code> variants are actually the same types under the covers; for example, following the <a href="https://doc.rust-lang.org/stable/src/alloc/vec/mod.rs.html">source
link</a> from the documentation for
<a name="a013"></a><a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>std::vec::Vec</code></a> leads to a <code>src/alloc/...</code> location.</p>
<p>A <code>no_std</code> Rust crate needs to explicitly opt-in to the use of <code>alloc</code>, by adding an <a name="a014"></a><code>extern crate alloc;</code> declaration<sup><a name="to-footnote-2"><a href="#footnote-2">2</a></a></sup> to <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">//! My `no_std` compatible crate.
#![no_std]

// Requires `alloc`.
extern crate alloc;</code></pre>
<p>Functionality that's enabled by turning on <code>alloc</code> includes many familiar friends, now addressed by their true names:</p>
<ul>
<li><a name="a015"></a><a href="https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html"><code>alloc::boxed::Box&lt;T&gt;</code></a></li>
<li><a name="a016"></a><a href="https://doc.rust-lang.org/stable/alloc/rc/struct.Rc.html"><code>alloc::rc::Rc&lt;T&gt;</code></a></li>
<li><a name="a017"></a><a href="https://doc.rust-lang.org/alloc/sync/struct.Arc.html"><code>alloc::sync::Arc&lt;T&gt;</code></a></li>
<li><a name="a018"></a><a href="https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html"><code>alloc::vec::Vec&lt;T&gt;</code></a></li>
<li><a name="a019"></a><a href="https://doc.rust-lang.org/stable/alloc/string/struct.String.html"><code>alloc::string::String</code></a></li>
<li><a name="a020"></a><a href="https://doc.rust-lang.org/stable/alloc/macro.format.html"><code>format!</code></a></li>
<li><a name="a021"></a><a href="https://doc.rust-lang.org/stable/alloc/collections/btree_map/struct.BTreeMap.html"><code>alloc::collections::BTreeMap&lt;K, V&gt;</code></a></li>
<li><a name="a022"></a><a href="https://doc.rust-lang.org/stable/alloc/collections/btree_set/struct.BTreeSet.html"><code>alloc::collections::BTreeSet&lt;T&gt;</code></a></li>
</ul>
<p>With these things available, it becomes possible for many library crates to be <code>no_std</code> compatible – e.g. for libraries
that don't involve I/O or networking.</p>
<p>There's a notable absence from the data structures that <code>alloc</code> makes available, though – the
collections
<a name="a023"></a><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> and
<a name="a024"></a><a href="https://doc.rust-lang.org/std/collections/hash_set/struct.HashSet.html"><code>HashSet</code></a> are specific to <code>std</code>, not <code>alloc</code>.
That's because these hash-based containers rely on random seeds to protect against hash collision attacks, but safe random
number generation requires assistance from the operating system – which <code>alloc</code> can't assume exists.</p>
<p>Another notable absence is synchronization functionality like
<a name="a025"></a><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>std::sync::Mutex</code></a>, which is required for
multi-threaded code (<a href="deadlock.html">Item 17</a>).  These types are specific to <a name="a026"></a><code>std</code> because they rely on OS-specific synchronization
primitives, which aren't available without an OS.  If you need to write code that is both <code>no_std</code> and multi-threaded,
third-party crates such as <a name="a027"></a><a href="https://docs.rs/spin/"><code>spin</code></a> are probably your only option.</p>
<h2 id="writing-code-for-no_std"><a class="header" href="#writing-code-for-no_std">Writing Code for <code>no_std</code></a></h2>
<p>The previous sections made it clear that for <em>some</em> library crates, making the code <code>no_std</code> compatible just involves:</p>
<ul>
<li>Replacing <code>std::</code> types with identical <code>core::</code> or <code>alloc::</code> crates (which requires <a name="a028"></a><code>use</code> of the full type name,
due to the absence of the <code>std</code> <a name="a029"></a>prelude).</li>
<li>Shifting from <code>HashMap</code> / <code>HashSet</code> to <code>BTreeMap</code> / <code>BTreeSet</code>.</li>
</ul>
<p>However, this only makes sense if all of the crates that you depend on (<a href="dep-graph.html">Item 25</a>) are also <code>no_std</code> compatible –
there's no point in becoming <code>no_std</code> compatible if any user of your crate is forced to link in <code>std</code> anyway.</p>
<p>There's also a catch here: the Rust compiler will not tell you if your <code>no_std</code> crate depends on a <code>std</code>-using
dependency. This means that it's easy for the work of making a crate <code>no_std</code>-compatible to be undone – all it
takes is an added or updated dependency that pulls in <code>std</code>.</p>
<p>To protect against this, <strong>add a CI check for a <code>no_std</code> build</strong>, so that your <a name="a030"></a>CI system (<a href="ci.html">Item 32</a>) will warn you if
this happens.  The Rust toolchain supports cross-compilation out of the box, so this can be as simple as performing a
<a href="https://www.reddit.com/r/rust/comments/ef8nd9/how_to_avoid_accidentally_breaking_no_std/fbyz6ix/">cross-compile</a> for a
target system (e.g. <code>--target thumbv6m-none-eabi</code>) that does not support <code>std</code> – any code that inadvertently
requires <code>std</code> will then fail to compile for this target.</p>
<p>So: if your dependencies support it, and the simple transformations above are all that's needed, then <strong>consider making
library code <code>no_std</code> compatible</strong>.  When it is possible, it's not much additional work and it allows for the widest
re-use of the library.</p>
<p>If those transformations <em>don't</em> cover all of the code in your crate, but the parts that aren't covered are only a small
or well-contained fraction of the code, then consider adding a <a name="a031"></a>feature (<a href="features.html">Item 26</a>) to your crate that turns on just
those parts.</p>
<p>Such a feature is conventionally named either <code>std</code>, if it enables use of <code>std</code>-specific functionality:</p>
<pre><code class="language-rust ignore">#![cfg_attr(not(feature = &quot;std&quot;), no_std)]</code></pre>
<p>or <code>alloc</code>, if it turns on use of <code>alloc</code>-derived function:</p>
<pre><code class="language-rust ignore">#[cfg(feature = &quot;alloc&quot;)]
extern crate alloc;</code></pre>
<p>As ever with feature-gated code (<a href="features.html">Item 26</a>), make sure that your CI system builds all the relevant combinations –
including a build with the <code>std</code> feature disabled on an explicitly <code>no_std</code> platform.</p>
<h2 id="fallible-allocation"><a class="header" href="#fallible-allocation">Fallible Allocation</a></h2>
<p>The earlier sections of this Item considered two different <code>no_std</code> environments: a fully embedded environment with no
heap allocation whatsoever (<code>core</code>), or a more generous environment where heap allocation is allowed (<code>core</code> +
<code>alloc</code>).  However, there are some important environments that fall between these two camps.</p>
<p>In particular, Rust's standard <a name="a032"></a><code>alloc</code> library includes a pervasive assumption that <a name="a033"></a>heap allocations cannot fail, and that's not always a valid assumption.</p>
<p>Even a simple use of <code>alloc::vec::Vec</code> could potentially allocate on every line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut v = Vec::new();
    v.push(1); // might allocate
    v.push(2); // might allocate
    v.push(3); // might allocate
    v.push(4); // might allocate
<span class="boring">}</span></code></pre></pre>
<p>None of these operations returns a <code>Result</code>, so what happens if those allocations fail?</p>
<p>The answer to this question depends on the toolchain, target and
<a href="https://doc.rust-lang.org/stable/std/alloc/fn.set_alloc_error_hook.html">configuration</a>, but is likely to involve
<a name="a034"></a><code>panic!</code> and program termination.  There is certainly no answer that allows an allocation failure on line 3 to be
handled in a way that allows the program to move on to line 4.</p>
<p>This assumption of <em><a name="a035"></a>infallible allocation</em> gives good ergonomics for code that runs in a &quot;normal&quot; userspace, where
there's effectively infinite memory (or at least where running out of memory indicates that the computer as a whole is
likely to have bigger problems elsewhere).</p>
<p>However, infallible allocation is utterly unsuitable for code that needs to run in environments where memory is
limited and programs are required to cope.  This is a (rare) area where there's better support in older, less
memory-safe, languages:</p>
<ul>
<li>C is sufficiently low-level that allocations are manual and so the return value from <code>malloc</code> can be checked for <code>NULL</code>.</li>
<li><a name="a036"></a>C++ can use its <a name="a037"></a>exception mechanism<sup><a name="to-footnote-3"><a href="#footnote-3">3</a></a></sup>  to catch allocation failures in the form
of <a href="https://en.cppreference.com/w/cpp/memory/new/bad_alloc"><code>std::bad_alloc</code></a> exceptions.</li>
</ul>
<p>At the time of writing, Rust's inability to cope with failed allocation has been flagged in some high-profile contexts
(such as the <a href="https://lkml.org/lkml/2021/4/14/1099">Linux kernel</a>, Android, and the <a href="https://github.com/hyperium/hyper/issues/2265#issuecomment-693194229">Curl
tool</a>), and so work is on-going to fix the
omission.</p>
<p>The first step is the <a name="a039"></a><a href="https://github.com/rust-lang/rfcs/pull/2116">&quot;fallible collection allocation&quot;
changes</a>, which added <a name="a040"></a>fallible alternatives to many of the collection
APIs that involve allocation.  This generally adds a <code>try_&lt;operation&gt;</code> variant that results a <code>Result&lt;_, AllocError&gt;</code>
(although the <code>try_...</code> variant is currently only available with the nightly toolchain). For example:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.try_new"><code>Box::try_new</code></a> is available as an alternative to
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.new"><code>Box::new</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.try_reserve"><code>Vec::try_reserve</code></a> is available as an
alternative to
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.reserve"><code>Vec::reserve</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html#method.try_insert"><code>BTreeMap::try_insert</code></a>
is available as an alternative to
<a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html#method.insert"><code>BTreeMap::insert</code></a></li>
</ul>
<p>These fallible APIs only go so far; for example, there is (as yet) no fallible equivalent to
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.push"><code>Vec::push</code></a>, so code that assembles a vector may need
to do careful calculations to ensure that allocation errors can't happen:</p>
<pre><code class="language-rust ignore">    let mut v = Vec::new();

    // Perform a careful calculation to figure out how much space is needed,
    // here simplified to...
    let required_size = 4;

    v.try_reserve(required_size).map_err(|_e| {
        MyError::new(format!(&quot;Failed to allocate {} items!&quot;, required_size))
    })?;

    // We now know that it's safe to do:
    v.push(1);
    v.push(2);
    v.push(3);
    v.push(4);</code></pre>
<p>Fallible allocation is an area where work on Rust is on-going.  The entrypoints described above will hopefully be
stabilized and expanded, and there has also been a <a href="https://github.com/rust-lang/rfcs/pull/3140">proposal</a> to make
<em>infallible</em> allocation operations controlled by a default-on <a name="a041"></a>feature – by explicitly disabling the feature, a
programmer can then be sure that no use of infallible allocation has inadvertently crept into their program.</p>
<p><hr/>
<p><a name="footnote-1"><a href="#to-footnote-1">1</a></a>: Pun intended.</p>
<p><a name="footnote-2"><a href="#to-footnote-2">2</a></a>: Prior to Rust 2018, <code>extern crate</code> declarations were used to pull in dependencies.  This
is now entirely handled by <code>Cargo.toml</code>, but the <code>extern crate</code> mechanism is still used to pull in those parts of the
Rust standard library that are optional in <code>no_std</code> environments.</p>
<p><a name="footnote-3"><a href="#to-footnote-3">3</a></a>: It's also possible to add the <a name="a038"></a><a href="https://en.cppreference.com/w/cpp/memory/new/nothrow"><code>std::nothrow</code></a> overload to calls to <code>new</code> and check for
<code>nullptr</code> return values; however, there are still container methods like
<a href="https://en.cppreference.com/w/cpp/container/vector/push_back"><code>vector&lt;T&gt;::push_back</code></a> that allocate under the covers,
and which can therefore only signal allocation failure via an exception.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="beyond-std.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ffi.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="beyond-std.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ffi.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/third_party/ferris/ferris.js"></script>


    </div>
    </body>
</html>
