<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Item 9: Familiarize yourself with reference and pointer types - Effective Rust</title>


        <!-- Custom HTML head -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-23228806-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
        <meta name="description" content="A collection of specific ways to improve your use of Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/third_party/ferris/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cover.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="use-types.html"><strong aria-hidden="true">3.1.</strong> Item 1: Use the type system to express your data structures</a></li><li class="chapter-item expanded "><a href="use-types-2.html"><strong aria-hidden="true">3.2.</strong> Item 2: Use the type system to express common behaviour</a></li><li class="chapter-item expanded "><a href="transform.html"><strong aria-hidden="true">3.3.</strong> Item 3: Avoid matching Option and Result</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">3.4.</strong> Item 4: Prefer idiomatic Error variants</a></li><li class="chapter-item expanded "><a href="std-traits.html"><strong aria-hidden="true">3.5.</strong> Item 5: Familiarize yourself with standard traits</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">3.6.</strong> Item 6: Understand type conversions</a></li><li class="chapter-item expanded "><a href="newtype.html"><strong aria-hidden="true">3.7.</strong> Item 7: Embrace the newtype pattern</a></li><li class="chapter-item expanded "><a href="builders.html"><strong aria-hidden="true">3.8.</strong> Item 8: Use builders for complex types</a></li><li class="chapter-item expanded "><a href="references.html" class="active"><strong aria-hidden="true">3.9.</strong> Item 9: Familiarize yourself with reference and pointer types</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">3.10.</strong> Item 10: Consider using iterator transforms instead of explicit loops</a></li><li class="chapter-item expanded "><a href="raii.html"><strong aria-hidden="true">3.11.</strong> Item 11: Implement the Drop trait for RAII patterns</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">3.12.</strong> Item 12: Prefer generics to trait objects</a></li><li class="chapter-item expanded "><a href="default-impl.html"><strong aria-hidden="true">3.13.</strong> Item 13: Use default implementations to minimize required trait methods</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">4.1.</strong> Item 14: Understand lifetimes</a></li><li class="chapter-item expanded "><a href="borrows.html"><strong aria-hidden="true">4.2.</strong> Item 15: Understand the borrow checker</a></li><li class="chapter-item expanded "><a href="unsafe.html"><strong aria-hidden="true">4.3.</strong> Item 16: Avoid writing unsafe code</a></li><li class="chapter-item expanded "><a href="deadlock.html"><strong aria-hidden="true">4.4.</strong> Item 17: Be wary of shared-state parallelism</a></li><li class="chapter-item expanded "><a href="panic.html"><strong aria-hidden="true">4.5.</strong> Item 18: Don't panic</a></li><li class="chapter-item expanded "><a href="reflection.html"><strong aria-hidden="true">4.6.</strong> Item 19: Avoid reflection</a></li><li class="chapter-item expanded "><a href="optimize.html"><strong aria-hidden="true">4.7.</strong> Item 20: Avoid the temptation to over-optimize</a></li></ol></li><li class="chapter-item expanded "><a href="deps.html"><strong aria-hidden="true">5.</strong> Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="semver.html"><strong aria-hidden="true">5.1.</strong> Item 21: Understand what semantic versioning promises</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.2.</strong> Item 22: Minimize visibility</a></li><li class="chapter-item expanded "><a href="wildcard.html"><strong aria-hidden="true">5.3.</strong> Item 23: Avoid wildcard imports</a></li><li class="chapter-item expanded "><a href="re-export.html"><strong aria-hidden="true">5.4.</strong> Item 24: Re-export dependencies whose types appear in your API</a></li><li class="chapter-item expanded "><a href="dep-graph.html"><strong aria-hidden="true">5.5.</strong> Item 25: Manage your dependency graph</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">5.6.</strong> Item 26: Be wary of feature creep</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">6.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">6.1.</strong> Item 27: Document public interfaces</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">6.2.</strong> Item 28: Use macros judiciously</a></li><li class="chapter-item expanded "><a href="clippy.html"><strong aria-hidden="true">6.3.</strong> Item 29: Listen to Clippy</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.4.</strong> Item 30: Write more than unit tests</a></li><li class="chapter-item expanded "><a href="use-tools.html"><strong aria-hidden="true">6.5.</strong> Item 31: Take advantage of the tooling ecosystem</a></li><li class="chapter-item expanded "><a href="ci.html"><strong aria-hidden="true">6.6.</strong> Item 32: Set up a continuous integration (CI) system</a></li></ol></li><li class="chapter-item expanded "><a href="beyond-std.html"><strong aria-hidden="true">7.</strong> Beyond Standard Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="no-std.html"><strong aria-hidden="true">7.1.</strong> Item 33: Consider making library code no_std compatible</a></li><li class="chapter-item expanded "><a href="ffi.html"><strong aria-hidden="true">7.2.</strong> Item 34: Control what crosses FFI boundaries</a></li><li class="chapter-item expanded "><a href="bindgen.html"><strong aria-hidden="true">7.3.</strong> Item 35: Prefer bindgen to manual FFI mappings</a></li></ol></li><li class="chapter-item expanded "><a href="indexing.html"><strong aria-hidden="true">8.</strong> Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="item-9-familiarize-yourself-with-reference-and-pointer-types"><a class="header" href="#item-9-familiarize-yourself-with-reference-and-pointer-types">Item 9: Familiarize yourself with reference and pointer types</a></h1>
<p>For programming in general, a <em>reference</em> is a way to indirectly access some data structure, separately from whatever
variable owns that data structure.  In practice, this is usually implemented as a <em><a name="a001"></a>pointer</em>: a number whose value
is the address in memory of the data structure.</p>
<p>A modern CPU will typically police a few constraints on pointers – the memory address should be in a valid range
of memory (whether virtual or physical), and may need to be <a name="a002"></a><em>aligned</em> (e.g. a 4-byte integer value might
only be accessible if its address is a multiple of 4).</p>
<p>However, higher level programming languages usually encode more information about pointers in their type systems.  In
C-derived languages, including Rust, pointers have a type that indicates what kind of data structure is expected to be
present at the pointed-to memory address.  This allows the code to interpret the contents of memory at that address, and
in the memory following that address.</p>
<p>This basic level of pointer information – putative memory location and expected data structure layout – is
represented in Rust as a <em><a name="a003"></a>raw pointer</em>.  However, &quot;normal&quot; Rust code does not use raw pointers, because Rust
provides richer reference and pointer types that provide additional safety guarantees and constraints.  These reference
and pointer types are the subject of this Item; raw pointers are relegated to <a href="unsafe.html">Item 16</a> (which discusses <code>unsafe</code> code).</p>
<h2 id="rust-references"><a class="header" href="#rust-references">Rust References</a></h2>
<p>The most ubiquitous pointer-like type in Rust is the <em><a name="a004"></a>reference</em>, whose type is written as <code>&amp;T</code> for some type
<code>T</code>. Although this is a pointer value under the covers, the compiler ensures that various rules around its use are
observed: it must always point to a valid, correctly-aligned instance of the relevant type <code>T</code>, whose lifetime (<a href="lifetimes.html">Item 14</a>) extends beyond its use, and which satisfies the <a name="a005"></a>borrow checking rules (<a href="borrows.html">Item 15</a>).  These
additional constraints are always implied by the term &quot;reference&quot; in Rust, and so the bare term &quot;pointer&quot; is generally
rare.</p>
<p>The constraints that a Rust reference must point to a valid, correctly-aligned item are shared by <a name="a006"></a>C++'s reference
types. However, C++ has no concept of lifetimes and so allows footguns<sup><a name="to-footnote-1"><a href="#footnote-1">1</a></a></sup> with dangling references:</p>
<pre><code class="language-c++ not_desired_behaviour">// C++
const int&amp; dangle() {
  int x = 32; // on the stack, overwritten later
  return x; // return reference to stack variable!
}
</code></pre>
<p>Rust's borrowing and lifetime checks make the equivalent code broken at compile time:</p>
<pre><code class="language-rust ignore does_not_compile">fn dangle() -&gt; &amp;'static i64 {
    let x: i64 = 32; // on the stack
    &amp;x
}</code></pre>
<pre><code class="language-text">error[E0515]: cannot return reference to local variable `x`
   --&gt; references/src/main.rs:399:5
    |
399 |     &amp;x
    |     ^^ returns a reference to data owned by the current function
</code></pre>
<p>A Rust reference <code>&amp;T</code> allows read-only access to the underlying item (roughly equivalent to C++'s <code>const T&amp;</code>).  A
<a name="a007"></a>mutable reference that also allows the underlying item to be modified is written as <code>&amp;mut T</code>, and is also subject
to the borrow checking rules discussed in <a href="borrows.html">Item 15</a>.  This naming pattern reflects a slightly different mindset between
Rust and C++:</p>
<ul>
<li>In Rust, the default variant is read-only, and writable types are marked specially (with <code>mut</code>).</li>
<li>In C++, the default variant is writable, and read-only types are marked specially (with <code>const</code>).</li>
</ul>
<p>In the generated code, a Rust reference is a simple pointer, 8 bytes in size on a 64-bit platform (which this Item
assumes throughout):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct Point {
        x: u32,
        y: u32,
    }
    let pt = Point { x: 1, y: 2 };
    let x = 0u64;
    let ref_x = &amp;x;
    let ref_pt = &amp;pt;
<span class="boring">}</span></code></pre></pre>
<img alt="Stack layout with pointers to local variables" src="images/stack.svg" width=346>
<p>A Rust reference can refer to items that are located either on the <a name="a008"></a>stack or on the <a name="a009"></a>heap.
Rust allocates items on the stack by default, but the <a name="a010"></a><code>Box&lt;T&gt;</code> pointer type (roughly equivalent to C++'s
<a name="a011"></a><code>std::unique_ptr&lt;T&gt;</code>) forces allocation to occur on the heap, which in turn means that
the allocated item can outlive the scope of the current block.  Under the covers, <code>Box&lt;T&gt;</code> is also a simple 8 byte
pointer value.</p>
<pre><code class="language-rust ignore">    let box_pt = Box::new(Point { x: 10, y: 20 });</code></pre>
<img alt="Stack Box pointer to struct on heap" src="images/heap.svg" width=591>
<h2 id="pointer-traits"><a class="header" href="#pointer-traits">Pointer Traits</a></h2>
<p>A method that expects a reference argument like <code>&amp;Point</code> can also be fed a <code>&amp;Box&lt;Point&gt;</code>:</p>
<pre><code class="language-rust ignore">    fn show(pt: &amp;Point) {
        println!(&quot;({}, {})&quot;, pt.x, pt.y);
    }
    show(ref_pt);
    show(&amp;box_pt);</code></pre>
<pre><code class="language-text">(1, 2)
(10, 20)
</code></pre>
<p>This is possible because <code>Box&lt;T&gt;</code> implements the <a name="a012"></a><a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a>
trait, with <code>Target = T</code>.  An implementation of this trait for some type means that the trait's
<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#tymethod.deref"><code>deref()</code></a> method can be used to create a reference
to the <code>Target</code> type.  There's also an equivalent
<a name="a013"></a><a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a> trait, which emits a <em>mutable</em> reference to
the <code>Target</code> type.</p>
<p>The <code>Deref</code> / <code>DerefMut</code> traits are somewhat special, because the Rust compiler has specific behaviour when dealing with
types that implement them.  When the compiler encounters a dereferencing expression
(e.g. <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-dereference-operator"><code>*x</code></a>), it looks for
and uses an implementation of one of these traits, depending on whether the dereference requires mutable access or not.
This <em><code>Deref</code> <a name="a014"></a>coercion</em> allows various smart pointer types to behave like normal references, and is one of the few
mechanisms that allow implicit type conversion in Rust (as described in <a href="casts.html">Item 6</a>).</p>
<p>As a technical aside, it's worth understanding why the <code>Deref</code> traits can't be generic (<code>Deref&lt;Target&gt;</code>) for the
destination type.  If they were, then it would be possible for some type <code>ConfusedPtr</code> to implement both <code>Deref&lt;TypeA&gt;</code>
and <code>Deref&lt;TypeB&gt;</code>, and that would leave the compiler unable to deduce a single unique type for an expression like <code>*x</code>.
So instead the destination type is encoded as the <a name="a015"></a>associated type named <code>Target</code>.</p>
<p>This technical aside provides a contrast to two other standard pointer traits, the
<a name="a016"></a><a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a> and
<a name="a017"></a><a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html"><code>AsMut</code></a> traits.  These traits don't induce special
behaviour in the compiler, but also allow conversions to a reference or mutable reference via an explicit call to their
trait functions ( <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html#tymethod.as_ref"><code>as_ref()</code></a> and
<a href="https://doc.rust-lang.org/std/convert/trait.AsMut.html#tymethod.as_mut"><code>as_mut()</code></a> respectively).  The destination
type for these conversions <em>is</em> encoded as a type parameter (e.g. <code>AsRef&lt;Point&gt;</code>), which means that a single container
type can support multiple destinations.</p>
<p>For example, the standard <a name="a018"></a><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> type implements the
<code>Deref</code> trait with <code>Target = str</code>, meaning that an expression like <code>&amp;my_string</code> can be coerced to type <code>&amp;str</code>.  But it
also implements:</p>
<ul>
<li><code>AsRef&lt;[u8]&gt;</code>, allowing conversion to a byte slice <code>&amp;[u8]</code>.</li>
<li><code>AsRef&lt;OsStr&gt;</code>, allowing conversion to an OS string.</li>
<li><code>AsRef&lt;Path&gt;</code>, allowing conversion to a filesystem path.</li>
<li><code>AsRef&lt;str&gt;</code>, allowing conversion to a string slice <code>&amp;str</code> (as with <code>Deref</code>).</li>
</ul>
<p>We saw above that a function that takes a reference can automatically take any type that implements <code>Deref</code>, via the
<code>Deref</code> coercion that the compiler performs.  Such a function can be made even more general, by making it <a name="a019"></a><em>generic</em> over one of the <code>AsRef</code> / <code>AsMut</code> traits, and changing it to use <code>.as_ref()</code> on the input. This
means it accepts the widest range of reference-like types:</p>
<pre><code class="language-rust ignore">    fn show_as_ref&lt;T: AsRef&lt;Point&gt;&gt;(pt: T) {
        let pt: &amp;Point = pt.as_ref();
        println!(&quot;({}, {})&quot;, pt.x, pt.y);
    }</code></pre>
<h2 id="fat-pointer-types"><a class="header" href="#fat-pointer-types">Fat Pointer Types</a></h2>
<p>Rust has two built-in <em><a name="a020"></a>fat pointer</em> types: types that act as pointers, but which hold additional information about
the thing they are pointing to.</p>
<p>The first such type is the <em><a name="a021"></a>slice</em>: a reference to a subset of some contiguous collection of values.  It's built
from a (non-owning) simple pointer, together with a length field, making it twice the size of a simple pointer (16 bytes
on a 64-bit platform).  The type of a slice is written as <code>&amp;[T]</code> – a reference to <code>[T]</code>, which is the notional
type for a contiguous collection of values of type <code>T</code>.</p>
<p>The notional type <code>[T]</code> can't be instantiated, but there are two common containers that embody it.  The first is the
<em><a name="a022"></a>array</em>: a contiguous collection of values whose size is known at compile time.  A slice can therefore refer to a
subset of an array:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let array = [0u64; 5];
    let slice = &amp;array[1..3];
<span class="boring">}</span></code></pre></pre>
<img alt="Stack slice pointing into stack array" src="images/arrayslice.svg" width=348>
<p>The other common container for contiguous values is a <a name="a023"></a><code>Vec&lt;T&gt;</code>.  This holds a contiguous collection of
values whose size can vary, and whose contents are held on the <a name="a024"></a>heap.  A slice can therefore refer to a subset of a
vector:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut vec = Vec::&lt;u64&gt;::with_capacity(8);
    for i in 0..5 {
        vec.push(i);
    }
    let slice = &amp;vec[1..3];
<span class="boring">}</span></code></pre></pre>
<img alt="Stack slice pointing into vector contents on heap" src="images/vecslice.svg" width=591>
<p>There's quite a lot going on under the covers for the expression <code>&amp;vec[1..3]</code>, so it's worth breaking down into its
components:</p>
<ul>
<li>The <code>1..3</code> part is a <a name="a025"></a><a href="https://doc.rust-lang.org/reference/expressions/range-expr.html">range expression</a>; the
compiler converts this into an instance of the
<a name="a026"></a><a href="https://doc.rust-lang.org/std/ops/struct.Range.html"><code>Range&lt;usize&gt;</code></a> type, which holds an inclusive
lower bound and an exclusive upper bound.</li>
<li>The <code>Range</code> type <a href="https://doc.rust-lang.org/std/ops/struct.Range.html#impl-SliceIndex%3C%5BT%5D%3E">implements</a> the
<a name="a027"></a><a href="https://doc.rust-lang.org/std/slice/trait.SliceIndex.html"><code>SliceIndex&lt;T&gt;</code></a> trait, which describes
indexing operations on slices of an arbitrary type <code>T</code> (so the <code>Output</code> type is <code>[T]</code>).</li>
<li>The <code>vec[ ]</code> part is an <a href="https://doc.rust-lang.org/reference/expressions/array-expr.html#array-and-slice-indexing-expressions">indexing
expression</a>; the
compiler converts this into an invocation of the <a name="a028"></a><a href="https://doc.rust-lang.org/std/ops/trait.Index.html"><code>Index</code></a>
trait's <a href="https://doc.rust-lang.org/std/ops/trait.Index.html#tymethod.index"><code>index</code></a> method on <code>vec</code>, together with a
dereference (i.e. <code>*vec.index( )</code>).
<ul>
<li>The equivalent trait for mutable expressions is
<a name="a029"></a><a href="https://doc.rust-lang.org/std/ops/trait.IndexMut.html"><code>IndexMut</code></a>.</li>
</ul>
</li>
<li><code>vec[1..3]</code> therefore invokes <code>Vec&lt;T&gt;</code>'s
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-Index%3CI%3E">implementation</a> of <code>Index&lt;I&gt;</code>, which requires
<code>I</code> to be an instance of <code>SliceIndex&lt;[u64]&gt;</code>.  This works because <code>Range&lt;usize&gt;</code> implements <code>SliceIndex&lt;[T]&gt;</code> for any
<code>T</code>, including <code>u64</code>.</li>
<li><code>&amp;vec[1..3]</code> un-does the dereference, resulting in a final expression type of <code>&amp;[u64]</code>.</li>
</ul>
<p>The second built-in fat pointer type is a <em><a name="a030"></a>trait object</em>: a reference to some item that implements a particular
trait.  It's built from a simple pointer to the item, together with an internal pointer to the type's <em><a name="a031"></a>vtable</em>,
giving a size of 16 bytes (on a 64-bit platform).  The <a href="https://en.wikipedia.org/wiki/Virtual_method_table">vtable</a> for
a type's implementation of a trait holds function pointers for each of the method implementations, allowing dynamic
dispatch at runtime (<a href="generics.html">Item 12</a>)<sup><a name="to-footnote-2"><a href="#footnote-2">2</a></a></sup>.</p>
<p>So a simple trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    trait Calculate {
        fn add(&amp;self, l: u64, r: u64) -&gt; u64;
        fn mul(&amp;self, l: u64, r: u64) -&gt; u64;
    }
<span class="boring">}</span></code></pre></pre>
<p>with a <code>struct</code> that implements it:</p>
<pre><code class="language-rust ignore">    struct Modulo(pub u64);

    impl Calculate for Modulo {
        fn add(&amp;self, l: u64, r: u64) -&gt; u64 {
            (l + r) % self.0
        }
        fn mul(&amp;self, l: u64, r: u64) -&gt; u64 {
            (l * r) % self.0
        }
    }

    let mod3 = Modulo(3);
</code></pre>
<p>can be converted to a trait object of type <code>&amp;dyn Trait</code> (where the <a href="https://doc.rust-lang.org/std/keyword.dyn.html"><code>dyn</code>
keyword</a> highlights the fact that dynamic dispatch is involved):</p>
<pre><code class="language-rust ignore">    // Need an explicit type to force dynamic dispatch.
    let tobj: &amp;dyn Calculate = &amp;mod3;
    let result = tobj.add(2, 2);
    assert_eq!(result, 1);</code></pre>
<img alt="Trait object with pointers to concrete object and vtable" src="images/traitobject.svg" width=844>
<!-- This picture doesn't show everything. In reality there are a few other things in the vtable: a pointer to the -->
<!-- `Drop` implementation for the type, size of type, alignment of type. -->
<p>Code that holds a trait object can invoke the methods of the trait via the function pointers in the vtable, passing in
the item pointer as the <code>&amp;self</code> parameter; see <a href="generics.html">Item 12</a> for more information and advice.</p>
<h2 id="more-pointer-traits"><a class="header" href="#more-pointer-traits">More Pointer Traits</a></h2>
<p>A previous section described two pairs of traits (<code>Deref</code> / <code>DerefMut</code>, <code>AsRef</code> / <code>AsMut</code>) that are used when dealing
with types that can be easily converted into references.  There are a few more standard traits that can also come into
play when working with pointer-like types, whether from the standard library or user defined.</p>
<p>The simplest of these is the <a name="a034"></a><a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html"><code>Pointer</code></a> trait, which
formats a pointer value for output. This can be helpful for low-level debugging, and the compiler will reach for this
trait automatically when it encounters the <code>{:p}</code> format specifier.</p>
<p>More intriguing are the <a name="a035"></a><a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow</code></a> and
<a name="a036"></a><a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html"><code>BorrowMut</code></a> traits, which each have a single method
(<a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html#tymethod.borrow"><code>borrow</code></a> and
<a href="https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html#tymethod.borrow_mut"><code>borrow_mut</code></a> respectively). This method
has the same signature as the equivalent <code>AsRef</code> / <code>AsMut</code> trait methods.</p>
<p>The key difference in intents between these traits is visible via the <a name="a037"></a>blanket implementations that the standard
library provides.  Given an arbitrary Rust reference <code>&amp;T</code>, there is a blanket implementation of both <code>AsRef</code> and
<code>Borrow</code>; likewise, for a mutable reference <code>&amp;mut T</code>, there's a blanket implementation of both <code>AsMut</code> and <code>BorrowMut</code>.</p>
<p>However, <code>Borrow</code> also has a blanket implementation for (non-reference) types:</p>
<ul>
<li><code>impl&lt;T&gt; Borrow&lt;T&gt; for T</code></li>
</ul>
<p>This means that a method accepting the <code>Borrow</code> trait can cope equally with instances of <code>T</code> as well as references-to-<code>T</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn add_four&lt;T: std::borrow::Borrow&lt;i32&gt;&gt;(v: T) -&gt; i32 {
        v.borrow() + 4
    }
    assert_eq!(add_four(&amp;2), 6);
    assert_eq!(add_four(2), 6);
<span class="boring">}</span></code></pre></pre>
<p>The standard library's container types have more realistic uses of <code>Borrow</code>; for example,
<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.get"><code>HashMap::get</code></a> uses <code>Borrow</code> to allow
convenient retrieval of entries whether keyed by value or by reference.</p>
<p>The <a name="a038"></a><a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html"><code>ToOwned</code></a> trait builds on the <code>Borrow</code>
trait, adding a <a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned"><code>to_owned()</code></a> method that
produces a new owned item of the underlying type.  This is a generalization of the <code>Clone</code> trait: where <code>Clone</code>
specifically requires a Rust reference <code>&amp;T</code>, <code>ToOwned</code> instead copes with things that implement <code>Borrow</code>.</p>
<p>This means that:</p>
<ul>
<li>A function that operates on references to some type can accept <code>Borrow</code> so that it can also be called with moved items
as well as references.</li>
<li>A function that operates on owned items of some type can accept <code>ToOwned</code> so that it can also be called with
references to items as well as moved items; any references passed to it will be replicated into a locally owned item.</li>
</ul>
<p>Although it's not a pointer type, it's worth mentioning the
<a name="a039"></a><a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow</code></a> type at this point, because it provides an alternative
way of dealing with the same kind of situation.  <code>Cow</code> is an <code>enum</code> that can hold either owned data, or a reference to
borrowed data. The peculiar name stands for &quot;clone-on-write&quot;: a <code>Cow</code> input can stay as borrowed data right up to the
point where it needs to be modified, but becomes an owned copy at the point where the data needs to be altered.</p>
<h2 id="smart-pointer-types"><a class="header" href="#smart-pointer-types">Smart Pointer Types</a></h2>
<p>The Rust standard library includes a variety of types that act like pointers to some degree or another, mediated by the
standard library traits described above.  These <em><a name="a040"></a>smart pointer</em> types each come with some particular semantics and
guarantees, which has the advantage that the right combination of them can give fine-grained control over the pointer's
behaviour, but has the disadvantage that the resulting types can seem overwhelming at first (<code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code>
anyone?).</p>
<p>The first smart pointer type is <a name="a041"></a><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a>, which is a
reference-counted pointer to an item (roughly analogous to C++'s <a name="a042"></a><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr&lt;T&gt;</code></a>).  It implements all of the
pointer-related traits, so acts like a <a name="a043"></a><code>Box&lt;T&gt;</code> in many ways.</p>
<p>This is useful for data structures where the same item can be reached in different ways, but it removes one of Rust's
core rules around ownership – that each item has only one owner.  Relaxing this rule means that it is now
possible to leak data: if item A has an <code>Rc</code> pointer to item B, and item B has an <code>Rc</code> pointer to A, then the pair
will never be dropped. To put it another way: you need <code>Rc</code> to support cyclical data structures, but the downside is
that there are now cycles in your data structures.</p>
<p>The risk of leaks can be ameliorated in some cases by the related
<a name="a044"></a><a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak&lt;T&gt;</code></a> type, which holds a non-owning reference to
the underlying item (roughly analogous to C++'s <a name="a045"></a><a href="https://en.cppreference.com/w/cpp/memory/weak_ptr"><code>std::weak_ptr&lt;T&gt;</code></a>).  Holding a weak reference doesn't
prevent the underlying item being dropped (when all strong references are removed), so making use of the <code>Weak&lt;T&gt;</code>
involves an upgrade to an <code>Rc&lt;T&gt;</code> – which can fail.</p>
<p>Under the hood, <code>Rc</code> is (currently) implemented as pair of reference counts together with the referenced items, all
stored on the <a name="a046"></a>heap.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::rc::Rc;
    let rc1: Rc&lt;u64&gt; = Rc::new(42);
    let rc2 = rc1.clone();
    let wk = Rc::downgrade(&amp;rc1);
<span class="boring">}</span></code></pre></pre>
<img alt="Rc and Weak pointers all referring to the same heap item" src="images/rc.svg" width=550>
<p>An <code>Rc</code> on its own gives you the ability to reach an item in different ways, but when you reach that item you can only
modify it (via <a name="a047"></a><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html#method.get_mut"><code>get_mut</code></a>) if there are no other
ways to reach the item – i.e. there are no other extant <code>Rc</code> or <code>Weak</code> references to the same item.  That's hard
to arrange, so <code>Rc</code> is often combined with another smart pointer type…</p>
<p>The next smart pointer type <a name="a048"></a><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a> relaxes the
rule (<a href="borrows.html">Item 15</a>) that an item can only be mutated by its owner or by code that holds the (only) mutable reference to the
item.  This <em><a name="a049"></a>interior mutability</em> allows for greater flexibility – for example, allowing trait
implementations that mutate internals even when the method signature only allows <code>&amp;self</code>.  However, it also incurs
costs: as well as the extra storage overhead (an extra <code>isize</code> to track current borrows), the normal borrow checks are
moved from compile-time to run-time.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use std::cell::RefCell;
    let rc: RefCell&lt;u64&gt; = RefCell::new(42);
    let b1 = rc.borrow();
    let b2 = rc.borrow();
<span class="boring">}</span></code></pre></pre>
<img alt="Ref borrows referring to a RefCell container" src="images/refcell.svg" width=330>
<p>The run-time nature of these checks means that the <code>RefCell</code> user has to choose between two options, neither pleasant:</p>
<ul>
<li>Accept that borrowing is an operation that might fail, and cope with <code>Result</code> values from <code>try_borrow[_mut]</code></li>
<li>Use the allegedly-infallible borrowing methods <code>borrow[_mut]</code>, and accept the risk of a <code>panic!</code> at runtime (<a href="panic.html">Item 18</a>)
if the borrow rules have not been complied with.</li>
</ul>
<p>In either case, this run-time checking means that <code>RefCell</code> itself implements none of the standard pointer traits;
instead, its access operations return a <a name="a050"></a><a href="https://doc.rust-lang.org/std/cell/struct.Ref.html"><code>Ref&lt;T&gt;</code></a> or
<a name="a051"></a><a href="https://doc.rust-lang.org/std/cell/struct.RefMut.html"><code>RefMut&lt;T&gt;</code></a> smart pointer type that does implement those
traits.</p>
<p>If the underlying type <code>T</code> implements the <code>Copy</code> trait (indicating that a fast bit-for-bit copy
produces a valid item, see <a href="std-traits.html">Item 5</a>), then the <a name="a052"></a><code>Cell&lt;T&gt;</code> type allows interior mutation
with less overhead – the <code>get(&amp;self)</code> method copies out the current value, and the <code>set(&amp;self, val)</code> method copies in a new value.  The <code>Cell</code> type is used internally by both the <code>Rc</code> and
<code>RefCell</code> implementations, for shared tracking of counters that can be mutated without a <code>&amp;mut self</code>.</p>
<p>The smart pointer types described so far are only suitable for single threaded use; their implementations assume that
there is no concurrent access to their internals.  If this is not the case, then different smart pointers are needed,
which include the additional synchronization overhead.</p>
<p>The thread-safe equivalent of <code>Rc&lt;T&gt;</code> is <a name="a053"></a><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>,
which uses atomic counters to ensure that the reference counts remain accurate. Like <code>Rc</code>, <code>Arc</code> implements all of the
various pointer-related traits.</p>
<p>However, <code>Arc</code> on its own does not allow any kind of mutable access to the underlying item. This is covered by the
<a name="a054"></a><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> type, which ensures that only one thread has
access – whether mutably or immutably – to the underlying item.  As with <code>RefCell</code>, <code>Mutex</code> itself does not
implement any pointer traits, but its <code>lock()</code> operation returns a value of a type that does:
<a name="a055"></a><a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a>, which implements <code>Deref[Mut]</code>.</p>
<p>If there are likely to be more readers than writers, the
<a name="a056"></a><a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a> type is preferable, as it allows multiple
readers access to the underlying item in parallel, provided that there isn't currently a (single) writer.</p>
<p>In either case, Rust's borrowing and threading rules force the use of one of these synchronization containers in
multi-threaded code (but this only guards against <em>some</em> of the problems of <a name="a057"></a>shared-state concurrency; see <a href="deadlock.html">Item 17</a>).</p>
<p>The same strategy – see what the compiler rejects, and what it suggests instead – can sometimes be
applied with the other smart pointer types; however, it's faster and less frustrating to understand what the behaviour
of the different smart pointers implies. To borrow<sup><a name="to-footnote-3"><a href="#footnote-3">3</a></a></sup> <a href="https://doc.rust-lang.org/1.15.1/book/choosing-your-guarantees.html#composition">an example from the first edition of the
Rust book</a>,</p>
<ul>
<li><code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> holds a vector (<code>Vec</code>) with shared ownership (<code>Rc</code>), where the vector can be mutated – but
only as a whole vector.</li>
<li><code>Rc&lt;Vec&lt;RefCell&lt;T&gt;&gt;&gt;</code> also holds a vector with shared ownership, but here each individual entry in the vector can be
mutated independently of the others.</li>
</ul>
<p>The types involved precisely describe these behaviours.</p>
<p><hr/>
<p><a name="footnote-1"><a href="#to-footnote-1">1</a></a>: Albeit with a warning from modern
compilers.</p>
<p><a name="footnote-2"><a href="#to-footnote-2">2</a></a>: This is somewhat simplified; a full vtable also includes information about the
size and <a name="a032"></a>alignment of the type, together with a <a name="a033"></a><code>drop()</code> function pointer so that the underlying
object can be safely dropped.</p>
<p><a name="footnote-3"><a href="#to-footnote-3">3</a></a>: Pun intended</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="builders.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="builders.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/third_party/ferris/ferris.js"></script>


    </div>
    </body>
</html>
