<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Item 30: Write more than unit tests - Effective Rust</title>


        <!-- Custom HTML head -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-23228806-1']);
          _gaq.push(['_trackPageview']);
        
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
        <meta name="description" content="A collection of specific ways to improve your use of Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/third_party/ferris/ferris.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="cover.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">3.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="use-types.html"><strong aria-hidden="true">3.1.</strong> Item 1: Use the type system to express your data structures</a></li><li class="chapter-item expanded "><a href="use-types-2.html"><strong aria-hidden="true">3.2.</strong> Item 2: Use the type system to express common behaviour</a></li><li class="chapter-item expanded "><a href="transform.html"><strong aria-hidden="true">3.3.</strong> Item 3: Avoid matching Option and Result</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">3.4.</strong> Item 4: Prefer idiomatic Error variants</a></li><li class="chapter-item expanded "><a href="std-traits.html"><strong aria-hidden="true">3.5.</strong> Item 5: Familiarize yourself with standard traits</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">3.6.</strong> Item 6: Understand type conversions</a></li><li class="chapter-item expanded "><a href="newtype.html"><strong aria-hidden="true">3.7.</strong> Item 7: Embrace the newtype pattern</a></li><li class="chapter-item expanded "><a href="builders.html"><strong aria-hidden="true">3.8.</strong> Item 8: Use builders for complex types</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.9.</strong> Item 9: Familiarize yourself with reference and pointer types</a></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">3.10.</strong> Item 10: Consider using iterator transforms instead of explicit loops</a></li><li class="chapter-item expanded "><a href="raii.html"><strong aria-hidden="true">3.11.</strong> Item 11: Implement the Drop trait for RAII patterns</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">3.12.</strong> Item 12: Prefer generics to trait objects</a></li><li class="chapter-item expanded "><a href="default-impl.html"><strong aria-hidden="true">3.13.</strong> Item 13: Use default implementations to minimize required trait methods</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">4.1.</strong> Item 14: Understand lifetimes</a></li><li class="chapter-item expanded "><a href="borrows.html"><strong aria-hidden="true">4.2.</strong> Item 15: Understand the borrow checker</a></li><li class="chapter-item expanded "><a href="unsafe.html"><strong aria-hidden="true">4.3.</strong> Item 16: Avoid writing unsafe code</a></li><li class="chapter-item expanded "><a href="deadlock.html"><strong aria-hidden="true">4.4.</strong> Item 17: Be wary of shared-state parallelism</a></li><li class="chapter-item expanded "><a href="panic.html"><strong aria-hidden="true">4.5.</strong> Item 18: Don't panic</a></li><li class="chapter-item expanded "><a href="reflection.html"><strong aria-hidden="true">4.6.</strong> Item 19: Avoid reflection</a></li><li class="chapter-item expanded "><a href="optimize.html"><strong aria-hidden="true">4.7.</strong> Item 20: Avoid the temptation to over-optimize</a></li></ol></li><li class="chapter-item expanded "><a href="deps.html"><strong aria-hidden="true">5.</strong> Dependencies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="semver.html"><strong aria-hidden="true">5.1.</strong> Item 21: Understand what semantic versioning promises</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.2.</strong> Item 22: Minimize visibility</a></li><li class="chapter-item expanded "><a href="wildcard.html"><strong aria-hidden="true">5.3.</strong> Item 23: Avoid wildcard imports</a></li><li class="chapter-item expanded "><a href="re-export.html"><strong aria-hidden="true">5.4.</strong> Item 24: Re-export dependencies whose types appear in your API</a></li><li class="chapter-item expanded "><a href="dep-graph.html"><strong aria-hidden="true">5.5.</strong> Item 25: Manage your dependency graph</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">5.6.</strong> Item 26: Be wary of feature creep</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">6.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">6.1.</strong> Item 27: Document public interfaces</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">6.2.</strong> Item 28: Use macros judiciously</a></li><li class="chapter-item expanded "><a href="clippy.html"><strong aria-hidden="true">6.3.</strong> Item 29: Listen to Clippy</a></li><li class="chapter-item expanded "><a href="testing.html" class="active"><strong aria-hidden="true">6.4.</strong> Item 30: Write more than unit tests</a></li><li class="chapter-item expanded "><a href="use-tools.html"><strong aria-hidden="true">6.5.</strong> Item 31: Take advantage of the tooling ecosystem</a></li><li class="chapter-item expanded "><a href="ci.html"><strong aria-hidden="true">6.6.</strong> Item 32: Set up a continuous integration (CI) system</a></li></ol></li><li class="chapter-item expanded "><a href="beyond-std.html"><strong aria-hidden="true">7.</strong> Beyond Standard Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="no-std.html"><strong aria-hidden="true">7.1.</strong> Item 33: Consider making library code no_std compatible</a></li><li class="chapter-item expanded "><a href="ffi.html"><strong aria-hidden="true">7.2.</strong> Item 34: Control what crosses FFI boundaries</a></li><li class="chapter-item expanded "><a href="bindgen.html"><strong aria-hidden="true">7.3.</strong> Item 35: Prefer bindgen to manual FFI mappings</a></li></ol></li><li class="chapter-item expanded "><a href="indexing.html"><strong aria-hidden="true">8.</strong> Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Effective Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="item-30-write-more-than-unit-tests"><a class="header" href="#item-30-write-more-than-unit-tests">Item 30: Write more than unit tests</a></h1>
<blockquote>
<p>&quot;All companies have test environments.</p>
<p>The lucky ones have production environments separate from the test environment.&quot; –
<a name="a001"></a><a href="https://twitter.com/FearlessSon/status/1405742580952834051">@FearlessSon</a></p>
</blockquote>
<p>Like most other modern languages, Rust includes features that make it easy to <a name="a002"></a><a href="https://doc.rust-lang.org/book/ch11-00-testing.html">write
tests</a> that live alongside your code,
and which give confidence that the code is working correctly.</p>
<p>This isn't the place to expound on the importance of tests; suffice it to say that if code isn't tested, it probably
doesn't work the way you think it does.  So this Item assumes that you're already signed up to <strong>write tests for your
code</strong>.</p>
<p>Unit tests and integration tests, described in the next two sections, are the key forms of test. However, the Rust
toolchain and extensions to it allow for various other types of test; this Item describes their distinct logistics and
rationales.</p>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h2>
<p>The most common form of test for Rust code is a <a name="a003"></a>unit test, which might look something like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_nat_subtract() {
        assert_eq!(nat_subtract(4, 3).unwrap(), 1);
        assert_eq!(nat_subtract(4, 5), None);
    }

    #[should_panic]
    #[test]
    fn test_something_that_panics() {
        nat_subtract_unchecked(4, 5);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Some aspects of this example will appear in every unit test:</p>
<ul>
<li>a collection of unit test functions, which are…</li>
<li>marked with the <code>#[test]</code> attribute, and included within…</li>
<li>a <code>#[cfg(test)]</code> attribute, so the code only gets built in test configurations.</li>
</ul>
<p>Other aspects of this example illustrate things that are optional, and may only be relevant for particular tests:</p>
<ul>
<li>The test code here is held in a separate <a name="a004"></a>module, conventionally called <code>tests</code> or <code>test</code>.  This module may be
inline (as here), or held in a separate <code>tests.rs</code> file.</li>
<li>The test module may have a wildcard <code>use super::*</code> to pull in everything from the parent module under test.  This
makes it more convenient to add tests (and is an exception to the general advice of <a href="wildcard.html">Item 23</a> to avoid wildcard
imports).</li>
<li>A unit test has the ability to use anything from the parent module, whether it is <a name="a005"></a><code>pub</code> or not.  This allows for
&quot;whitebox&quot; testing of the code, where the unit tests exercise internal features that aren't visible to normal users.</li>
<li>The test code makes use of <code>unwrap()</code> for its expected results; the advice of <a href="panic.html">Item 18</a> isn't really relevant for
test-only code, where <code>panic!</code> is used to signal a failing test.  Similarly, the test code also checks expected
results with <code>assert_eq!</code>, which will panic on failure.</li>
<li>The code under test includes a function that panics on some kinds of invalid input, and the tests exercise that in a
test that's marked with the <code>#[should_panic]</code> attribute. This might be an internal function that normally expects the
rest of the code to respect its invariants and preconditions, or it might be a public function that has some reason
to ignore the advice of <a href="panic.html">Item 18</a>. (Such a function should have a &quot;Panics&quot; section in its doc comment, as described in
<a href="documentation.html">Item 27</a>.)</li>
</ul>
<p><a href="documentation.html">Item 27</a> suggests <em>not</em> documenting things that are already expressed by the type system; similarly, there's no need to
test things that are guaranteed by the type system. If your <code>enum</code> types start start holding values that aren't in the
list of allowed variants, you've got bigger problems than a failing unit test!</p>
<p>However, if your code relies on specific functionality from your dependencies, it can be helpful to include basic tests
of that functionality.  The aim here is not to repeat testing that's already done by the dependency itself, but instead
to have an early warning system that indicates whether it's safe to include a new version of that dependency in practice
– separately from whether the <a name="a006"></a>semantic version number (<a href="semver.html">Item 21</a>) indicates that the new
version is safe in theory.</p>
<h2 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h2>
<p>The other common form of test included with a Rust project is <a name="a007"></a><em>integration tests</em>, held under
<code>tests/</code>.  Each file in that directory is run as a separate test program that executes all of the functions marked with
<code>#[test]</code>.</p>
<p>Integration tests do <em>not</em> have access to crate internals, and so act as black-box tests that can only exercise the
public API of the crate.</p>
<h2 id="doc-tests"><a class="header" href="#doc-tests">Doc Tests</a></h2>
<p><a href="documentation.html">Item 27</a> described the inclusion of short code samples in documentation comments, to illustrate the use of a particular
public API item.  Each such chunk of code is enclosed in an implicit <code>fn main() { ... }</code> and run as part of <code>cargo test</code>, effectively making it an additional test case for your code, known as a <a name="a008"></a><strong>doc test</strong>.  Individual
tests can also be executed selectively by running <code>cargo test --doc &lt;item-name&gt;</code>.</p>
<p>Assuming that you regularly run tests as part of your <a name="a009"></a>continuous integration environment (<a href="ci.html">Item 32</a>), this ensures
that your code samples don't drift too far from the current reality of your API.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p><a href="documentation.html">Item 27</a> also described the ability to provide example programs that exercise your public API. Each Rust file under
<code>examples/</code> (or each subdirectory under <code>examples/</code> that includes a <code>main.rs</code>) can be run as a standalone binary
with <code>cargo run --example &lt;name&gt;</code> or <code>cargo test --example &lt;name&gt;</code>.</p>
<p>These programs only have access to the public API of your crate, and are intended to illustrate the use of your API as a
whole.  Examples are not specifically designated as test code (no <code>#[test]</code>, no <code>#[cfg(test)]</code>), and they're a poor
place to put code that exercises obscure nooks and crannies of your crate – particularly as examples are <strong>not</strong>
run by <code>cargo test</code> by default.</p>
<p>Nevertheless, it's a good idea to ensure that your <a name="a010"></a>continuous integration system (<a href="ci.html">Item 32</a>) builds and runs all
the associated examples for a crate (with <code>cargo test --examples</code>), because it can act as a good early warning system
for regressions that are likely to affect lots of users.  As noted above, if your examples demonstrate mainline use of
your API, then a failure in the examples implies that something significant is wrong.</p>
<ul>
<li>If it's a genuine <a name="a011"></a>bug, then it's likely to affect lots of users – the
very nature of example code means that users are likely to have copied, pasted and adapted the example.</li>
<li>If it's an intended change to the API, then the examples need to be updated to match.  A change to the API also
implies a <a name="a012"></a>backwards incompatibility, so if the crate is published then the semantic version
number needs a corresponding update to indicate this (<a href="semver.html">Item 21</a>).</li>
</ul>
<p>The likelihood of users copying and pasting example code means that it should have a different style than test code. In
line with <a href="panic.html">Item 18</a>, you should set a good example for your users by avoiding <code>unwrap()</code> calls for
<a name="a013"></a><code>Result</code>s. Instead, make each example's <a name="a014"></a><code>main()</code> function return something like <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>, and then use the <a name="a015"></a>question mark operator throughout (<a href="transform.html">Item 3</a>).</p>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<p><a href="optimize.html">Item 20</a> attempts to persuade you that fully optimizing the performance of your code isn't always necessary.
Nevertheless, there are definitely still times when performance is critical, and if that's the case then it's a good
idea to measure and track that performance. Having <em><a name="a016"></a>benchmarks</em> that are run regularly (e.g. as part of continuous
integration, <a href="ci.html">Item 32</a>) allows you to detect when changes to the code or the toolchains adversely affect that
performance.</p>
<p>The <a name="a017"></a><a href="https://doc.rust-lang.org/cargo/commands/cargo-bench.html"><code>cargo bench</code></a> command<sup><a name="to-footnote-1"><a href="#footnote-1">1</a></a></sup> runs special test cases
that repeatedly perform an operation, and emits average timing information for the operation.</p>
<p>However, there's a danger that compiler optimizations may give misleading results, particularly if you restrict the
operation that's being performed to a small subset of the real code.  Consider a simple arithmetic function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn factorial(n: u128) -&gt; u128 {
        match n {
            0 =&gt; 1,
            n =&gt; n * factorial(n - 1),
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>A naïve benchmark for this code:</p>
<pre><code class="language-rust ignore">    #[bench]
    fn bench_factorial(b: &amp;mut Bencher) {
        b.iter(|| {
            let result = factorial(15);
            assert_eq!(result, 1_307_674_368_000);
        });
    }</code></pre>
<p>gives incredibly positive results:</p>
<pre><code class="language-text">test naive::bench_factorial       ... bench:           0 ns/iter (+/- 0)
</code></pre>
<p>With fixed inputs and a small amount of code under test, the compiler is able to optimize away the iteration and
directly emit the result, leading to an unrealistically optimistic result.</p>
<p>The (experimental) <a name="a018"></a><a href="https://doc.rust-lang.org/std/hint/fn.black_box.html"><code>std::hint::black_box</code></a>
function can help with this; it's an identity function <a href="https://rust-lang.github.io/rfcs/2360-bench-black-box.html">whose implementation the compiler is &quot;encouraged, <em>but not
required</em>&quot;</a> (their italics) to pessimize.</p>
<p>Moving the code under test to use this hint:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(bench_black_box)] // nightly-only

<span class="boring">fn main() {
</span>pub fn factorial(n: u128) -&gt; u128 {
    match n {
        0 =&gt; 1,
        n =&gt; n * std::hint::black_box(factorial(n - 1)),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>gives more realistic results:</p>
<pre><code class="language-text">test bench_factorial              ... bench:          42 ns/iter (+/- 6)
</code></pre>
<p>The <a name="a019"></a><a href="https://rust.godbolt.org/">Godbolt compiler explorer</a> can also help by showing the actual machine code
emitted by the compiler, which may make it obvious when the compiler has performed optimizations that would be
unrealistic for code running a real scenario.</p>
<p>Finally, if you are including benchmarks for your Rust code, the <a name="a020"></a><a href="https://crates.io/crates/criterion">Criterion</a>
crate may provide an alternative to the standard
<a href="https://doc.rust-lang.org/test/bench/struct.Bencher.html"><code>test::Bencher</code></a> functionality which is:</p>
<ul>
<li>more convenient (it runs with stable Rust)</li>
<li>more fully-featured (it has support for statistics and graphs).</li>
</ul>
<h2 id="fuzz-testing"><a class="header" href="#fuzz-testing">Fuzz Testing</a></h2>
<p>Fuzz testing is the process of exposing code to randomized inputs in the hope of finding <a name="a021"></a>bugs, particularly
crashes that result from those inputs. Although this can be a useful technique in general, it becomes much more
important when your code is exposed to inputs that may be controlled by someone who is deliberately trying to attack the
code – so you should <strong>run <a name="a022"></a>fuzz tests if your code is exposed to potential attackers</strong>.</p>
<p>Historically, the majority of defects in C/<a name="a023"></a>C++ code that have been exposed by fuzzers have been memory safety problems,
typically found by combining fuzz testing with runtime instrumentation (e.g.
<a name="a024"></a><a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer</a> or
<a name="a025"></a><a href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a>) of memory access patterns.</p>
<p>Rust is immune to some (but not all) of these memory safety problems, particularly when there is no <a name="a026"></a><code>unsafe</code> code
involved (<a href="unsafe.html">Item 16</a>).  However, Rust does not prevent bugs in general, and a code path that triggers a <a name="a027"></a><code>panic!</code>
(cf. <a href="panic.html">Item 18</a>) can still result in a denial-of-service (DoS) attack on the codebase as a whole.</p>
<p>The most effective forms of fuzz testing are <em>coverage-guided</em>: the test infrastructure monitors which parts of the code
are executed, and favours random mutations of the inputs that explore new code paths.  <a name="a028"></a><a href="https://lcamtuf.coredump.cx/afl/">&quot;American fuzzy lop&quot;
(AFL)</a> was the original heavyweight champion of this technique, but in more recent
years equivalent functionality has been included into the LLVM toolchain as
<a name="a029"></a><a href="https://llvm.org/docs/LibFuzzer.html"><code>libFuzzer</code></a>.</p>
<p>The Rust compiler is built on LLVM, and so the <a name="a030"></a><a href="https://github.com/rust-fuzz/cargo-fuzz"><code>cargo-fuzz</code></a> sub-command
exposes <code>libFuzzer</code> functionality for Rust (albeit only for a limited number of platforms).</p>
<p>To set up a fuzz test, first identify an entrypoint of your code that takes (or can be adapted to take) arbitrary bytes
of data as input:</p>
<pre><pre class="playground"><code class="language-rust panics"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Determine if the input starts with &quot;FUZZ&quot;.
fn is_fuzz(data: &amp;[u8]) -&gt; bool {
    if data.len() &gt;= 3 /* oops */
        &amp;&amp; data[0] == b'F'
        &amp;&amp; data[1] == b'U'
        &amp;&amp; data[2] == b'Z'
        &amp;&amp; data[3] == b'Z'
    {
        true
    } else {
        false
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Next, write a small driver that connects this entrypoint to the fuzzing infrastructure:</p>
<pre><code class="language-rust ignore">fuzz_target!(|data: &amp;[u8]| {
    let _ = is_fuzz(data);
});</code></pre>
<p>Running <code>cargo +nightly fuzz run target1</code> continuously executes the fuzz target with random data, only stopping if a
crash is found.  In this case, a failure is found almost immediately:</p>
<pre><code class="language-text">INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 1139733386
INFO: Loaded 1 modules   (1596 inline 8-bit counters): 1596 [0x10cba9c60, 0x10cbaa29c), 
INFO: Loaded 1 PC tables (1596 PCs): 1596 [0x10cbaa2a0,0x10cbb0660), 
INFO:        7 files found in /Users/dmd/src/effective-rust/examples/testing/fuzz/corpus/target1
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
INFO: seed corpus: files: 7 min: 1b max: 8b total: 34b rss: 38Mb
#8	INITED cov: 22 ft: 22 corp: 6/26b exec/s: 0 rss: 38Mb
thread '&lt;unnamed&gt;' panicked at 'index out of bounds: the len is 3 but the index is 3', fuzz_targets/target1.rs:11:12
stack backtrace:
   0: rust_begin_unwind
             at /rustc/f77bfb7336f21bfe6a5fb5f7358d4406e2597289/library/std/src/panicking.rs:579:5
   1: core::panicking::panic_fmt
             at /rustc/f77bfb7336f21bfe6a5fb5f7358d4406e2597289/library/core/src/panicking.rs:64:14
   2: core::panicking::panic_bounds_check
             at /rustc/f77bfb7336f21bfe6a5fb5f7358d4406e2597289/library/core/src/panicking.rs:159:5
   3: _rust_fuzzer_test_input
   4: ___rust_try
   5: _LLVMFuzzerTestOneInput
   6: __ZN6fuzzer6Fuzzer15ExecuteCallbackEPKhm
   7: __ZN6fuzzer6Fuzzer6RunOneEPKhmbPNS_9InputInfoEbPb
   8: __ZN6fuzzer6Fuzzer16MutateAndTestOneEv
   9: __ZN6fuzzer6Fuzzer4LoopERNSt3__16vectorINS_9SizedFileENS_16fuzzer_allocatorIS3_EEEE
  10: __ZN6fuzzer12FuzzerDriverEPiPPPcPFiPKhmE
  11: _main
</code></pre>
<p>and the input that triggered the failure is emitted.</p>
<p>Normally, fuzz testing does not find failures so quickly, and so it does <em>not</em> make sense to run fuzz tests as part of
your <a name="a031"></a>continuous integration.  The open-ended nature of the testing, and the consequent compute costs, mean that you need
to consider how and when to run fuzz tests – perhaps only for new releases or major changes, or perhaps for a
limited period of time<sup><a name="to-footnote-2"><a href="#footnote-2">2</a></a></sup>.</p>
<p>You can also make subsequent runs of the fuzzing infrastructure more efficient, by storing and re-using a <em><a name="a033"></a>corpus</em> of
previous inputs which the fuzzer found to explore new code paths; this helps subsequent runs of the fuzzer explore new
ground, rather than re-testing code paths previously visited.</p>
<h2 id="testing-advice"><a class="header" href="#testing-advice">Testing Advice</a></h2>
<p>An Item about testing wouldn't be complete without repeating some common advice (which is mostly not Rust-specific):</p>
<ul>
<li>As this Item has endlessly repeated, <strong>run all your tests in continuous integration on every change</strong> (with the
exception of fuzz tests).</li>
<li>When you're fixing a bug, <strong>write a test that exhibits the bug before fixing the <a name="a034"></a>bug</strong>.  That way you can be sure that
the bug is fixed, and that it won't be accidentally re-introduced in future.</li>
<li>If your crate has features (<a href="features.html">Item 26</a>), <strong>run tests over every possible combination of available features</strong>.</li>
<li>More generally, if your crate includes any config-specific code (e.g. <code>#[cfg(target_os = &quot;windows&quot;)]</code>), <strong>run tests
for every platform</strong> that has distinct code.</li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This Item has covered a lot of different types of test, so a summary is in order:</p>
<ul>
<li>Write unit tests for comprehensive testing that includes testing of internal-only code; run with <code>cargo test</code>.</li>
<li>Write integration tests to exercise your public API; run with <code>cargo test</code>.</li>
<li>Write doc tests that exemplify how to use individual items in your public API; run with <code>cargo test</code>.</li>
<li>Write example programs that show how to use your public API as a whole; run with <code>cargo test --examples</code> or <code>cargo run --example &lt;name&gt;</code>.</li>
<li>Write benchmarks if your code has significant performance requirements; run with <code>cargo bench</code>.</li>
<li>Write fuzz tests if your code is exposed to untrusted inputs; run (continuously) with <code>cargo fuzz</code>.</li>
</ul>
<p>That's a lot of different types of test, so it's up to you how much each of them is relevant and worthwhile for your
project.</p>
<p>If you have a lot of test code and you are publishing your crate to <a name="a035"></a><a href="https://crates.io"><code>crates.io</code></a>,
then you might need to consider which of the tests make sense to include in the published crate.  By default, <code>cargo</code>
will include unit tests, integration tests, benchmarks and examples (but not fuzz tests), which may be more than end
users need.  If that's the case, you can either
<a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-exclude-and-include-fields"><code>exclude</code></a> some of the files,
or (for black-box tests) move the tests out of the crate and into a separate test crate.</p>
<p><hr/>
<p><a name="footnote-1"><a href="#to-footnote-1">1</a></a>: Support for benchmarks is not stable, so the command may need to be <code>cargo +nightly bench</code>.</p>
<p><a name="footnote-2"><a href="#to-footnote-2">2</a></a>: If your code is a widely-used open-source crate, the <a name="a032"></a><a href="https://google.github.io/oss-fuzz/getting-started/accepting-new-projects/">Google OSS-Fuzz
program</a> may be willing to run fuzzing on
your behalf.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="clippy.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="use-tools.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="clippy.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="use-tools.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/third_party/ferris/ferris.js"></script>


    </div>
    </body>
</html>
